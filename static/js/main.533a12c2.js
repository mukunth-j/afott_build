/*! For license information please see main.533a12c2.js.LICENSE.txt */
(() => { var e = { 115: function (e) { e.exports = function (e) { function t(r) { if (n[r]) return n[r].exports; var i = n[r] = { exports: {}, id: r, loaded: !1 }; return e[r].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports } var n = {}; return t.m = e, t.c = n, t.p = "dist/", t(0) }([function (e, t, n) { "use strict"; function r(e) { return e && e.__esModule ? e : { default: e } } var i = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, s = (r(n(1)), n(6)), o = r(s), a = r(n(7)), l = r(n(8)), c = r(n(9)), u = r(n(10)), d = r(n(11)), h = r(n(14)), f = [], p = !1, m = { offset: 120, delay: 0, easing: "ease", duration: 400, disable: !1, once: !1, startEvent: "DOMContentLoaded", throttleDelay: 99, debounceDelay: 50, disableMutationObserver: !1 }, g = function () { if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (p = !0), p) return f = (0, d.default)(f, m), (0, u.default)(f, m.once), f }, v = function () { f = (0, h.default)(), g() }, y = function () { f.forEach((function (e, t) { e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay") })) }, b = function (e) { return !0 === e || "mobile" === e && c.default.mobile() || "phone" === e && c.default.phone() || "tablet" === e && c.default.tablet() || "function" == typeof e && !0 === e() }, w = function (e) { m = i(m, e), f = (0, h.default)(); var t = document.all && !window.atob; return b(m.disable) || t ? y() : (m.disableMutationObserver || l.default.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), m.disableMutationObserver = !0), document.querySelector("body").setAttribute("data-aos-easing", m.easing), document.querySelector("body").setAttribute("data-aos-duration", m.duration), document.querySelector("body").setAttribute("data-aos-delay", m.delay), "DOMContentLoaded" === m.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? g(!0) : "load" === m.startEvent ? window.addEventListener(m.startEvent, (function () { g(!0) })) : document.addEventListener(m.startEvent, (function () { g(!0) })), window.addEventListener("resize", (0, a.default)(g, m.debounceDelay, !0)), window.addEventListener("orientationchange", (0, a.default)(g, m.debounceDelay, !0)), window.addEventListener("scroll", (0, o.default)((function () { (0, u.default)(f, m.once) }), m.throttleDelay)), m.disableMutationObserver || l.default.ready("[data-aos]", v), f) }; e.exports = { init: w, refresh: g, refreshHard: v } }, function (e, t) { }, , , , , function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function r(t) { var n = m, r = g; return m = g = void 0, N = t, y = e.apply(r, n) } function s(e) { return N = e, b = setTimeout(u, t), C ? r(e) : y } function o(e) { var n = t - (e - w); return T ? E(n, v - (e - N)) : n } function l(e) { var n = e - w; return void 0 === w || n >= t || n < 0 || T && e - N >= v } function u() { var e = S(); return l(e) ? d(e) : void (b = setTimeout(u, o(e))) } function d(e) { return b = void 0, A && m ? r(e) : (m = g = void 0, y) } function h() { void 0 !== b && clearTimeout(b), N = 0, m = w = g = b = void 0 } function f() { return void 0 === b ? y : d(S()) } function p() { var e = S(), n = l(e); if (m = arguments, g = this, w = e, n) { if (void 0 === b) return s(w); if (T) return b = setTimeout(u, t), r(w) } return void 0 === b && (b = setTimeout(u, t)), y } var m, g, v, y, b, w, N = 0, C = !1, T = !1, A = !0; if ("function" != typeof e) throw new TypeError(c); return t = a(t) || 0, i(n) && (C = !!n.leading, v = (T = "maxWait" in n) ? x(a(n.maxWait) || 0, t) : v, A = "trailing" in n ? !!n.trailing : A), p.cancel = h, p.flush = f, p } function r(e, t, r) { var s = !0, o = !0; if ("function" != typeof e) throw new TypeError(c); return i(r) && (s = "leading" in r ? !!r.leading : s, o = "trailing" in r ? !!r.trailing : o), n(e, t, { leading: s, maxWait: t, trailing: o }) } function i(e) { var t = "undefined" == typeof e ? "undefined" : l(e); return !!e && ("object" == t || "function" == t) } function s(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : l(e)) } function o(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : l(e)) || s(e) && w.call(e) == d } function a(e) { if ("number" == typeof e) return e; if (o(e)) return u; if (i(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = i(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(h, ""); var n = p.test(e); return n || m.test(e) ? g(e.slice(2), n ? 2 : 8) : f.test(e) ? u : +e } var l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, c = "Expected a function", u = NaN, d = "[object Symbol]", h = /^\s+|\s+$/g, f = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, m = /^0o[0-7]+$/i, g = parseInt, v = "object" == ("undefined" == typeof t ? "undefined" : l(t)) && t && t.Object === Object && t, y = "object" == ("undefined" == typeof self ? "undefined" : l(self)) && self && self.Object === Object && self, b = v || y || Function("return this")(), w = Object.prototype.toString, x = Math.max, E = Math.min, S = function () { return b.Date.now() }; e.exports = r }).call(t, function () { return this }()) }, function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function i(t) { var n = m, r = g; return m = g = void 0, N = t, y = e.apply(r, n) } function s(e) { return N = e, b = setTimeout(u, t), C ? i(e) : y } function a(e) { var n = t - (e - S); return T ? x(n, v - (e - N)) : n } function c(e) { var n = e - S; return void 0 === S || n >= t || n < 0 || T && e - N >= v } function u() { var e = E(); return c(e) ? d(e) : void (b = setTimeout(u, a(e))) } function d(e) { return b = void 0, A && m ? i(e) : (m = g = void 0, y) } function h() { void 0 !== b && clearTimeout(b), N = 0, m = S = g = b = void 0 } function f() { return void 0 === b ? y : d(E()) } function p() { var e = E(), n = c(e); if (m = arguments, g = this, S = e, n) { if (void 0 === b) return s(S); if (T) return b = setTimeout(u, t), i(S) } return void 0 === b && (b = setTimeout(u, t)), y } var m, g, v, y, b, S, N = 0, C = !1, T = !1, A = !0; if ("function" != typeof e) throw new TypeError(l); return t = o(t) || 0, r(n) && (C = !!n.leading, v = (T = "maxWait" in n) ? w(o(n.maxWait) || 0, t) : v, A = "trailing" in n ? !!n.trailing : A), p.cancel = h, p.flush = f, p } function r(e) { var t = "undefined" == typeof e ? "undefined" : a(e); return !!e && ("object" == t || "function" == t) } function i(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : a(e)) } function s(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : a(e)) || i(e) && b.call(e) == u } function o(e) { if ("number" == typeof e) return e; if (s(e)) return c; if (r(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = r(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(d, ""); var n = f.test(e); return n || p.test(e) ? m(e.slice(2), n ? 2 : 8) : h.test(e) ? c : +e } var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, l = "Expected a function", c = NaN, u = "[object Symbol]", d = /^\s+|\s+$/g, h = /^[-+]0x[0-9a-f]+$/i, f = /^0b[01]+$/i, p = /^0o[0-7]+$/i, m = parseInt, g = "object" == ("undefined" == typeof t ? "undefined" : a(t)) && t && t.Object === Object && t, v = "object" == ("undefined" == typeof self ? "undefined" : a(self)) && self && self.Object === Object && self, y = g || v || Function("return this")(), b = Object.prototype.toString, w = Math.max, x = Math.min, E = function () { return y.Date.now() }; e.exports = n }).call(t, function () { return this }()) }, function (e, t) { "use strict"; function n(e) { var t = void 0, r = void 0; for (t = 0; t < e.length; t += 1) { if ((r = e[t]).dataset && r.dataset.aos) return !0; if (r.children && n(r.children)) return !0 } return !1 } function r() { return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver } function i() { return !!r() } function s(e, t) { var n = window.document, i = new (r())(o); a = t, i.observe(n.documentElement, { childList: !0, subtree: !0, removedNodes: !0 }) } function o(e) { e && e.forEach((function (e) { var t = Array.prototype.slice.call(e.addedNodes), r = Array.prototype.slice.call(e.removedNodes); if (n(t.concat(r))) return a() })) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = function () { }; t.default = { isSupported: i, ready: s } }, function (e, t) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function r() { return navigator.userAgent || navigator.vendor || window.opera || "" } Object.defineProperty(t, "__esModule", { value: !0 }); var i = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(), s = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, o = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, a = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, l = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, c = function () { function e() { n(this, e) } return i(e, [{ key: "phone", value: function () { var e = r(); return !(!s.test(e) && !o.test(e.substr(0, 4))) } }, { key: "mobile", value: function () { var e = r(); return !(!a.test(e) && !l.test(e.substr(0, 4))) } }, { key: "tablet", value: function () { return this.mobile() && !this.phone() } }]), e }(); t.default = new c }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e, t, n) { var r = e.node.getAttribute("data-aos-once"); t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof r && ("false" === r || !n && "true" !== r) && e.node.classList.remove("aos-animate") }, r = function (e, t) { var r = window.pageYOffset, i = window.innerHeight; e.forEach((function (e, s) { n(e, i + r, t) })) }; t.default = r }, function (e, t, n) { "use strict"; function r(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = r(n(12)), s = function (e, t) { return e.forEach((function (e, n) { e.node.classList.add("aos-init"), e.position = (0, i.default)(e.node, t.offset) })), e }; t.default = s }, function (e, t, n) { "use strict"; function r(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = r(n(13)), s = function (e, t) { var n = 0, r = 0, s = window.innerHeight, o = { offset: e.getAttribute("data-aos-offset"), anchor: e.getAttribute("data-aos-anchor"), anchorPlacement: e.getAttribute("data-aos-anchor-placement") }; switch (o.offset && !isNaN(o.offset) && (r = parseInt(o.offset)), o.anchor && document.querySelectorAll(o.anchor) && (e = document.querySelectorAll(o.anchor)[0]), n = (0, i.default)(e).top, o.anchorPlacement) { case "top-bottom": break; case "center-bottom": n += e.offsetHeight / 2; break; case "bottom-bottom": n += e.offsetHeight; break; case "top-center": n += s / 2; break; case "bottom-center": n += s / 2 + e.offsetHeight; break; case "center-center": n += s / 2 + e.offsetHeight / 2; break; case "top-top": n += s; break; case "bottom-top": n += e.offsetHeight + s; break; case "center-top": n += e.offsetHeight / 2 + s }return o.anchorPlacement || o.offset || isNaN(t) || (r = t), n + r }; t.default = s }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent; return { top: n, left: t } }; t.default = n }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { return e = e || document.querySelectorAll("[data-aos]"), Array.prototype.map.call(e, (function (e) { return { node: e } })) }; t.default = n }]) }, 740: e => { "use strict"; e.exports = function (e, t, n, r, i, s, o, a) { if (!e) { var l; if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, i, s, o, a], u = 0; (l = new Error(t.replace(/%s/g, (function () { return c[u++] })))).name = "Invariant Violation" } throw l.framesToPop = 1, l } } }, 197: (e, t, n) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return (0, s.default)((function () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; var i = null; return t.forEach((function (e) { if (null == i) { var t = e.apply(void 0, n); null != t && (i = t) } })), i })) }; var r, i = n(534), s = (r = i) && r.__esModule ? r : { default: r }; e.exports = t.default }, 534: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) { function t(t, n, r, i, s, o) { var a = i || "<<anonymous>>", l = o || r; if (null == n[r]) return t ? new Error("Required " + s + " `" + l + "` was not specified in `" + a + "`.") : null; for (var c = arguments.length, u = Array(c > 6 ? c - 6 : 0), d = 6; d < c; d++)u[d - 6] = arguments[d]; return e.apply(void 0, [n, r, a, s, l].concat(u)) } var n = t.bind(null, !1); return n.isRequired = t.bind(null, !0), n }, e.exports = t.default }, 497: (e, t, n) => { "use strict"; var r = n(218); function i() { } function s() { } s.resetWarningCache = i, e.exports = function () { function e(e, t, n, i, s, o) { if (o !== r) { var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw a.name = "Invariant Violation", a } } function t() { return e } e.isRequired = e; var n = { array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: s, resetWarningCache: i }; return n.PropTypes = n, n } }, 173: (e, t, n) => { e.exports = n(497)() }, 218: e => { "use strict"; e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED" }, 730: (e, t, n) => { "use strict"; var r = n(43), i = n(853); function s(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = new Set, a = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (a[e] = t, e = 0; e < t.length; e++)o.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, p = {}; function m(e, t, n, r, i, s, o) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var v = /[\-:]([a-z])/g; function y(e) { return e[1].toUpperCase() } function b(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null === t || "undefined" === typeof t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, x = Symbol.for("react.element"), E = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), N = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), A = Symbol.for("react.context"), k = Symbol.for("react.forward_ref"), j = Symbol.for("react.suspense"), P = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), R = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var O = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var D = Symbol.iterator; function _(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = D && e[D] || e["@@iterator"]) ? e : null } var M, L = Object.assign; function F(e) { if (void 0 === M) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); M = t && t[1] || "" } return "\n" + M + e } var U = !1; function B(e, t) { if (!e || U) return ""; U = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) { if (c && r && "string" === typeof c.stack) { for (var i = c.stack.split("\n"), s = r.stack.split("\n"), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (i[o] !== s[a]) { if (1 !== o || 1 !== a) do { if (o--, 0 > --a || i[o] !== s[a]) { var l = "\n" + i[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= o && 0 <= a); break } } } finally { U = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? F(e) : "" } function V(e) { switch (e.tag) { case 5: return F(e.type); case 16: return F("Lazy"); case 13: return F("Suspense"); case 19: return F("SuspenseList"); case 0: case 2: case 15: return e = B(e.type, !1); case 11: return e = B(e.type.render, !1); case 1: return e = B(e.type, !0); default: return "" } } function z(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case S: return "Fragment"; case E: return "Portal"; case C: return "Profiler"; case N: return "StrictMode"; case j: return "Suspense"; case P: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case A: return (e.displayName || "Context") + ".Consumer"; case T: return (e._context.displayName || "Context") + ".Provider"; case k: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case I: return null !== (t = e.displayName || null) ? t : z(e.type) || "Memo"; case R: t = e._payload, e = e._init; try { return z(e(t)) } catch (n) { } }return null } function q(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return z(t); case 8: return t === N ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function H(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function W(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function K(e) { e._valueTracker || (e._valueTracker = function (e) { var t = W(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var i = n.get, s = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, s.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function G(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = W(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function Q(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function Y(e, t) { var n = t.checked; return L({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function J(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = H(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function X(e, t) { null != (t = t.checked) && b(e, "checked", t, !1) } function Z(e, t) { X(e, t); var n = H(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, H(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function $(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && Q(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + H(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(s(91)); return L({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(s(92)); if (te(n)) { if (1 < n.length) throw Error(s(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: H(n) } } function se(e, t) { var n = H(t.value), r = H(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function oe(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function ae(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? ae(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var fe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(fe).forEach((function (e) { pe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e] })) })); var ve = L({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ye(e, t) { if (t) { if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(s(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(s(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(s(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(s(62)) } } function be(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var we = null; function xe(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var Ee = null, Se = null, Ne = null; function Ce(e) { if (e = bi(e)) { if ("function" !== typeof Ee) throw Error(s(280)); var t = e.stateNode; t && (t = xi(t), Ee(e.stateNode, e.type, t)) } } function Te(e) { Se ? Ne ? Ne.push(e) : Ne = [e] : Se = e } function Ae() { if (Se) { var e = Se, t = Ne; if (Ne = Se = null, Ce(e), t) for (e = 0; e < t.length; e++)Ce(t[e]) } } function ke(e, t) { return e(t) } function je() { } var Pe = !1; function Ie(e, t, n) { if (Pe) return e(t, n); Pe = !0; try { return ke(e, t, n) } finally { Pe = !1, (null !== Se || null !== Ne) && (je(), Ae()) } } function Re(e, t) { var n = e.stateNode; if (null === n) return null; var r = xi(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(s(231, t, typeof n)); return n } var Oe = !1; if (u) try { var De = {}; Object.defineProperty(De, "passive", { get: function () { Oe = !0 } }), window.addEventListener("test", De, De), window.removeEventListener("test", De, De) } catch (ue) { Oe = !1 } function _e(e, t, n, r, i, s, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var Me = !1, Le = null, Fe = !1, Ue = null, Be = { onError: function (e) { Me = !0, Le = e } }; function Ve(e, t, n, r, i, s, o, a, l) { Me = !1, Le = null, _e.apply(Be, arguments) } function ze(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function qe(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function He(e) { if (ze(e) !== e) throw Error(s(188)) } function We(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = ze(e))) throw Error(s(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var o = i.alternate; if (null === o) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return He(i), e; if (o === r) return He(i), t; o = o.sibling } throw Error(s(188)) } if (n.return !== r.return) n = i, r = o; else { for (var a = !1, l = i.child; l;) { if (l === n) { a = !0, n = i, r = o; break } if (l === r) { a = !0, r = i, n = o; break } l = l.sibling } if (!a) { for (l = o.child; l;) { if (l === n) { a = !0, n = o, r = i; break } if (l === r) { a = !0, r = o, n = i; break } l = l.sibling } if (!a) throw Error(s(189)) } } if (n.alternate !== r) throw Error(s(190)) } if (3 !== n.tag) throw Error(s(188)); return n.stateNode.current === n ? e : t }(e)) ? Ke(e) : null } function Ke(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Ke(e); if (null !== t) return t; e = e.sibling } return null } var Ge = i.unstable_scheduleCallback, Qe = i.unstable_cancelCallback, Ye = i.unstable_shouldYield, Je = i.unstable_requestPaint, Xe = i.unstable_now, Ze = i.unstable_getCurrentPriorityLevel, $e = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, st = null; var ot = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (at(e) / lt | 0) | 0 }, at = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, s = e.pingedLanes, o = 268435455 & n; if (0 !== o) { var a = o & ~i; 0 !== a ? r = dt(a) : 0 !== (s &= o) && (r = dt(s)) } else 0 !== (o = n & ~i) ? r = dt(o) : 0 !== s && (r = dt(s)); if (0 === r) return 0; if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (s = t & -t) || 16 === i && 0 !== (4194240 & s))) return t; if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - ot(t)), r |= e[n], t &= ~i; return r } function ft(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function pt(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function vt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - ot(t)] = n } function yt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - ot(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var bt = 0; function wt(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var xt, Et, St, Nt, Ct, Tt = !1, At = [], kt = null, jt = null, Pt = null, It = new Map, Rt = new Map, Ot = [], Dt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function _t(e, t) { switch (e) { case "focusin": case "focusout": kt = null; break; case "dragenter": case "dragleave": jt = null; break; case "mouseover": case "mouseout": Pt = null; break; case "pointerover": case "pointerout": It.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Rt.delete(t.pointerId) } } function Mt(e, t, n, r, i, s) { return null === e || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, null !== t && (null !== (t = bi(t)) && Et(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function Lt(e) { var t = yi(e.target); if (null !== t) { var n = ze(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = qe(n))) return e.blockedOn = t, void Ct(e.priority, (function () { St(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Ft(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Yt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = bi(n)) && Et(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); we = r, n.target.dispatchEvent(r), we = null, t.shift() } return !0 } function Ut(e, t, n) { Ft(e) && n.delete(t) } function Bt() { Tt = !1, null !== kt && Ft(kt) && (kt = null), null !== jt && Ft(jt) && (jt = null), null !== Pt && Ft(Pt) && (Pt = null), It.forEach(Ut), Rt.forEach(Ut) } function Vt(e, t) { e.blockedOn === t && (e.blockedOn = null, Tt || (Tt = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Bt))) } function zt(e) { function t(t) { return Vt(t, e) } if (0 < At.length) { Vt(At[0], e); for (var n = 1; n < At.length; n++) { var r = At[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== kt && Vt(kt, e), null !== jt && Vt(jt, e), null !== Pt && Vt(Pt, e), It.forEach(t), Rt.forEach(t), n = 0; n < Ot.length; n++)(r = Ot[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Ot.length && null === (n = Ot[0]).blockedOn;)Lt(n), null === n.blockedOn && Ot.shift() } var qt = w.ReactCurrentBatchConfig, Ht = !0; function Wt(e, t, n, r) { var i = bt, s = qt.transition; qt.transition = null; try { bt = 1, Gt(e, t, n, r) } finally { bt = i, qt.transition = s } } function Kt(e, t, n, r) { var i = bt, s = qt.transition; qt.transition = null; try { bt = 4, Gt(e, t, n, r) } finally { bt = i, qt.transition = s } } function Gt(e, t, n, r) { if (Ht) { var i = Yt(e, t, n, r); if (null === i) Hr(e, t, r, Qt, n), _t(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return kt = Mt(kt, e, t, n, r, i), !0; case "dragenter": return jt = Mt(jt, e, t, n, r, i), !0; case "mouseover": return Pt = Mt(Pt, e, t, n, r, i), !0; case "pointerover": var s = i.pointerId; return It.set(s, Mt(It.get(s) || null, e, t, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, Rt.set(s, Mt(Rt.get(s) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (_t(e, r), 4 & t && -1 < Dt.indexOf(e)) { for (; null !== i;) { var s = bi(i); if (null !== s && xt(s), null === (s = Yt(e, t, n, r)) && Hr(e, t, r, Qt, n), s === i) break; i = s } null !== i && r.stopPropagation() } else Hr(e, t, r, null, n) } } var Qt = null; function Yt(e, t, n, r) { if (Qt = null, null !== (e = yi(e = xe(r)))) if (null === (t = ze(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = qe(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Qt = e, null } function Jt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Ze()) { case $e: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var Xt = null, Zt = null, $t = null; function en() { if ($t) return $t; var e, t, n = Zt, r = n.length, i = "value" in Xt ? Xt.value : Xt.textContent, s = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var o = r - e; for (t = 1; t <= o && n[r - t] === i[s - t]; t++); return $t = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function sn(e) { function t(t, n, r, i, s) { for (var o in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = s, this.currentTarget = null, e) e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return L(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var on, an, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = sn(cn), dn = L({}, cn, { view: 0, detail: 0 }), hn = sn(dn), fn = L({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Cn, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (on = e.screenX - ln.screenX, an = e.screenY - ln.screenY) : an = on = 0, ln = e), on) }, movementY: function (e) { return "movementY" in e ? e.movementY : an } }), pn = sn(fn), mn = sn(L({}, fn, { dataTransfer: 0 })), gn = sn(L({}, dn, { relatedTarget: 0 })), vn = sn(L({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), yn = L({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), bn = sn(yn), wn = sn(L({}, cn, { data: 0 })), xn = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, En = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Sn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Nn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e] } function Cn() { return Nn } var Tn = L({}, dn, { key: function (e) { if (e.key) { var t = xn[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? En[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Cn, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), An = sn(Tn), kn = sn(L({}, fn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), jn = sn(L({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Cn })), Pn = sn(L({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), In = L({}, fn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Rn = sn(In), On = [9, 13, 27, 32], Dn = u && "CompositionEvent" in window, _n = null; u && "documentMode" in document && (_n = document.documentMode); var Mn = u && "TextEvent" in window && !_n, Ln = u && (!Dn || _n && 8 < _n && 11 >= _n), Fn = String.fromCharCode(32), Un = !1; function Bn(e, t) { switch (e) { case "keyup": return -1 !== On.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Vn(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var zn = !1; var qn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Hn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!qn[e.type] : "textarea" === t } function Wn(e, t, n, r) { Te(r), 0 < (t = Kr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Kn = null, Gn = null; function Qn(e) { Fr(e, 0) } function Yn(e) { if (G(wi(e))) return e } function Jn(e, t) { if ("change" === e) return t } var Xn = !1; if (u) { var Zn; if (u) { var $n = "oninput" in document; if (!$n) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), $n = "function" === typeof er.oninput } Zn = $n } else Zn = !1; Xn = Zn && (!document.documentMode || 9 < document.documentMode) } function tr() { Kn && (Kn.detachEvent("onpropertychange", nr), Gn = Kn = null) } function nr(e) { if ("value" === e.propertyName && Yn(Gn)) { var t = []; Wn(t, Gn, e, xe(e)), Ie(Qn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), Gn = n, (Kn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Yn(Gn) } function sr(e, t) { if ("click" === e) return Yn(t) } function or(e, t) { if ("input" === e || "change" === e) return Yn(t) } var ar = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function lr(e, t) { if (ar(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !ar(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hr() { for (var e = window, t = Q(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (r) { n = !1 } if (!n) break; t = Q((e = t.contentWindow).document) } return t } function fr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function pr(e) { var t = hr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = void 0 === r.end ? s : Math.min(r.end, i), !e.extend && s > r && (i = r, r = s, s = i), i = ur(n, s); var o = ur(n, r); i && o && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), s > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, vr = null, yr = null, br = !1; function wr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; br || null == gr || gr !== Q(r) || ("selectionStart" in (r = gr) && fr(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : r = { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, yr && lr(yr, r) || (yr = r, 0 < (r = Kr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function xr(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Er = { animationend: xr("Animation", "AnimationEnd"), animationiteration: xr("Animation", "AnimationIteration"), animationstart: xr("Animation", "AnimationStart"), transitionend: xr("Transition", "TransitionEnd") }, Sr = {}, Nr = {}; function Cr(e) { if (Sr[e]) return Sr[e]; if (!Er[e]) return e; var t, n = Er[e]; for (t in n) if (n.hasOwnProperty(t) && t in Nr) return Sr[e] = n[t]; return e } u && (Nr = document.createElement("div").style, "AnimationEvent" in window || (delete Er.animationend.animation, delete Er.animationiteration.animation, delete Er.animationstart.animation), "TransitionEvent" in window || delete Er.transitionend.transition); var Tr = Cr("animationend"), Ar = Cr("animationiteration"), kr = Cr("animationstart"), jr = Cr("transitionend"), Pr = new Map, Ir = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Rr(e, t) { Pr.set(e, t), l(t, [e]) } for (var Or = 0; Or < Ir.length; Or++) { var Dr = Ir[Or]; Rr(Dr.toLowerCase(), "on" + (Dr[0].toUpperCase() + Dr.slice(1))) } Rr(Tr, "onAnimationEnd"), Rr(Ar, "onAnimationIteration"), Rr(kr, "onAnimationStart"), Rr("dblclick", "onDoubleClick"), Rr("focusin", "onFocus"), Rr("focusout", "onBlur"), Rr(jr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var _r = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Mr = new Set("cancel close invalid load scroll toggle".split(" ").concat(_r)); function Lr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, o, a, l, c) { if (Ve.apply(this, arguments), Me) { if (!Me) throw Error(s(198)); var u = Le; Me = !1, Le = null, Fe || (Fe = !0, Ue = u) } }(r, t, void 0, e), e.currentTarget = null } function Fr(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var s = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== s && i.isPropagationStopped()) break e; Lr(i, a, c), s = l } else for (o = 0; o < r.length; o++) { if (l = (a = r[o]).instance, c = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e; Lr(i, a, c), s = l } } } if (Fe) throw e = Ue, Fe = !1, Ue = null, e } function Ur(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (qr(t, e, 2, !1), n.add(r)) } function Br(e, t, n) { var r = 0; t && (r |= 4), qr(n, e, r, t) } var Vr = "_reactListening" + Math.random().toString(36).slice(2); function zr(e) { if (!e[Vr]) { e[Vr] = !0, o.forEach((function (t) { "selectionchange" !== t && (Mr.has(t) || Br(t, !1, e), Br(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Vr] || (t[Vr] = !0, Br("selectionchange", !1, t)) } } function qr(e, t, n, r) { switch (Jt(t)) { case 1: var i = Wt; break; case 4: i = Kt; break; default: i = Gt }n = i.bind(null, t, n, e), i = void 0, !Oe || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Hr(e, t, n, r, i) { var s = r; if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var o = r.tag; if (3 === o || 4 === o) { var a = r.stateNode.containerInfo; if (a === i || 8 === a.nodeType && a.parentNode === i) break; if (4 === o) for (o = r.return; null !== o;) { var l = o.tag; if ((3 === l || 4 === l) && ((l = o.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; o = o.return } for (; null !== a;) { if (null === (o = yi(a))) return; if (5 === (l = o.tag) || 6 === l) { r = s = o; continue e } a = a.parentNode } } r = r.return } Ie((function () { var r = s, i = xe(n), o = []; e: { var a = Pr.get(e); if (void 0 !== a) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = An; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = pn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = jn; break; case Tr: case Ar: case kr: l = vn; break; case jr: l = Pn; break; case "scroll": l = hn; break; case "wheel": l = Rn; break; case "copy": case "cut": case "paste": l = bn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = kn }var u = 0 !== (4 & t), d = !u && "scroll" === e, h = u ? null !== a ? a + "Capture" : null : a; u = []; for (var f, p = r; null !== p;) { var m = (f = p).stateNode; if (5 === f.tag && null !== m && (f = m, null !== h && (null != (m = Re(p, h)) && u.push(Wr(p, m, f)))), d) break; p = p.return } 0 < u.length && (a = new l(a, c, null, n, i), o.push({ event: a, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(a = "mouseover" === e || "pointerover" === e) || n === we || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[pi]) && (l || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = ze(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = pn, m = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = kn, m = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? a : wi(l), f = null == c ? a : wi(c), (a = new u(m, p + "leave", l, n, i)).target = d, a.relatedTarget = f, m = null, yi(i) === r && ((u = new u(h, p + "enter", c, n, i)).target = f, u.relatedTarget = d, m = u), d = m, l && c) e: { for (h = c, p = 0, f = u = l; f; f = Gr(f))p++; for (f = 0, m = h; m; m = Gr(m))f++; for (; 0 < p - f;)u = Gr(u), p--; for (; 0 < f - p;)h = Gr(h), f--; for (; p--;) { if (u === h || null !== h && u === h.alternate) break e; u = Gr(u), h = Gr(h) } u = null } else u = null; null !== l && Qr(o, a, l, u, !1), null !== c && null !== d && Qr(o, d, c, u, !0) } if ("select" === (l = (a = r ? wi(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type) var g = Jn; else if (Hn(a)) if (Xn) g = or; else { g = ir; var v = rr } else (l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = sr); switch (g && (g = g(e, r)) ? Wn(o, g, n, i) : (v && v(e, a, r), "focusout" === e && (v = a._wrapperState) && v.controlled && "number" === a.type && ee(a, "number", a.value)), v = r ? wi(r) : window, e) { case "focusin": (Hn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null); break; case "focusout": yr = vr = gr = null; break; case "mousedown": br = !0; break; case "contextmenu": case "mouseup": case "dragend": br = !1, wr(o, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": wr(o, n, i) }var y; if (Dn) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else zn ? Bn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart"); b && (Ln && "ko" !== n.locale && (zn || "onCompositionStart" !== b ? "onCompositionEnd" === b && zn && (y = en()) : (Zt = "value" in (Xt = i) ? Xt.value : Xt.textContent, zn = !0)), 0 < (v = Kr(r, b)).length && (b = new wn(b, e, null, n, i), o.push({ event: b, listeners: v }), y ? b.data = y : null !== (y = Vn(n)) && (b.data = y))), (y = Mn ? function (e, t) { switch (e) { case "compositionend": return Vn(t); case "keypress": return 32 !== t.which ? null : (Un = !0, Fn); case "textInput": return (e = t.data) === Fn && Un ? null : e; default: return null } }(e, n) : function (e, t) { if (zn) return "compositionend" === e || !Dn && Bn(e, t) ? (e = en(), $t = Zt = Xt = null, zn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Ln && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (r = Kr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), o.push({ event: i, listeners: r }), i.data = y)) } Fr(o, t) })) } function Wr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Kr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, s = i.stateNode; 5 === i.tag && null !== s && (i = s, null != (s = Re(e, n)) && r.unshift(Wr(e, s, i)), null != (s = Re(e, t)) && r.push(Wr(e, s, i))), e = e.return } return r } function Gr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Qr(e, t, n, r, i) { for (var s = t._reactName, o = []; null !== n && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (null !== l && l === r) break; 5 === a.tag && null !== c && (a = c, i ? null != (l = Re(n, s)) && o.unshift(Wr(n, l, a)) : i || null != (l = Re(n, s)) && o.push(Wr(n, l, a))), n = n.return } 0 !== o.length && e.push({ event: t, listeners: o }) } var Yr = /\r\n?/g, Jr = /\u0000|\uFFFD/g; function Xr(e) { return ("string" === typeof e ? e : "" + e).replace(Yr, "\n").replace(Jr, "") } function Zr(e, t, n) { if (t = Xr(t), Xr(e) !== t && n) throw Error(s(425)) } function $r() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" === typeof setTimeout ? setTimeout : void 0, ii = "function" === typeof clearTimeout ? clearTimeout : void 0, si = "function" === typeof Promise ? Promise : void 0, oi = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof si ? function (e) { return si.resolve(null).then(e).catch(ai) } : ri; function ai(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void zt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); zt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, fi = "__reactProps$" + di, pi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di, vi = "__reactHandles$" + di; function yi(e) { var t = e[hi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pi] || n[hi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[hi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function bi(e) { return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function wi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(s(33)) } function xi(e) { return e[fi] || null } var Ei = [], Si = -1; function Ni(e) { return { current: e } } function Ci(e) { 0 > Si || (e.current = Ei[Si], Ei[Si] = null, Si--) } function Ti(e, t) { Si++, Ei[Si] = e.current, e.current = t } var Ai = {}, ki = Ni(Ai), ji = Ni(!1), Pi = Ai; function Ii(e, t) { var n = e.type.contextTypes; if (!n) return Ai; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, s = {}; for (i in n) s[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function Ri(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Oi() { Ci(ji), Ci(ki) } function Di(e, t, n) { if (ki.current !== Ai) throw Error(s(168)); Ti(ki, t), Ti(ji, n) } function _i(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(s(108, q(e) || "Unknown", i)); return L({}, n, r) } function Mi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ai, Pi = ki.current, Ti(ki, e), Ti(ji, ji.current), !0 } function Li(e, t, n) { var r = e.stateNode; if (!r) throw Error(s(169)); n ? (e = _i(e, t, Pi), r.__reactInternalMemoizedMergedChildContext = e, Ci(ji), Ci(ki), Ti(ki, e)) : Ci(ji), Ti(ji, n) } var Fi = null, Ui = !1, Bi = !1; function Vi(e) { null === Fi ? Fi = [e] : Fi.push(e) } function zi() { if (!Bi && null !== Fi) { Bi = !0; var e = 0, t = bt; try { var n = Fi; for (bt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Fi = null, Ui = !1 } catch (i) { throw null !== Fi && (Fi = Fi.slice(e + 1)), Ge($e, zi), i } finally { bt = t, Bi = !1 } } return null } var qi = [], Hi = 0, Wi = null, Ki = 0, Gi = [], Qi = 0, Yi = null, Ji = 1, Xi = ""; function Zi(e, t) { qi[Hi++] = Ki, qi[Hi++] = Wi, Wi = e, Ki = t } function $i(e, t, n) { Gi[Qi++] = Ji, Gi[Qi++] = Xi, Gi[Qi++] = Yi, Yi = e; var r = Ji; e = Xi; var i = 32 - ot(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - ot(t) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Ji = 1 << 32 - ot(t) + i | n << i | r, Xi = s + e } else Ji = 1 << s | n << i | r, Xi = e } function es(e) { null !== e.return && (Zi(e, 1), $i(e, 1, 0)) } function ts(e) { for (; e === Wi;)Wi = qi[--Hi], qi[Hi] = null, Ki = qi[--Hi], qi[Hi] = null; for (; e === Yi;)Yi = Gi[--Qi], Gi[Qi] = null, Xi = Gi[--Qi], Gi[Qi] = null, Ji = Gi[--Qi], Gi[Qi] = null } var ns = null, rs = null, is = !1, ss = null; function os(e, t) { var n = Rc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function as(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, ns = e, rs = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, ns = e, rs = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Yi ? { id: Ji, overflow: Xi } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Rc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, ns = e, rs = null, !0); default: return !1 } } function ls(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function cs(e) { if (is) { var t = rs; if (t) { var n = t; if (!as(e, t)) { if (ls(e)) throw Error(s(418)); t = ci(n.nextSibling); var r = ns; t && as(e, t) ? os(r, n) : (e.flags = -4097 & e.flags | 2, is = !1, ns = e) } } else { if (ls(e)) throw Error(s(418)); e.flags = -4097 & e.flags | 2, is = !1, ns = e } } } function us(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; ns = e } function ds(e) { if (e !== ns) return !1; if (!is) return us(e), is = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = rs)) { if (ls(e)) throw hs(), Error(s(418)); for (; t;)os(e, t), t = ci(t.nextSibling) } if (us(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(s(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { rs = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } rs = null } } else rs = ns ? ci(e.stateNode.nextSibling) : null; return !0 } function hs() { for (var e = rs; e;)e = ci(e.nextSibling) } function fs() { rs = ns = null, is = !1 } function ps(e) { null === ss ? ss = [e] : ss.push(e) } var ms = w.ReactCurrentBatchConfig; function gs(e, t) { if (e && e.defaultProps) { for (var n in t = L({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var vs = Ni(null), ys = null, bs = null, ws = null; function xs() { ws = bs = ys = null } function Es(e) { var t = vs.current; Ci(vs), e._currentValue = t } function Ss(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Ns(e, t) { ys = e, ws = bs = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (wa = !0), e.firstContext = null) } function Cs(e) { var t = e._currentValue; if (ws !== e) if (e = { context: e, memoizedValue: t, next: null }, null === bs) { if (null === ys) throw Error(s(308)); bs = e, ys.dependencies = { lanes: 0, firstContext: e } } else bs = bs.next = e; return t } var Ts = null; function As(e) { null === Ts ? Ts = [e] : Ts.push(e) } function ks(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, As(t)) : (n.next = i.next, i.next = n), t.interleaved = n, js(e, r) } function js(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Ps = !1; function Is(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Rs(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Os(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Ds(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 !== (2 & jl)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, js(e, n) } return null === (i = r.interleaved) ? (t.next = t, As(r)) : (t.next = i.next, i.next = t), r.interleaved = t, js(e, n) } function _s(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } function Ms(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, s = null; if (null !== (n = n.firstBaseUpdate)) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === s ? i = s = o : s = s.next = o, n = n.next } while (null !== n); null === s ? i = s = t : s = s.next = t } else i = s = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ls(e, t, n, r) { var i = e.updateQueue; Ps = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending; if (null !== a) { i.shared.pending = null; var l = a, c = l.next; l.next = null, null === o ? s = c : o.next = c, o = l; var u = e.alternate; null !== u && ((a = (u = u.updateQueue).lastBaseUpdate) !== o && (null === a ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (null !== s) { var d = i.baseState; for (o = 0, u = c = l = null, a = s; ;) { var h = a.lane, f = a.eventTime; if ((r & h) === h) { null !== u && (u = u.next = { eventTime: f, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var p = e, m = a; switch (h = t, f = n, m.tag) { case 1: if ("function" === typeof (p = m.payload)) { d = p.call(f, d, h); break e } d = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null === (h = "function" === typeof (p = m.payload) ? p.call(f, d, h) : p) || void 0 === h) break e; d = L({}, d, h); break e; case 2: Ps = !0 } } null !== a.callback && 0 !== a.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [a] : h.push(a)) } else f = { eventTime: f, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, null === u ? (c = u = f, l = d) : u = u.next = f, o |= h; if (null === (a = a.next)) { if (null === (a = i.shared.pending)) break; a = (h = a).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { o |= i.lane, i = i.next } while (i !== t) } else null === s && (i.shared.lanes = 0); Ll |= o, e.lanes = o, e.memoizedState = d } } function Fs(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" !== typeof i) throw Error(s(191, i)); i.call(r) } } } var Us = (new r.Component).refs; function Bs(e, t, n, r) { n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : L({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var Vs = { isMounted: function (e) { return !!(e = e._reactInternals) && ze(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), s = Os(r, i); s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = Ds(e, s, i)) && (rc(t, e, i, r), _s(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), s = Os(r, i); s.tag = 1, s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = Ds(e, s, i)) && (rc(t, e, i, r), _s(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), r = nc(e), i = Os(n, r); i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Ds(e, i, r)) && (rc(t, e, r, n), _s(t, e, r)) } }; function zs(e, t, n, r, i, s, o) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, o) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, s)) } function qs(e, t, n) { var r = !1, i = Ai, s = t.contextType; return "object" === typeof s && null !== s ? s = Cs(s) : (i = Ri(t) ? Pi : ki.current, s = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ii(e, i) : Ai), t = new t(n, s), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Vs, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t } function Hs(e, t, n, r) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Vs.enqueueReplaceState(t, t.state, null) } function Ws(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Us, Is(e); var s = t.contextType; "object" === typeof s && null !== s ? i.context = Cs(s) : (s = Ri(t) ? Pi : ki.current, i.context = Ii(e, s)), i.state = e.memoizedState, "function" === typeof (s = t.getDerivedStateFromProps) && (Bs(e, t, s, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Vs.enqueueReplaceState(i, i.state, null), Ls(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308) } function Ks(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(s(309)); var r = n.stateNode } if (!r) throw Error(s(147, e)); var i = r, o = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === o ? t.ref : (t = function (e) { var t = i.refs; t === Us && (t = i.refs = {}), null === e ? delete t[o] : t[o] = e }, t._stringRef = o, t) } if ("string" !== typeof e) throw Error(s(284)); if (!n._owner) throw Error(s(290, e)) } return e } function Gs(e, t) { throw e = Object.prototype.toString.call(t), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Qs(e) { return (0, e._init)(e._payload) } function Ys(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Dc(e, t)).index = 0, e.sibling = null, e } function o(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function a(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = Fc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var s = n.type; return s === S ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === s || "object" === typeof s && null !== s && s.$$typeof === R && Qs(s) === t.type) ? ((r = i(t, n.props)).ref = Ks(e, t, n), r.return = e, r) : ((r = _c(n.type, n.key, n.props, null, e.mode, r)).ref = Ks(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Uc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, s) { return null === t || 7 !== t.tag ? ((t = Mc(n, e.mode, r, s)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Fc("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case x: return (n = _c(t.type, t.key, t.props, null, e.mode, n)).ref = Ks(e, null, t), n.return = e, n; case E: return (t = Uc(t, e.mode, n)).return = e, t; case R: return h(e, (0, t._init)(t._payload), n) }if (te(t) || _(t)) return (t = Mc(t, e.mode, n, null)).return = e, t; Gs(e, t) } return null } function f(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case x: return n.key === i ? c(e, t, n, r) : null; case E: return n.key === i ? u(e, t, n, r) : null; case R: return f(e, t, (i = n._init)(n._payload), r) }if (te(n) || _(n)) return null !== i ? null : d(e, t, n, r, null); Gs(e, n) } return null } function p(e, t, n, r, i) { if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" === typeof r && null !== r) { switch (r.$$typeof) { case x: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case E: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case R: return p(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || _(r)) return d(t, e = e.get(n) || null, r, i, null); Gs(t, r) } return null } function m(i, s, a, l) { for (var c = null, u = null, d = s, m = s = 0, g = null; null !== d && m < a.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var v = f(i, d, a[m], l); if (null === v) { null === d && (d = g); break } e && d && null === v.alternate && t(i, d), s = o(v, s, m), null === u ? c = v : u.sibling = v, u = v, d = g } if (m === a.length) return n(i, d), is && Zi(i, m), c; if (null === d) { for (; m < a.length; m++)null !== (d = h(i, a[m], l)) && (s = o(d, s, m), null === u ? c = d : u.sibling = d, u = d); return is && Zi(i, m), c } for (d = r(i, d); m < a.length; m++)null !== (g = p(d, i, m, a[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), s = o(g, s, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(i, e) })), is && Zi(i, m), c } function g(i, a, l, c) { var u = _(l); if ("function" !== typeof u) throw Error(s(150)); if (null == (l = u.call(l))) throw Error(s(151)); for (var d = u = null, m = a, g = a = 0, v = null, y = l.next(); null !== m && !y.done; g++, y = l.next()) { m.index > g ? (v = m, m = null) : v = m.sibling; var b = f(i, m, y.value, c); if (null === b) { null === m && (m = v); break } e && m && null === b.alternate && t(i, m), a = o(b, a, g), null === d ? u = b : d.sibling = b, d = b, m = v } if (y.done) return n(i, m), is && Zi(i, g), u; if (null === m) { for (; !y.done; g++, y = l.next())null !== (y = h(i, y.value, c)) && (a = o(y, a, g), null === d ? u = y : d.sibling = y, d = y); return is && Zi(i, g), u } for (m = r(i, m); !y.done; g++, y = l.next())null !== (y = p(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), a = o(y, a, g), null === d ? u = y : d.sibling = y, d = y); return e && m.forEach((function (e) { return t(i, e) })), is && Zi(i, g), u } return function e(r, s, o, l) { if ("object" === typeof o && null !== o && o.type === S && null === o.key && (o = o.props.children), "object" === typeof o && null !== o) { switch (o.$$typeof) { case x: e: { for (var c = o.key, u = s; null !== u;) { if (u.key === c) { if ((c = o.type) === S) { if (7 === u.tag) { n(r, u.sibling), (s = i(u, o.props.children)).return = r, r = s; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === R && Qs(c) === u.type) { n(r, u.sibling), (s = i(u, o.props)).ref = Ks(r, u, o), s.return = r, r = s; break e } n(r, u); break } t(r, u), u = u.sibling } o.type === S ? ((s = Mc(o.props.children, r.mode, l, o.key)).return = r, r = s) : ((l = _c(o.type, o.key, o.props, null, r.mode, l)).ref = Ks(r, s, o), l.return = r, r = l) } return a(r); case E: e: { for (u = o.key; null !== s;) { if (s.key === u) { if (4 === s.tag && s.stateNode.containerInfo === o.containerInfo && s.stateNode.implementation === o.implementation) { n(r, s.sibling), (s = i(s, o.children || [])).return = r, r = s; break e } n(r, s); break } t(r, s), s = s.sibling } (s = Uc(o, r.mode, l)).return = r, r = s } return a(r); case R: return e(r, s, (u = o._init)(o._payload), l) }if (te(o)) return m(r, s, o, l); if (_(o)) return g(r, s, o, l); Gs(r, o) } return "string" === typeof o && "" !== o || "number" === typeof o ? (o = "" + o, null !== s && 6 === s.tag ? (n(r, s.sibling), (s = i(s, o)).return = r, r = s) : (n(r, s), (s = Fc(o, r.mode, l)).return = r, r = s), a(r)) : n(r, s) } } var Js = Ys(!0), Xs = Ys(!1), Zs = {}, $s = Ni(Zs), eo = Ni(Zs), to = Ni(Zs); function no(e) { if (e === Zs) throw Error(s(174)); return e } function ro(e, t) { switch (Ti(to, t), Ti(eo, e), Ti($s, Zs), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }Ci($s), Ti($s, t) } function io() { Ci($s), Ci(eo), Ci(to) } function so(e) { no(to.current); var t = no($s.current), n = le(t, e.type); t !== n && (Ti(eo, e), Ti($s, n)) } function oo(e) { eo.current === e && (Ci($s), Ci(eo)) } var ao = Ni(0); function lo(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var co = []; function uo() { for (var e = 0; e < co.length; e++)co[e]._workInProgressVersionPrimary = null; co.length = 0 } var ho = w.ReactCurrentDispatcher, fo = w.ReactCurrentBatchConfig, po = 0, mo = null, go = null, vo = null, yo = !1, bo = !1, wo = 0, xo = 0; function Eo() { throw Error(s(321)) } function So(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!ar(e[n], t[n])) return !1; return !0 } function No(e, t, n, r, i, o) { if (po = o, mo = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ho.current = null === e || null === e.memoizedState ? aa : la, e = n(r, i), bo) { o = 0; do { if (bo = !1, wo = 0, 25 <= o) throw Error(s(301)); o += 1, vo = go = null, t.updateQueue = null, ho.current = ca, e = n(r, i) } while (bo) } if (ho.current = oa, t = null !== go && null !== go.next, po = 0, vo = go = mo = null, yo = !1, t) throw Error(s(300)); return e } function Co() { var e = 0 !== wo; return wo = 0, e } function To() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === vo ? mo.memoizedState = vo = e : vo = vo.next = e, vo } function Ao() { if (null === go) { var e = mo.alternate; e = null !== e ? e.memoizedState : null } else e = go.next; var t = null === vo ? mo.memoizedState : vo.next; if (null !== t) vo = t, go = e; else { if (null === e) throw Error(s(310)); e = { memoizedState: (go = e).memoizedState, baseState: go.baseState, baseQueue: go.baseQueue, queue: go.queue, next: null }, null === vo ? mo.memoizedState = vo = e : vo = vo.next = e } return vo } function ko(e, t) { return "function" === typeof t ? t(e) : t } function jo(e) { var t = Ao(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var r = go, i = r.baseQueue, o = n.pending; if (null !== o) { if (null !== i) { var a = i.next; i.next = o.next, o.next = a } r.baseQueue = i = o, n.pending = null } if (null !== i) { o = i.next, r = r.baseState; var l = a = null, c = null, u = o; do { var d = u.lane; if ((po & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, a = r) : c = c.next = h, mo.lanes |= d, Ll |= d } u = u.next } while (null !== u && u !== o); null === c ? a = r : c.next = l, ar(r, t.memoizedState) || (wa = !0), t.memoizedState = r, t.baseState = a, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { o = i.lane, mo.lanes |= o, Ll |= o, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Po(e) { var t = Ao(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (null !== i) { n.pending = null; var a = i = i.next; do { o = e(o, a.action), a = a.next } while (a !== i); ar(o, t.memoizedState) || (wa = !0), t.memoizedState = o, null === t.baseQueue && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Io() { } function Ro(e, t) { var n = mo, r = Ao(), i = t(), o = !ar(r.memoizedState, i); if (o && (r.memoizedState = i, wa = !0), r = r.queue, Ho(_o.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || null !== vo && 1 & vo.memoizedState.tag) { if (n.flags |= 2048, Uo(9, Do.bind(null, n, r, i, t), void 0, null), null === Pl) throw Error(s(349)); 0 !== (30 & po) || Oo(n, t, i) } return i } function Oo(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Do(e, t, n, r) { t.value = n, t.getSnapshot = r, Mo(t) && Lo(e) } function _o(e, t, n) { return n((function () { Mo(t) && Lo(e) })) } function Mo(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !ar(e, n) } catch (r) { return !0 } } function Lo(e) { var t = js(e, 1); null !== t && rc(t, e, 1, -1) } function Fo(e) { var t = To(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ko, lastRenderedState: e }, t.queue = e, e = e.dispatch = na.bind(null, mo, e), [t.memoizedState, e] } function Uo(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Bo() { return Ao().memoizedState } function Vo(e, t, n, r) { var i = To(); mo.flags |= e, i.memoizedState = Uo(1 | t, n, void 0, void 0 === r ? null : r) } function zo(e, t, n, r) { var i = Ao(); r = void 0 === r ? null : r; var s = void 0; if (null !== go) { var o = go.memoizedState; if (s = o.destroy, null !== r && So(r, o.deps)) return void (i.memoizedState = Uo(t, n, s, r)) } mo.flags |= e, i.memoizedState = Uo(1 | t, n, s, r) } function qo(e, t) { return Vo(8390656, 8, e, t) } function Ho(e, t) { return zo(2048, 8, e, t) } function Wo(e, t) { return zo(4, 2, e, t) } function Ko(e, t) { return zo(4, 4, e, t) } function Go(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Qo(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, zo(4, 4, Go.bind(null, t, e), n) } function Yo() { } function Jo(e, t) { var n = Ao(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && So(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Xo(e, t) { var n = Ao(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && So(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Zo(e, t, n) { return 0 === (21 & po) ? (e.baseState && (e.baseState = !1, wa = !0), e.memoizedState = n) : (ar(n, t) || (n = mt(), mo.lanes |= n, Ll |= n, e.baseState = !0), t) } function $o(e, t) { var n = bt; bt = 0 !== n && 4 > n ? n : 4, e(!0); var r = fo.transition; fo.transition = {}; try { e(!1), t() } finally { bt = n, fo.transition = r } } function ea() { return Ao().memoizedState } function ta(e, t, n) { var r = nc(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, ra(e)) ia(t, n); else if (null !== (n = ks(e, t, n, r))) { rc(n, e, r, tc()), sa(n, t, r) } } function na(e, t, n) { var r = nc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (ra(e)) ia(t, i); else { var s = e.alternate; if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try { var o = t.lastRenderedState, a = s(o, n); if (i.hasEagerState = !0, i.eagerState = a, ar(a, o)) { var l = t.interleaved; return null === l ? (i.next = i, As(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (c) { } null !== (n = ks(e, t, i, r)) && (rc(n, e, r, i = tc()), sa(n, t, r)) } } function ra(e) { var t = e.alternate; return e === mo || null !== t && t === mo } function ia(e, t) { bo = yo = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function sa(e, t, n) { if (0 !== (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } var oa = { readContext: Cs, useCallback: Eo, useContext: Eo, useEffect: Eo, useImperativeHandle: Eo, useInsertionEffect: Eo, useLayoutEffect: Eo, useMemo: Eo, useReducer: Eo, useRef: Eo, useState: Eo, useDebugValue: Eo, useDeferredValue: Eo, useTransition: Eo, useMutableSource: Eo, useSyncExternalStore: Eo, useId: Eo, unstable_isNewReconciler: !1 }, aa = { readContext: Cs, useCallback: function (e, t) { return To().memoizedState = [e, void 0 === t ? null : t], e }, useContext: Cs, useEffect: qo, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Vo(4194308, 4, Go.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Vo(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Vo(4, 2, e, t) }, useMemo: function (e, t) { var n = To(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = To(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = ta.bind(null, mo, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, To().memoizedState = e }, useState: Fo, useDebugValue: Yo, useDeferredValue: function (e) { return To().memoizedState = e }, useTransition: function () { var e = Fo(!1), t = e[0]; return e = $o.bind(null, e[1]), To().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = mo, i = To(); if (is) { if (void 0 === n) throw Error(s(407)); n = n() } else { if (n = t(), null === Pl) throw Error(s(349)); 0 !== (30 & po) || Oo(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, qo(_o.bind(null, r, o, e), [e]), r.flags |= 2048, Uo(9, Do.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = To(), t = Pl.identifierPrefix; if (is) { var n = Xi; t = ":" + t + "R" + (n = (Ji & ~(1 << 32 - ot(Ji) - 1)).toString(32) + n), 0 < (n = wo++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = xo++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, la = { readContext: Cs, useCallback: Jo, useContext: Cs, useEffect: Ho, useImperativeHandle: Qo, useInsertionEffect: Wo, useLayoutEffect: Ko, useMemo: Xo, useReducer: jo, useRef: Bo, useState: function () { return jo(ko) }, useDebugValue: Yo, useDeferredValue: function (e) { return Zo(Ao(), go.memoizedState, e) }, useTransition: function () { return [jo(ko)[0], Ao().memoizedState] }, useMutableSource: Io, useSyncExternalStore: Ro, useId: ea, unstable_isNewReconciler: !1 }, ca = { readContext: Cs, useCallback: Jo, useContext: Cs, useEffect: Ho, useImperativeHandle: Qo, useInsertionEffect: Wo, useLayoutEffect: Ko, useMemo: Xo, useReducer: Po, useRef: Bo, useState: function () { return Po(ko) }, useDebugValue: Yo, useDeferredValue: function (e) { var t = Ao(); return null === go ? t.memoizedState = e : Zo(t, go.memoizedState, e) }, useTransition: function () { return [Po(ko)[0], Ao().memoizedState] }, useMutableSource: Io, useSyncExternalStore: Ro, useId: ea, unstable_isNewReconciler: !1 }; function ua(e, t) { try { var n = "", r = t; do { n += V(r), r = r.return } while (r); var i = n } catch (s) { i = "\nError generating stack: " + s.message + "\n" + s.stack } return { value: e, source: t, stack: i, digest: null } } function da(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function ha(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var fa = "function" === typeof WeakMap ? WeakMap : Map; function pa(e, t, n) { (n = Os(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Wl || (Wl = !0, Kl = r), ha(0, t) }, n } function ma(e, t, n) { (n = Os(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" === typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { ha(0, t) } } var s = e.stateNode; return null !== s && "function" === typeof s.componentDidCatch && (n.callback = function () { ha(0, t), "function" !== typeof r && (null === Gl ? Gl = new Set([this]) : Gl.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function ga(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new fa; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Tc.bind(null, e, t, n), t.then(e, e)) } function va(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function ya(e, t, n, r, i) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Os(-1, 1)).tag = 2, Ds(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var ba = w.ReactCurrentOwner, wa = !1; function xa(e, t, n, r) { t.child = null === e ? Xs(t, null, n, r) : Js(t, e.child, n, r) } function Ea(e, t, n, r, i) { n = n.render; var s = t.ref; return Ns(t, i), r = No(e, t, n, r, s, i), n = Co(), null === e || wa ? (is && n && es(t), t.flags |= 1, xa(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Wa(e, t, i)) } function Sa(e, t, n, r, i) { if (null === e) { var s = n.type; return "function" !== typeof s || Oc(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = _c(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, Na(e, t, s, r, i)) } if (s = e.child, 0 === (e.lanes & i)) { var o = s.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(o, r) && e.ref === t.ref) return Wa(e, t, i) } return t.flags |= 1, (e = Dc(s, r)).ref = t.ref, e.return = t, t.child = e } function Na(e, t, n, r, i) { if (null !== e) { var s = e.memoizedProps; if (lr(s, r) && e.ref === t.ref) { if (wa = !1, t.pendingProps = r = s, 0 === (e.lanes & i)) return t.lanes = e.lanes, Wa(e, t, i); 0 !== (131072 & e.flags) && (wa = !0) } } return Aa(e, t, n, r, i) } function Ca(e, t, n) { var r = t.pendingProps, i = r.children, s = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ti(Dl, Ol), Ol |= n; else { if (0 === (1073741824 & n)) return e = null !== s ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ti(Dl, Ol), Ol |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== s ? s.baseLanes : n, Ti(Dl, Ol), Ol |= r } else null !== s ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, Ti(Dl, Ol), Ol |= r; return xa(e, t, i, n), t.child } function Ta(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Aa(e, t, n, r, i) { var s = Ri(n) ? Pi : ki.current; return s = Ii(t, s), Ns(t, i), n = No(e, t, n, r, s, i), r = Co(), null === e || wa ? (is && r && es(t), t.flags |= 1, xa(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Wa(e, t, i)) } function ka(e, t, n, r, i) { if (Ri(n)) { var s = !0; Mi(t) } else s = !1; if (Ns(t, i), null === t.stateNode) Ha(e, t), qs(t, n, r), Ws(t, n, r, i), r = !0; else if (null === e) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, c = n.contextType; "object" === typeof c && null !== c ? c = Cs(c) : c = Ii(t, c = Ri(n) ? Pi : ki.current); var u = n.getDerivedStateFromProps, d = "function" === typeof u || "function" === typeof o.getSnapshotBeforeUpdate; d || "function" !== typeof o.UNSAFE_componentWillReceiveProps && "function" !== typeof o.componentWillReceiveProps || (a !== r || l !== c) && Hs(t, o, r, c), Ps = !1; var h = t.memoizedState; o.state = h, Ls(t, r, o, i), l = t.memoizedState, a !== r || h !== l || ji.current || Ps ? ("function" === typeof u && (Bs(t, n, u, r), l = t.memoizedState), (a = Ps || zs(t, n, a, r, h, l, c)) ? (d || "function" !== typeof o.UNSAFE_componentWillMount && "function" !== typeof o.componentWillMount || ("function" === typeof o.componentWillMount && o.componentWillMount(), "function" === typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount()), "function" === typeof o.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof o.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = a) : ("function" === typeof o.componentDidMount && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, Rs(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : gs(t.type, a), o.props = c, d = t.pendingProps, h = o.context, "object" === typeof (l = n.contextType) && null !== l ? l = Cs(l) : l = Ii(t, l = Ri(n) ? Pi : ki.current); var f = n.getDerivedStateFromProps; (u = "function" === typeof f || "function" === typeof o.getSnapshotBeforeUpdate) || "function" !== typeof o.UNSAFE_componentWillReceiveProps && "function" !== typeof o.componentWillReceiveProps || (a !== d || h !== l) && Hs(t, o, r, l), Ps = !1, h = t.memoizedState, o.state = h, Ls(t, r, o, i); var p = t.memoizedState; a !== d || h !== p || ji.current || Ps ? ("function" === typeof f && (Bs(t, n, f, r), p = t.memoizedState), (c = Ps || zs(t, n, c, r, h, p, l) || !1) ? (u || "function" !== typeof o.UNSAFE_componentWillUpdate && "function" !== typeof o.componentWillUpdate || ("function" === typeof o.componentWillUpdate && o.componentWillUpdate(r, p, l), "function" === typeof o.UNSAFE_componentWillUpdate && o.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof o.componentDidUpdate && (t.flags |= 4), "function" === typeof o.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof o.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof o.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), o.props = r, o.state = p, o.context = l, r = c) : ("function" !== typeof o.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof o.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return ja(e, t, n, r, s, i) } function ja(e, t, n, r, i, s) { Ta(e, t); var o = 0 !== (128 & t.flags); if (!r && !o) return i && Li(t, n, !1), Wa(e, t, s); r = t.stateNode, ba.current = t; var a = o && "function" !== typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && o ? (t.child = Js(t, e.child, null, s), t.child = Js(t, null, a, s)) : xa(e, t, a, s), t.memoizedState = r.state, i && Li(t, n, !0), t.child } function Pa(e) { var t = e.stateNode; t.pendingContext ? Di(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Di(0, t.context, !1), ro(e, t.containerInfo) } function Ia(e, t, n, r, i) { return fs(), ps(i), t.flags |= 256, xa(e, t, n, r), t.child } var Ra, Oa, Da, _a, Ma = { dehydrated: null, treeContext: null, retryLane: 0 }; function La(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Fa(e, t, n) { var r, i = t.pendingProps, o = ao.current, a = !1, l = 0 !== (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)), r ? (a = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (o |= 1), Ti(ao, 1 & o), null === e) return cs(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, a ? (i = t.mode, a = t.child, l = { mode: "hidden", children: l }, 0 === (1 & i) && null !== a ? (a.childLanes = 0, a.pendingProps = l) : a = Lc(l, i, 0, null), e = Mc(e, i, n, null), a.return = t, e.return = t, a.sibling = e, t.child = a, t.child.memoizedState = La(n), t.memoizedState = Ma, e) : Ua(t, l)); if (null !== (o = e.memoizedState) && null !== (r = o.dehydrated)) return function (e, t, n, r, i, o, a) { if (n) return 256 & t.flags ? (t.flags &= -257, Ba(e, t, a, r = da(Error(s(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Lc({ mode: "visible", children: r.children }, i, 0, null), (o = Mc(o, i, a, null)).flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 0 !== (1 & t.mode) && Js(t, e.child, null, a), t.child.memoizedState = La(a), t.memoizedState = Ma, o); if (0 === (1 & t.mode)) return Ba(e, t, a, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, Ba(e, t, a, r = da(o = Error(s(419)), r, void 0)) } if (l = 0 !== (a & e.childLanes), wa || l) { if (null !== (r = Pl)) { switch (a & -a) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 !== (i & (r.suspendedLanes | a)) ? 0 : i) && i !== o.retryLane && (o.retryLane = i, js(e, i), rc(r, e, i, -1)) } return gc(), Ba(e, t, a, r = da(Error(s(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = kc.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, rs = ci(i.nextSibling), ns = t, is = !0, ss = null, null !== e && (Gi[Qi++] = Ji, Gi[Qi++] = Xi, Gi[Qi++] = Yi, Ji = e.id, Xi = e.overflow, Yi = t), t = Ua(t, r.children), t.flags |= 4096, t) }(e, t, l, i, r, o, n); if (a) { a = i.fallback, l = t.mode, r = (o = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 === (1 & l) && t.child !== o ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Dc(o, c)).subtreeFlags = 14680064 & o.subtreeFlags, null !== r ? a = Dc(r, a) : (a = Mc(a, l, n, null)).flags |= 2, a.return = t, i.return = t, i.sibling = a, t.child = i, i = a, a = t.child, l = null === (l = e.child.memoizedState) ? La(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, a.memoizedState = l, a.childLanes = e.childLanes & ~n, t.memoizedState = Ma, i } return e = (a = e.child).sibling, i = Dc(a, { mode: "visible", children: i.children }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Ua(e, t) { return (t = Lc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Ba(e, t, n, r) { return null !== r && ps(r), Js(t, e.child, null, n), (e = Ua(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Va(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), Ss(e.return, t, n) } function za(e, t, n, r, i) { var s = e.memoizedState; null === s ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function qa(e, t, n) { var r = t.pendingProps, i = r.revealOrder, s = r.tail; if (xa(e, t, r.children, n), 0 !== (2 & (r = ao.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Va(e, n, t); else if (19 === e.tag) Va(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ti(ao, r), 0 === (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === lo(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), za(t, !1, i, n, s); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === lo(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } za(t, !0, n, null, s); break; case "together": za(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Ha(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Wa(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), Ll |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(s(153)); if (null !== t.child) { for (n = Dc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Dc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Ka(e, t) { if (!is) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Ga(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Qa(e, t, n) { var r = t.pendingProps; switch (ts(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ga(t), null; case 1: case 17: return Ri(t.type) && Oi(), Ga(t), null; case 3: return r = t.stateNode, io(), Ci(ji), Ci(ki), uo(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ds(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== ss && (ac(ss), ss = null))), Oa(e, t), Ga(t), null; case 5: oo(t); var i = no(to.current); if (n = t.type, null !== e && null != t.stateNode) Da(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(s(166)); return Ga(t), null } if (e = no($s.current), ds(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[hi] = t, r[fi] = o, e = 0 !== (1 & t.mode), n) { case "dialog": Ur("cancel", r), Ur("close", r); break; case "iframe": case "object": case "embed": Ur("load", r); break; case "video": case "audio": for (i = 0; i < _r.length; i++)Ur(_r[i], r); break; case "source": Ur("error", r); break; case "img": case "image": case "link": Ur("error", r), Ur("load", r); break; case "details": Ur("toggle", r); break; case "input": J(r, o), Ur("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Ur("invalid", r); break; case "textarea": ie(r, o), Ur("invalid", r) }for (var l in ye(n, o), i = null, o) if (o.hasOwnProperty(l)) { var c = o[l]; "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== o.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== o.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", "" + c]) : a.hasOwnProperty(l) && null != c && "onScroll" === l && Ur("scroll", r) } switch (n) { case "input": K(r), $(r, o, !0); break; case "textarea": K(r), oe(r); break; case "select": case "option": break; default: "function" === typeof o.onClick && (r.onclick = $r) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = ae(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, Ra(e, t, !1, !1), t.stateNode = e; e: { switch (l = be(n, r), n) { case "dialog": Ur("cancel", e), Ur("close", e), i = r; break; case "iframe": case "object": case "embed": Ur("load", e), i = r; break; case "video": case "audio": for (i = 0; i < _r.length; i++)Ur(_r[i], e); i = r; break; case "source": Ur("error", e), i = r; break; case "img": case "image": case "link": Ur("error", e), Ur("load", e), i = r; break; case "details": Ur("toggle", e), i = r; break; case "input": J(e, r), i = Y(e, r), Ur("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = L({}, r, { value: void 0 }), Ur("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Ur("invalid", e) }for (o in ye(n, i), c = i) if (c.hasOwnProperty(o)) { var u = c[o]; "style" === o ? ge(e, u) : "dangerouslySetInnerHTML" === o ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === o ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== o && "suppressHydrationWarning" !== o && "autoFocus" !== o && (a.hasOwnProperty(o) ? null != u && "onScroll" === o && Ur("scroll", e) : null != u && b(e, o, u, l)) } switch (n) { case "input": K(e), $(e, r, !1); break; case "textarea": K(e), oe(e); break; case "option": null != r.value && e.setAttribute("value", "" + H(r.value)); break; case "select": e.multiple = !!r.multiple, null != (o = r.value) ? ne(e, !!r.multiple, o, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" === typeof i.onClick && (e.onclick = $r) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Ga(t), null; case 6: if (e && null != t.stateNode) _a(e, t, e.memoizedProps, r); else { if ("string" !== typeof r && null === t.stateNode) throw Error(s(166)); if (n = no(to.current), no($s.current), ds(t)) { if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (o = r.nodeValue !== n) && null !== (e = ns)) switch (e.tag) { case 3: Zr(r.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Zr(r.nodeValue, n, 0 !== (1 & e.mode)) }o && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r } return Ga(t), null; case 13: if (Ci(ao), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (is && null !== rs && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) hs(), fs(), t.flags |= 98560, o = !1; else if (o = ds(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!o) throw Error(s(318)); if (!(o = null !== (o = t.memoizedState) ? o.dehydrated : null)) throw Error(s(317)); o[hi] = t } else fs(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Ga(t), o = !1 } else null !== ss && (ac(ss), ss = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & ao.current) ? 0 === _l && (_l = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Ga(t), null); case 4: return io(), Oa(e, t), null === e && zr(t.stateNode.containerInfo), Ga(t), null; case 10: return Es(t.type._context), Ga(t), null; case 19: if (Ci(ao), null === (o = t.memoizedState)) return Ga(t), null; if (r = 0 !== (128 & t.flags), null === (l = o.rendering)) if (r) Ka(o, !1); else { if (0 !== _l || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = lo(e))) { for (t.flags |= 128, Ka(o, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (o = n).flags &= 14680066, null === (l = o.alternate) ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = l.childLanes, o.lanes = l.lanes, o.child = l.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = l.memoizedProps, o.memoizedState = l.memoizedState, o.updateQueue = l.updateQueue, o.type = l.type, e = l.dependencies, o.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ti(ao, 1 & ao.current | 2), t.child } e = e.sibling } null !== o.tail && Xe() > ql && (t.flags |= 128, r = !0, Ka(o, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = lo(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Ka(o, !0), null === o.tail && "hidden" === o.tailMode && !l.alternate && !is) return Ga(t), null } else 2 * Xe() - o.renderingStartTime > ql && 1073741824 !== n && (t.flags |= 128, r = !0, Ka(o, !1), t.lanes = 4194304); o.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = o.last) ? n.sibling = l : t.child = l, o.last = l) } return null !== o.tail ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Xe(), t.sibling = null, n = ao.current, Ti(ao, r ? 1 & n | 2 : 1 & n), t) : (Ga(t), null); case 22: case 23: return hc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Ol) && (Ga(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Ga(t), null; case 24: case 25: return null }throw Error(s(156, t.tag)) } function Ya(e, t) { switch (ts(t), t.tag) { case 1: return Ri(t.type) && Oi(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return io(), Ci(ji), Ci(ki), uo(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return oo(t), null; case 13: if (Ci(ao), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(s(340)); fs() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Ci(ao), null; case 4: return io(), null; case 10: return Es(t.type._context), null; case 22: case 23: return hc(), null; default: return null } } Ra = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Oa = function () { }, Da = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, no($s.current); var s, o = null; switch (n) { case "input": i = Y(e, i), r = Y(e, r), o = []; break; case "select": i = L({}, i, { value: void 0 }), r = L({}, r, { value: void 0 }), o = []; break; case "textarea": i = re(e, i), r = re(e, r), o = []; break; default: "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r) }for (u in ye(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (a.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (s in l) !l.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in c) c.hasOwnProperty(s) && l[s] !== c[s] && (n || (n = {}), n[s] = c[s]) } else n || (o || (o = []), o.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (o = o || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (o = o || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (a.hasOwnProperty(u) ? (null != c && "onScroll" === u && Ur("scroll", e), o || l === c || (o = [])) : (o = o || []).push(u, c)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }, _a = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Ja = !1, Xa = !1, Za = "function" === typeof WeakSet ? WeakSet : Set, $a = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (r) { Cc(e, t, r) } else n.current = null } function tl(e, t, n) { try { n() } catch (r) { Cc(e, t, r) } } var nl = !1; function rl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var s = i.destroy; i.destroy = void 0, void 0 !== s && tl(t, n, s) } i = i.next } while (i !== r) } } function il(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function sl(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function ol(e) { var t = e.alternate; null !== t && (e.alternate = null, ol(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[mi], delete t[gi], delete t[vi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function al(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || al(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var dl = null, hl = !1; function fl(e, t, n) { for (n = n.child; null !== n;)pl(e, t, n), n = n.sibling } function pl(e, t, n) { if (st && "function" === typeof st.onCommitFiberUnmount) try { st.onCommitFiberUnmount(it, n) } catch (a) { } switch (n.tag) { case 5: Xa || el(n, t); case 6: var r = dl, i = hl; dl = null, fl(e, t, n), hl = i, null !== (dl = r) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode)); break; case 18: null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), zt(e)) : li(dl, n.stateNode)); break; case 4: r = dl, i = hl, dl = n.stateNode.containerInfo, hl = !0, fl(e, t, n), dl = r, hl = i; break; case 0: case 11: case 14: case 15: if (!Xa && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, void 0 !== o && (0 !== (2 & s) || 0 !== (4 & s)) && tl(n, t, o), i = i.next } while (i !== r) } fl(e, t, n); break; case 1: if (!Xa && (el(n, t), "function" === typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Cc(n, t, a) } fl(e, t, n); break; case 21: fl(e, t, n); break; case 22: 1 & n.mode ? (Xa = (r = Xa) || null !== n.memoizedState, fl(e, t, n), Xa = r) : fl(e, t, n); break; default: fl(e, t, n) } } function ml(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Za), t.forEach((function (t) { var r = jc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function gl(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, a = t, l = a; e: for (; null !== l;) { switch (l.tag) { case 5: dl = l.stateNode, hl = !1; break e; case 3: case 4: dl = l.stateNode.containerInfo, hl = !0; break e }l = l.return } if (null === dl) throw Error(s(160)); pl(o, a, i), dl = null, hl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (u) { Cc(i, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)vl(t, e), t = t.sibling } function vl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (gl(t, e), yl(e), 4 & r) { try { rl(3, e, e.return), il(3, e) } catch (g) { Cc(e, e.return, g) } try { rl(5, e, e.return) } catch (g) { Cc(e, e.return, g) } } break; case 1: gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return); break; case 5: if (gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) { var i = e.stateNode; try { he(i, "") } catch (g) { Cc(e, e.return, g) } } if (4 & r && null != (i = e.stateNode)) { var o = e.memoizedProps, a = null !== n ? n.memoizedProps : o, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === o.type && null != o.name && X(i, o), be(l, a); var u = be(l, o); for (a = 0; a < c.length; a += 2) { var d = c[a], h = c[a + 1]; "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u) } switch (l) { case "input": Z(i, o); break; case "textarea": se(i, o); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; null != p ? ne(i, !!o.multiple, p, !1) : f !== !!o.multiple && (null != o.defaultValue ? ne(i, !!o.multiple, o.defaultValue, !0) : ne(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[fi] = o } catch (g) { Cc(e, e.return, g) } } break; case 6: if (gl(t, e), yl(e), 4 & r) { if (null === e.stateNode) throw Error(s(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (g) { Cc(e, e.return, g) } } break; case 3: if (gl(t, e), yl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { zt(t.containerInfo) } catch (g) { Cc(e, e.return, g) } break; case 4: default: gl(t, e), yl(e); break; case 13: gl(t, e), yl(e), 8192 & (i = e.child).flags && (o = null !== i.memoizedState, i.stateNode.isHidden = o, !o || null !== i.alternate && null !== i.alternate.memoizedState || (zl = Xe())), 4 & r && ml(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Xa = (u = Xa) || d, gl(t, e), Xa = u) : gl(t, e), yl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode)) for ($a = e, d = e.child; null !== d;) { for (h = $a = d; null !== $a;) { switch (p = (f = $a).child, f.tag) { case 0: case 11: case 14: case 15: rl(4, f, f.return); break; case 1: el(f, f.return); var m = f.stateNode; if ("function" === typeof m.componentWillUnmount) { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (g) { Cc(r, n, g) } } break; case 5: el(f, f.return); break; case 22: if (null !== f.memoizedState) { El(h); continue } }null !== p ? (p.return = f, $a = p) : El(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { i = h.stateNode, u ? "function" === typeof (o = i.style).setProperty ? o.setProperty("display", "none", "important") : o.display = "none" : (l = h.stateNode, a = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", a)) } catch (g) { Cc(e, e.return, g) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (g) { Cc(e, e.return, g) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: gl(t, e), yl(e), 4 & r && ml(e); case 21: } } function yl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (al(n)) { var r = n; break e } n = n.return } throw Error(s(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, ll(e), i); break; case 3: case 4: var o = r.stateNode.containerInfo; cl(e, ll(e), o); break; default: throw Error(s(161)) } } catch (a) { Cc(e, e.return, a) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function bl(e, t, n) { $a = e, wl(e, t, n) } function wl(e, t, n) { for (var r = 0 !== (1 & e.mode); null !== $a;) { var i = $a, s = i.child; if (22 === i.tag && r) { var o = null !== i.memoizedState || Ja; if (!o) { var a = i.alternate, l = null !== a && null !== a.memoizedState || Xa; a = Ja; var c = Xa; if (Ja = o, (Xa = l) && !c) for ($a = i; null !== $a;)l = (o = $a).child, 22 === o.tag && null !== o.memoizedState ? Sl(i) : null !== l ? (l.return = o, $a = l) : Sl(i); for (; null !== s;)$a = s, wl(s, t, n), s = s.sibling; $a = i, Ja = a, Xa = c } xl(e) } else 0 !== (8772 & i.subtreeFlags) && null !== s ? (s.return = i, $a = s) : xl(e) } } function xl(e) { for (; null !== $a;) { var t = $a; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Xa || il(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !Xa) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : gs(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; null !== o && Fs(t, o, r); break; case 3: var a = t.updateQueue; if (null !== a) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Fs(t, a, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && zt(h) } } } break; default: throw Error(s(163)) }Xa || 512 & t.flags && sl(t) } catch (f) { Cc(t, t.return, f) } } if (t === e) { $a = null; break } if (null !== (n = t.sibling)) { n.return = t.return, $a = n; break } $a = t.return } } function El(e) { for (; null !== $a;) { var t = $a; if (t === e) { $a = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, $a = n; break } $a = t.return } } function Sl(e) { for (; null !== $a;) { var t = $a; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { il(4, t) } catch (l) { Cc(t, n, l) } break; case 1: var r = t.stateNode; if ("function" === typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (l) { Cc(t, i, l) } } var s = t.return; try { sl(t) } catch (l) { Cc(t, s, l) } break; case 5: var o = t.return; try { sl(t) } catch (l) { Cc(t, o, l) } } } catch (l) { Cc(t, t.return, l) } if (t === e) { $a = null; break } var a = t.sibling; if (null !== a) { a.return = t.return, $a = a; break } $a = t.return } } var Nl, Cl = Math.ceil, Tl = w.ReactCurrentDispatcher, Al = w.ReactCurrentOwner, kl = w.ReactCurrentBatchConfig, jl = 0, Pl = null, Il = null, Rl = 0, Ol = 0, Dl = Ni(0), _l = 0, Ml = null, Ll = 0, Fl = 0, Ul = 0, Bl = null, Vl = null, zl = 0, ql = 1 / 0, Hl = null, Wl = !1, Kl = null, Gl = null, Ql = !1, Yl = null, Jl = 0, Xl = 0, Zl = null, $l = -1, ec = 0; function tc() { return 0 !== (6 & jl) ? Xe() : -1 !== $l ? $l : $l = Xe() } function nc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & jl) && 0 !== Rl ? Rl & -Rl : null !== ms.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Jt(e.type) } function rc(e, t, n, r) { if (50 < Xl) throw Xl = 0, Zl = null, Error(s(185)); vt(e, n, r), 0 !== (2 & jl) && e === Pl || (e === Pl && (0 === (2 & jl) && (Fl |= n), 4 === _l && lc(e, Rl)), ic(e, r), 1 === n && 0 === jl && 0 === (1 & t.mode) && (ql = Xe() + 500, Ui && zi())) } function ic(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var o = 31 - ot(s), a = 1 << o, l = i[o]; -1 === l ? 0 !== (a & n) && 0 === (a & r) || (i[o] = ft(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a } }(e, t); var r = ht(e, e === Pl ? Rl : 0); if (0 === r) null !== n && Qe(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Qe(n), 1 === t) 0 === e.tag ? function (e) { Ui = !0, Vi(e) }(cc.bind(null, e)) : Vi(cc.bind(null, e)), oi((function () { 0 === (6 & jl) && zi() })), n = null; else { switch (wt(r)) { case 1: n = $e; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Pc(n, sc.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function sc(e, t) { if ($l = -1, ec = 0, 0 !== (6 & jl)) throw Error(s(327)); var n = e.callbackNode; if (Sc() && e.callbackNode !== n) return null; var r = ht(e, e === Pl ? Rl : 0); if (0 === r) return null; if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = vc(e, r); else { t = r; var i = jl; jl |= 2; var o = mc(); for (Pl === e && Rl === t || (Hl = null, ql = Xe() + 500, fc(e, t)); ;)try { bc(); break } catch (l) { pc(e, l) } xs(), Tl.current = o, jl = i, null !== Il ? t = 0 : (Pl = null, Rl = 0, t = _l) } if (0 !== t) { if (2 === t && (0 !== (i = pt(e)) && (r = i, t = oc(e, i))), 1 === t) throw n = Ml, fc(e, 0), lc(e, r), ic(e, Xe()), n; if (6 === t) lc(e, r); else { if (i = e.current.alternate, 0 === (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!ar(s(), i)) return !1 } catch (a) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = vc(e, r)) && (0 !== (o = pt(e)) && (r = o, t = oc(e, o))), 1 === t)) throw n = Ml, fc(e, 0), lc(e, r), ic(e, Xe()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(s(345)); case 2: case 5: Ec(e, Vl, Hl); break; case 3: if (lc(e, r), (130023424 & r) === r && 10 < (t = zl + 500 - Xe())) { if (0 !== ht(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { tc(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(Ec.bind(null, e, Vl, Hl), t); break } Ec(e, Vl, Hl); break; case 4: if (lc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var a = 31 - ot(r); o = 1 << a, (a = t[a]) > i && (i = a), r &= ~o } if (r = i, 10 < (r = (120 > (r = Xe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Cl(r / 1960)) - r)) { e.timeoutHandle = ri(Ec.bind(null, e, Vl, Hl), r); break } Ec(e, Vl, Hl); break; default: throw Error(s(329)) } } } return ic(e, Xe()), e.callbackNode === n ? sc.bind(null, e) : null } function oc(e, t) { var n = Bl; return e.current.memoizedState.isDehydrated && (fc(e, t).flags |= 256), 2 !== (e = vc(e, t)) && (t = Vl, Vl = n, null !== t && ac(t)), e } function ac(e) { null === Vl ? Vl = e : Vl.push.apply(Vl, e) } function lc(e, t) { for (t &= ~Ul, t &= ~Fl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - ot(t), r = 1 << n; e[n] = -1, t &= ~r } } function cc(e) { if (0 !== (6 & jl)) throw Error(s(327)); Sc(); var t = ht(e, 0); if (0 === (1 & t)) return ic(e, Xe()), null; var n = vc(e, t); if (0 !== e.tag && 2 === n) { var r = pt(e); 0 !== r && (t = r, n = oc(e, r)) } if (1 === n) throw n = Ml, fc(e, 0), lc(e, t), ic(e, Xe()), n; if (6 === n) throw Error(s(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Ec(e, Vl, Hl), ic(e, Xe()), null } function uc(e, t) { var n = jl; jl |= 1; try { return e(t) } finally { 0 === (jl = n) && (ql = Xe() + 500, Ui && zi()) } } function dc(e) { null !== Yl && 0 === Yl.tag && 0 === (6 & jl) && Sc(); var t = jl; jl |= 1; var n = kl.transition, r = bt; try { if (kl.transition = null, bt = 1, e) return e() } finally { bt = r, kl.transition = n, 0 === (6 & (jl = t)) && zi() } } function hc() { Ol = Dl.current, Ci(Dl) } function fc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Il) for (n = Il.return; null !== n;) { var r = n; switch (ts(r), r.tag) { case 1: null !== (r = r.type.childContextTypes) && void 0 !== r && Oi(); break; case 3: io(), Ci(ji), Ci(ki), uo(); break; case 5: oo(r); break; case 4: io(); break; case 13: case 19: Ci(ao); break; case 10: Es(r.type._context); break; case 22: case 23: hc() }n = n.return } if (Pl = e, Il = e = Dc(e.current, null), Rl = Ol = t, _l = 0, Ml = null, Ul = Fl = Ll = 0, Vl = Bl = null, null !== Ts) { for (t = 0; t < Ts.length; t++)if (null !== (r = (n = Ts[t]).interleaved)) { n.interleaved = null; var i = r.next, s = n.pending; if (null !== s) { var o = s.next; s.next = i, r.next = o } n.pending = r } Ts = null } return e } function pc(e, t) { for (; ;) { var n = Il; try { if (xs(), ho.current = oa, yo) { for (var r = mo.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } yo = !1 } if (po = 0, vo = go = mo = null, bo = !1, wo = 0, Al.current = null, null === n || null === n.return) { _l = 1, Ml = t, Il = null; break } e: { var o = e, a = n.return, l = n, c = t; if (t = Rl, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, d = l, h = d.tag; if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) { var f = d.alternate; f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = va(a); if (null !== p) { p.flags &= -257, ya(p, a, l, 0, t), 1 & p.mode && ga(o, u, t), c = u; var m = (t = p).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 === (1 & t)) { ga(o, u, t), gc(); break e } c = Error(s(426)) } else if (is && 1 & l.mode) { var v = va(a); if (null !== v) { 0 === (65536 & v.flags) && (v.flags |= 256), ya(v, a, l, 0, t), ps(ua(c, l)); break e } } o = c = ua(c, l), 4 !== _l && (_l = 2), null === Bl ? Bl = [o] : Bl.push(o), o = a; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t, Ms(o, pa(0, c, t)); break e; case 1: l = c; var y = o.type, b = o.stateNode; if (0 === (128 & o.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Gl || !Gl.has(b)))) { o.flags |= 65536, t &= -t, o.lanes |= t, Ms(o, ma(o, l, t)); break e } }o = o.return } while (null !== o) } xc(n) } catch (w) { t = w, Il === n && null !== n && (Il = n = n.return); continue } break } } function mc() { var e = Tl.current; return Tl.current = oa, null === e ? oa : e } function gc() { 0 !== _l && 3 !== _l && 2 !== _l || (_l = 4), null === Pl || 0 === (268435455 & Ll) && 0 === (268435455 & Fl) || lc(Pl, Rl) } function vc(e, t) { var n = jl; jl |= 2; var r = mc(); for (Pl === e && Rl === t || (Hl = null, fc(e, t)); ;)try { yc(); break } catch (i) { pc(e, i) } if (xs(), jl = n, Tl.current = r, null !== Il) throw Error(s(261)); return Pl = null, Rl = 0, _l } function yc() { for (; null !== Il;)wc(Il) } function bc() { for (; null !== Il && !Ye();)wc(Il) } function wc(e) { var t = Nl(e.alternate, e, Ol); e.memoizedProps = e.pendingProps, null === t ? xc(e) : Il = t, Al.current = null } function xc(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = Qa(n, t, Ol))) return void (Il = n) } else { if (null !== (n = Ya(n, t))) return n.flags &= 32767, void (Il = n); if (null === e) return _l = 6, void (Il = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Il = t); Il = t = e } while (null !== t); 0 === _l && (_l = 5) } function Ec(e, t, n) { var r = bt, i = kl.transition; try { kl.transition = null, bt = 1, function (e, t, n, r) { do { Sc() } while (null !== Yl); if (0 !== (6 & jl)) throw Error(s(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - ot(n), s = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~s } }(e, o), e === Pl && (Il = Pl = null, Rl = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Ql || (Ql = !0, Pc(tt, (function () { return Sc(), null }))), o = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || o) { o = kl.transition, kl.transition = null; var a = bt; bt = 1; var l = jl; jl |= 4, Al.current = null, function (e, t) { if (ei = Ht, fr(e = hr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch (x) { n = null; break e } var a = 0, l = -1, c = -1, u = 0, d = 0, h = e, f = null; t: for (; ;) { for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = a + i), h !== o || 0 !== r && 3 !== h.nodeType || (c = a + r), 3 === h.nodeType && (a += h.nodeValue.length), null !== (p = h.firstChild);)f = h, h = p; for (; ;) { if (h === e) break t; if (f === n && ++u === i && (l = a), f === o && ++d === r && (c = a), null !== (p = h.nextSibling)) break; f = (h = f).parentNode } h = p } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Ht = !1, $a = t; null !== $a;)if (e = (t = $a).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, $a = e; else for (; null !== $a;) { t = $a; try { var m = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, v = m.memoizedState, y = t.stateNode, b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : gs(t.type, g), v); y.__reactInternalSnapshotBeforeUpdate = b } break; case 3: var w = t.stateNode.containerInfo; 1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement); break; default: throw Error(s(163)) } } catch (x) { Cc(t, t.return, x) } if (null !== (e = t.sibling)) { e.return = t.return, $a = e; break } $a = t.return } m = nl, nl = !1 }(e, n), vl(n, e), pr(ti), Ht = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Je(), jl = l, bt = a, kl.transition = o } else e.current = n; if (Ql && (Ql = !1, Yl = e, Jl = i), o = e.pendingLanes, 0 === o && (Gl = null), function (e) { if (st && "function" === typeof st.onCommitFiberRoot) try { st.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), ic(e, Xe()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Wl) throw Wl = !1, e = Kl, Kl = null, e; 0 !== (1 & Jl) && 0 !== e.tag && Sc(), o = e.pendingLanes, 0 !== (1 & o) ? e === Zl ? Xl++ : (Xl = 0, Zl = e) : Xl = 0, zi() }(e, t, n, r) } finally { kl.transition = i, bt = r } return null } function Sc() { if (null !== Yl) { var e = wt(Jl), t = kl.transition, n = bt; try { if (kl.transition = null, bt = 16 > e ? 16 : e, null === Yl) var r = !1; else { if (e = Yl, Yl = null, Jl = 0, 0 !== (6 & jl)) throw Error(s(331)); var i = jl; for (jl |= 4, $a = e.current; null !== $a;) { var o = $a, a = o.child; if (0 !== (16 & $a.flags)) { var l = o.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for ($a = u; null !== $a;) { var d = $a; switch (d.tag) { case 0: case 11: case 15: rl(8, d, o) }var h = d.child; if (null !== h) h.return = d, $a = h; else for (; null !== $a;) { var f = (d = $a).sibling, p = d.return; if (ol(d), d === u) { $a = null; break } if (null !== f) { f.return = p, $a = f; break } $a = p } } } var m = o.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } $a = o } } if (0 !== (2064 & o.subtreeFlags) && null !== a) a.return = o, $a = a; else e: for (; null !== $a;) { if (0 !== (2048 & (o = $a).flags)) switch (o.tag) { case 0: case 11: case 15: rl(9, o, o.return) }var y = o.sibling; if (null !== y) { y.return = o.return, $a = y; break e } $a = o.return } } var b = e.current; for ($a = b; null !== $a;) { var w = (a = $a).child; if (0 !== (2064 & a.subtreeFlags) && null !== w) w.return = a, $a = w; else e: for (a = b; null !== $a;) { if (0 !== (2048 & (l = $a).flags)) try { switch (l.tag) { case 0: case 11: case 15: il(9, l) } } catch (E) { Cc(l, l.return, E) } if (l === a) { $a = null; break e } var x = l.sibling; if (null !== x) { x.return = l.return, $a = x; break e } $a = l.return } } if (jl = i, zi(), st && "function" === typeof st.onPostCommitFiberRoot) try { st.onPostCommitFiberRoot(it, e) } catch (E) { } r = !0 } return r } finally { bt = n, kl.transition = t } } return !1 } function Nc(e, t, n) { e = Ds(e, t = pa(0, t = ua(n, t), 1), 1), t = tc(), null !== e && (vt(e, 1, t), ic(e, t)) } function Cc(e, t, n) { if (3 === e.tag) Nc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { Nc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Gl || !Gl.has(r))) { t = Ds(t, e = ma(t, e = ua(n, e), 1), 1), e = tc(), null !== t && (vt(t, 1, e), ic(t, e)); break } } t = t.return } } function Tc(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Pl === e && (Rl & n) === n && (4 === _l || 3 === _l && (130023424 & Rl) === Rl && 500 > Xe() - zl ? fc(e, 0) : Ul |= n), ic(e, t) } function Ac(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = tc(); null !== (e = js(e, t)) && (vt(e, t, n), ic(e, n)) } function kc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Ac(e, n) } function jc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(s(314)) }null !== r && r.delete(t), Ac(e, n) } function Pc(e, t) { return Ge(e, t) } function Ic(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Rc(e, t, n, r) { return new Ic(e, t, n, r) } function Oc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Dc(e, t) { var n = e.alternate; return null === n ? ((n = Rc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function _c(e, t, n, r, i, o) { var a = 2; if (r = e, "function" === typeof e) Oc(e) && (a = 1); else if ("string" === typeof e) a = 5; else e: switch (e) { case S: return Mc(n.children, i, o, t); case N: a = 8, i |= 8; break; case C: return (e = Rc(12, n, t, 2 | i)).elementType = C, e.lanes = o, e; case j: return (e = Rc(13, n, t, i)).elementType = j, e.lanes = o, e; case P: return (e = Rc(19, n, t, i)).elementType = P, e.lanes = o, e; case O: return Lc(n, i, o, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case T: a = 10; break e; case A: a = 9; break e; case k: a = 11; break e; case I: a = 14; break e; case R: a = 16, r = null; break e }throw Error(s(130, null == e ? e : typeof e, "")) }return (t = Rc(a, n, t, i)).elementType = e, t.type = r, t.lanes = o, t } function Mc(e, t, n, r) { return (e = Rc(7, e, r, t)).lanes = n, e } function Lc(e, t, n, r) { return (e = Rc(22, e, r, t)).elementType = O, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Fc(e, t, n) { return (e = Rc(6, e, null, t)).lanes = n, e } function Uc(e, t, n) { return (t = Rc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Bc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Vc(e, t, n, r, i, s, o, a, l) { return e = new Bc(e, t, n, a, l), 1 === t ? (t = 1, !0 === s && (t |= 8)) : t = 0, s = Rc(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Is(s), e } function zc(e) { if (!e) return Ai; e: { if (ze(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(s(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ri(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(s(171)) } if (1 === e.tag) { var n = e.type; if (Ri(n)) return _i(e, n, t) } return t } function qc(e, t, n, r, i, s, o, a, l) { return (e = Vc(n, r, !0, e, 0, s, 0, a, l)).context = zc(null), n = e.current, (s = Os(r = tc(), i = nc(n))).callback = void 0 !== t && null !== t ? t : null, Ds(n, s, i), e.current.lanes = i, vt(e, i, r), ic(e, r), e } function Hc(e, t, n, r) { var i = t.current, s = tc(), o = nc(i); return n = zc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Os(s, o)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Ds(i, t, o)) && (rc(e, i, o, s), _s(e, i, o)), o } function Wc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Kc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Gc(e, t) { Kc(e, t), (e = e.alternate) && Kc(e, t) } Nl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || ji.current) wa = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return wa = !1, function (e, t, n) { switch (t.tag) { case 3: Pa(t), fs(); break; case 5: so(t); break; case 1: Ri(t.type) && Mi(t); break; case 4: ro(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ti(vs, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ti(ao, 1 & ao.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Fa(e, t, n) : (Ti(ao, 1 & ao.current), null !== (e = Wa(e, t, n)) ? e.sibling : null); Ti(ao, 1 & ao.current); break; case 19: if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (r) return qa(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ti(ao, ao.current), r) break; return null; case 22: case 23: return t.lanes = 0, Ca(e, t, n) }return Wa(e, t, n) }(e, t, n); wa = 0 !== (131072 & e.flags) } else wa = !1, is && 0 !== (1048576 & t.flags) && $i(t, Ki, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Ha(e, t), e = t.pendingProps; var i = Ii(t, ki.current); Ns(t, n), i = No(null, t, r, e, i, n); var o = Co(); return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ri(r) ? (o = !0, Mi(t)) : o = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Is(t), i.updater = Vs, t.stateNode = i, i._reactInternals = t, Ws(t, r, e, n), t = ja(null, t, r, !0, o, n)) : (t.tag = 0, is && o && es(t), xa(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Ha(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" === typeof e) return Oc(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === k) return 11; if (e === I) return 14 } return 2 }(r), e = gs(r, e), i) { case 0: t = Aa(null, t, r, e, n); break e; case 1: t = ka(null, t, r, e, n); break e; case 11: t = Ea(null, t, r, e, n); break e; case 14: t = Sa(null, t, r, gs(r.type, e), n); break e }throw Error(s(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Aa(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 1: return r = t.type, i = t.pendingProps, ka(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 3: e: { if (Pa(t), null === e) throw Error(s(387)); r = t.pendingProps, i = (o = t.memoizedState).element, Rs(e, t), Ls(t, r, null, n); var a = t.memoizedState; if (r = a.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: a.cache, pendingSuspenseBoundaries: a.pendingSuspenseBoundaries, transitions: a.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { t = Ia(e, t, r, n, i = ua(Error(s(423)), t)); break e } if (r !== i) { t = Ia(e, t, r, n, i = ua(Error(s(424)), t)); break e } for (rs = ci(t.stateNode.containerInfo.firstChild), ns = t, is = !0, ss = null, n = Xs(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (fs(), r === i) { t = Wa(e, t, n); break e } xa(e, t, r, n) } t = t.child } return t; case 5: return so(t), null === e && cs(t), r = t.type, i = t.pendingProps, o = null !== e ? e.memoizedProps : null, a = i.children, ni(r, i) ? a = null : null !== o && ni(r, o) && (t.flags |= 32), Ta(e, t), xa(e, t, a, n), t.child; case 6: return null === e && cs(t), null; case 13: return Fa(e, t, n); case 4: return ro(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Js(t, null, r, n) : xa(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, Ea(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 7: return xa(e, t, t.pendingProps, n), t.child; case 8: case 12: return xa(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, a = i.value, Ti(vs, r._currentValue), r._currentValue = a, null !== o) if (ar(o.value, a)) { if (o.children === i.children && !ji.current) { t = Wa(e, t, n); break e } } else for (null !== (o = t.child) && (o.return = t); null !== o;) { var l = o.dependencies; if (null !== l) { a = o.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === o.tag) { (c = Os(-1, n & -n)).tag = 2; var u = o.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } o.lanes |= n, null !== (c = o.alternate) && (c.lanes |= n), Ss(o.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === o.tag) a = o.type === t.type ? null : o.child; else if (18 === o.tag) { if (null === (a = o.return)) throw Error(s(341)); a.lanes |= n, null !== (l = a.alternate) && (l.lanes |= n), Ss(a, n, t), a = o.sibling } else a = o.child; if (null !== a) a.return = o; else for (a = o; null !== a;) { if (a === t) { a = null; break } if (null !== (o = a.sibling)) { o.return = a.return, a = o; break } a = a.return } o = a } xa(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Ns(t, n), r = r(i = Cs(i)), t.flags |= 1, xa(e, t, r, n), t.child; case 14: return i = gs(r = t.type, t.pendingProps), Sa(e, t, r, i = gs(r.type, i), n); case 15: return Na(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : gs(r, i), Ha(e, t), t.tag = 1, Ri(r) ? (e = !0, Mi(t)) : e = !1, Ns(t, n), qs(t, r, i), Ws(t, r, i, n), ja(null, t, r, !0, e, n); case 19: return qa(e, t, n); case 22: return Ca(e, t, n) }throw Error(s(156, t.tag)) }; var Qc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function Yc(e) { this._internalRoot = e } function Jc(e) { this._internalRoot = e } function Xc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Zc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function $c() { } function eu(e, t, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if ("function" === typeof i) { var a = i; i = function () { var e = Wc(o); a.call(e) } } Hc(t, o, e, i) } else o = function (e, t, n, r, i) { if (i) { if ("function" === typeof r) { var s = r; r = function () { var e = Wc(o); s.call(e) } } var o = qc(t, r, e, 0, null, !1, 0, "", $c); return e._reactRootContainer = o, e[pi] = o.current, zr(8 === e.nodeType ? e.parentNode : e), dc(), o } for (; i = e.lastChild;)e.removeChild(i); if ("function" === typeof r) { var a = r; r = function () { var e = Wc(l); a.call(e) } } var l = Vc(e, 0, !1, null, 0, !1, 0, "", $c); return e._reactRootContainer = l, e[pi] = l.current, zr(8 === e.nodeType ? e.parentNode : e), dc((function () { Hc(t, l, n, r) })), l }(n, t, e, i, r); return Wc(o) } Jc.prototype.render = Yc.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(s(409)); Hc(e, t, null, null) }, Jc.prototype.unmount = Yc.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; dc((function () { Hc(null, e, null, null) })), t[pi] = null } }, Jc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Nt(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Ot.length && 0 !== t && t < Ot[n].priority; n++); Ot.splice(n, 0, e), 0 === n && Lt(e) } }, xt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (yt(t, 1 | n), ic(t, Xe()), 0 === (6 & jl) && (ql = Xe() + 500, zi())) } break; case 13: dc((function () { var t = js(e, 1); if (null !== t) { var n = tc(); rc(t, e, 1, n) } })), Gc(e, 1) } }, Et = function (e) { if (13 === e.tag) { var t = js(e, 134217728); if (null !== t) rc(t, e, 134217728, tc()); Gc(e, 134217728) } }, St = function (e) { if (13 === e.tag) { var t = nc(e), n = js(e, t); if (null !== n) rc(n, e, t, tc()); Gc(e, t) } }, Nt = function () { return bt }, Ct = function (e, t) { var n = bt; try { return bt = e, t() } finally { bt = n } }, Ee = function (e, t, n) { switch (t) { case "input": if (Z(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = xi(r); if (!i) throw Error(s(90)); G(r), Z(r, i) } } } break; case "textarea": se(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, ke = uc, je = dc; var tu = { usingClientEntryPoint: !1, Events: [bi, wi, xi, Te, Ae, uc] }, nu = { findFiberByHostInstance: yi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ru = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: w.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = We(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!iu.isDisabled && iu.supportsFiber) try { it = iu.inject(ru), st = iu } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Xc(t)) throw Error(s(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: E, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Xc(e)) throw Error(s(299)); var n = !1, r = "", i = Qc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Vc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, zr(8 === e.nodeType ? e.parentNode : e), new Yc(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(s(188)); throw e = Object.keys(e).join(","), Error(s(268, e)) } return e = null === (e = We(t)) ? null : e.stateNode }, t.flushSync = function (e) { return dc(e) }, t.hydrate = function (e, t, n) { if (!Zc(t)) throw Error(s(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Xc(e)) throw Error(s(405)); var r = null != n && n.hydratedSources || null, i = !1, o = "", a = Qc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (o = n.identifierPrefix), void 0 !== n.onRecoverableError && (a = n.onRecoverableError)), t = qc(t, null, e, 1, null != n ? n : null, i, 0, o, a), e[pi] = t.current, zr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Jc(t) }, t.render = function (e, t, n) { if (!Zc(t)) throw Error(s(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Zc(e)) throw Error(s(40)); return !!e._reactRootContainer && (dc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[pi] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Zc(n)) throw Error(s(200)); if (null == e || void 0 === e._reactInternals) throw Error(s(38)); return eu(e, t, n, !1, r) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 391: (e, t, n) => { "use strict"; var r = n(950); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 950: (e, t, n) => { "use strict"; !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(730) }, 153: (e, t, n) => { "use strict"; var r = n(43), i = Symbol.for("react.element"), s = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, s = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) o.call(t, r) && !l.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: s, _owner: a.current } } t.Fragment = s, t.jsx = c, t.jsxs = c }, 202: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.iterator; var p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function v(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } function y() { } function b(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } v.prototype.isReactComponent = {}, v.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, v.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, y.prototype = v.prototype; var w = b.prototype = new y; w.constructor = b, m(w, v.prototype), w.isPureReactComponent = !0; var x = Array.isArray, E = Object.prototype.hasOwnProperty, S = { current: null }, N = { key: !0, ref: !0, __self: !0, __source: !0 }; function C(e, t, r) { var i, s = {}, o = null, a = null; if (null != t) for (i in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (o = "" + t.key), t) E.call(t, i) && !N.hasOwnProperty(i) && (s[i] = t[i]); var l = arguments.length - 2; if (1 === l) s.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; s.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === s[i] && (s[i] = l[i]); return { $$typeof: n, type: e, key: o, ref: a, props: s, _owner: S.current } } function T(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var A = /\/+/g; function k(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function j(e, t, i, s, o) { var a = typeof e; "undefined" !== a && "boolean" !== a || (e = null); var l = !1; if (null === e) l = !0; else switch (a) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return o = o(l = e), e = "" === s ? "." + k(l, 0) : s, x(o) ? (i = "", null != e && (i = e.replace(A, "$&/") + "/"), j(o, t, i, "", (function (e) { return e }))) : null != o && (T(o) && (o = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(o, i + (!o.key || l && l.key === o.key ? "" : ("" + o.key).replace(A, "$&/") + "/") + e)), t.push(o)), 1; if (l = 0, s = "" === s ? "." : s + ":", x(e)) for (var c = 0; c < e.length; c++) { var u = s + k(a = e[c], c); l += j(a, t, i, u, o) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = f && e[f] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(a = e.next()).done;)l += j(a = a.value, t, i, u = s + k(a, c++), o); else if ("object" === a) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function P(e, t, n) { if (null == e) return e; var r = [], i = 0; return j(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function I(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var R = { current: null }, O = { transition: null }, D = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: O, ReactCurrentOwner: S }; t.Children = { map: P, forEach: function (e, t, n) { P(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return P(e, (function () { t++ })), t }, toArray: function (e) { return P(e, (function (e) { return e })) || [] }, only: function (e) { if (!T(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = v, t.Fragment = i, t.Profiler = o, t.PureComponent = b, t.StrictMode = s, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D, t.cloneElement = function (e, t, r) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), s = e.key, o = e.ref, a = e._owner; if (null != t) { if (void 0 !== t.ref && (o = t.ref, a = S.current), void 0 !== t.key && (s = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) E.call(t, c) && !N.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: s, ref: o, props: i, _owner: a } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: a, _context: e }, e.Consumer = e }, t.createElement = C, t.createFactory = function (e) { var t = C.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = T, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: I } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = O.transition; O.transition = {}; try { e() } finally { O.transition = t } }, t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, t.useCallback = function (e, t) { return R.current.useCallback(e, t) }, t.useContext = function (e) { return R.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return R.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return R.current.useEffect(e, t) }, t.useId = function () { return R.current.useId() }, t.useImperativeHandle = function (e, t, n) { return R.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return R.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return R.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return R.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return R.current.useReducer(e, t, n) }, t.useRef = function (e) { return R.current.useRef(e) }, t.useState = function (e) { return R.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return R.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return R.current.useTransition() }, t.version = "18.2.0" }, 43: (e, t, n) => { "use strict"; e.exports = n(202) }, 579: (e, t, n) => { "use strict"; e.exports = n(153) }, 234: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < s(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var a = 2 * (r + 1) - 1, l = e[a], c = a + 1, u = e[c]; if (0 > s(l, n)) c < i && 0 > s(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[a] = n, r = a); else { if (!(c < i && 0 > s(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function s(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var o = performance; t.unstable_now = function () { return o.now() } } else { var a = Date, l = a.now(); t.unstable_now = function () { return a.now() - l } } var c = [], u = [], d = 1, h = null, f = 3, p = !1, m = !1, g = !1, v = "function" === typeof setTimeout ? setTimeout : null, y = "function" === typeof clearTimeout ? clearTimeout : null, b = "undefined" !== typeof setImmediate ? setImmediate : null; function w(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function x(e) { if (g = !1, w(e), !m) if (null !== r(c)) m = !0, O(E); else { var t = r(u); null !== t && D(x, t.startTime - e) } } function E(e, n) { m = !1, g && (g = !1, y(T), T = -1), p = !0; var s = f; try { for (w(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !j());) { var o = h.callback; if ("function" === typeof o) { h.callback = null, f = h.priorityLevel; var a = o(h.expirationTime <= n); n = t.unstable_now(), "function" === typeof a ? h.callback = a : h === r(c) && i(c), w(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && D(x, d.startTime - n), l = !1 } return l } finally { h = null, f = s, p = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var S, N = !1, C = null, T = -1, A = 5, k = -1; function j() { return !(t.unstable_now() - k < A) } function P() { if (null !== C) { var e = t.unstable_now(); k = e; var n = !0; try { n = C(!0, e) } finally { n ? S() : (N = !1, C = null) } } else N = !1 } if ("function" === typeof b) S = function () { b(P) }; else if ("undefined" !== typeof MessageChannel) { var I = new MessageChannel, R = I.port2; I.port1.onmessage = P, S = function () { R.postMessage(null) } } else S = function () { v(P, 0) }; function O(e) { C = e, N || (N = !0, S()) } function D(e, n) { T = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || p || (m = !0, O(E)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : A = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (f) { case 1: case 2: case 3: var t = 3; break; default: t = f }var n = f; f = t; try { return e() } finally { f = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = f; f = e; try { return t() } finally { f = n } }, t.unstable_scheduleCallback = function (e, i, s) { var o = t.unstable_now(); switch ("object" === typeof s && null !== s ? s = "number" === typeof (s = s.delay) && 0 < s ? o + s : o : s = o, e) { case 1: var a = -1; break; case 2: a = 250; break; case 5: a = 1073741823; break; case 4: a = 1e4; break; default: a = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: s, expirationTime: a = s + a, sortIndex: -1 }, s > o ? (e.sortIndex = s, n(u, e), null === r(c) && e === r(u) && (g ? (y(T), T = -1) : g = !0, D(x, s - o))) : (e.sortIndex = a, n(c, e), m || p || (m = !0, O(E))), e }, t.unstable_shouldYield = j, t.unstable_wrapCallback = function (e) { var t = f; return function () { var n = f; f = t; try { return e.apply(this, arguments) } finally { f = n } } } }, 853: (e, t, n) => { "use strict"; e.exports = n(234) }, 440: e => { "use strict"; var t = function () { }; e.exports = t }, 139: (e, t) => { var n; !function () { "use strict"; var r = {}.hasOwnProperty; function i() { for (var e = "", t = 0; t < arguments.length; t++) { var n = arguments[t]; n && (e = o(e, s(n))) } return e } function s(e) { if ("string" === typeof e || "number" === typeof e) return e; if ("object" !== typeof e) return ""; if (Array.isArray(e)) return i.apply(null, e); if (e.toString !== Object.prototype.toString && !e.toString.toString().includes("[native code]")) return e.toString(); var t = ""; for (var n in e) r.call(e, n) && e[n] && (t = o(t, n)); return t } function o(e, t) { return t ? e ? e + " " + t : e + t : e } e.exports ? (i.default = i, e.exports = i) : void 0 === (n = function () { return i }.apply(t, [])) || (e.exports = n) }() } }, t = {}; function n(r) { var i = t[r]; if (void 0 !== i) return i.exports; var s = t[r] = { exports: {} }; return e[r].call(s.exports, s, s.exports, n), s.exports } n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; n.t = function (r, i) { if (1 & i && (r = this(r)), 8 & i) return r; if ("object" === typeof r && r) { if (4 & i && r.__esModule) return r; if (16 & i && "function" === typeof r.then) return r } var s = Object.create(null); n.r(s); var o = {}; e = e || [null, t({}), t([]), t(t)]; for (var a = 2 & i && r; "object" == typeof a && !~e.indexOf(a); a = t(a))Object.getOwnPropertyNames(a).forEach((e => o[e] = () => r[e])); return o.default = () => r, n.d(s, o), s } })(), n.d = (e, t) => { for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, n.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.p = "/", (() => { "use strict"; var e = {}; n.r(e), n.d(e, { hasBrowserEnv: () => Tm, hasStandardBrowserEnv: () => Am, hasStandardBrowserWebWorkerEnv: () => km, origin: () => jm }); var t, r = n(43), i = n.t(r, 2), s = n(391), o = n(950), a = n.t(o, 2); function l() { return l = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, l.apply(this, arguments) } !function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" }(t || (t = {})); const c = "popstate"; function u(e, t) { if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t) } function d(e, t) { if (!e) { "undefined" !== typeof console && console.warn(t); try { throw new Error(t) } catch (n) { } } } function h(e, t) { return { usr: e.state, key: e.key, idx: t } } function f(e, t, n, r) { return void 0 === n && (n = null), l({ pathname: "string" === typeof e ? e : e.pathname, search: "", hash: "" }, "string" === typeof t ? m(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function p(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function m(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function g(e, n, r, i) { void 0 === i && (i = {}); let { window: s = document.defaultView, v5Compat: o = !1 } = i, a = s.history, d = t.Pop, m = null, g = v(); function v() { return (a.state || { idx: null }).idx } function y() { d = t.Pop; let e = v(), n = null == e ? null : e - g; g = e, m && m({ action: d, location: w.location, delta: n }) } function b(e) { let t = "null" !== s.location.origin ? s.location.origin : s.location.href, n = "string" === typeof e ? e : p(e); return n = n.replace(/ $/, "%20"), u(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == g && (g = 0, a.replaceState(l({}, a.state, { idx: g }), "")); let w = { get action() { return d }, get location() { return e(s, a) }, listen(e) { if (m) throw new Error("A history only accepts one active listener"); return s.addEventListener(c, y), m = e, () => { s.removeEventListener(c, y), m = null } }, createHref: e => n(s, e), createURL: b, encodeLocation(e) { let t = b(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, n) { d = t.Push; let i = f(w.location, e, n); r && r(i, e), g = v() + 1; let l = h(i, g), c = w.createHref(i); try { a.pushState(l, "", c) } catch (No) { if (No instanceof DOMException && "DataCloneError" === No.name) throw No; s.location.assign(c) } o && m && m({ action: d, location: w.location, delta: 1 }) }, replace: function (e, n) { d = t.Replace; let i = f(w.location, e, n); r && r(i, e), g = v(); let s = h(i, g), l = w.createHref(i); a.replaceState(s, "", l), o && m && m({ action: d, location: w.location, delta: 0 }) }, go: e => a.go(e) }; return w } var v; !function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" }(v || (v = {})); new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function y(e, t, n) { void 0 === n && (n = "/"); let r = R(("string" === typeof t ? m(t) : t).pathname || "/", n); if (null == r) return null; let i = b(e); !function (e) { e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n])); return n ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex))))) }(i); let s = null; for (let o = 0; null == s && o < i.length; ++o) { let e = I(r); s = j(i[o], e) } return s } function b(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let i = (e, i, s) => { let o = { relativePath: void 0 === s ? e.path || "" : s, caseSensitive: !0 === e.caseSensitive, childrenIndex: i, route: e }; o.relativePath.startsWith("/") && (u(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(r.length)); let a = L([r, o.relativePath]), l = n.concat(o); e.children && e.children.length > 0 && (u(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), b(e.children, t, l, a)), (null != e.path || e.index) && t.push({ path: a, score: k(a, e.index), routesMeta: l }) }; return e.forEach(((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of w(e.path)) i(e, t, r); else i(e, t) })), t } function w(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (0 === r.length) return i ? [s, ""] : [s]; let o = w(r.join("/")), a = []; return a.push(...o.map((e => "" === e ? s : [s, e].join("/")))), i && a.push(...o), a.map((t => e.startsWith("/") && "" === t ? "/" : t)) } const x = /^:[\w-]+$/, E = 3, S = 2, N = 1, C = 10, T = -2, A = e => "*" === e; function k(e, t) { let n = e.split("/"), r = n.length; return n.some(A) && (r += T), t && (r += S), n.filter((e => !A(e))).reduce(((e, t) => e + (x.test(t) ? E : "" === t ? N : C)), r) } function j(e, t) { let { routesMeta: n } = e, r = {}, i = "/", s = []; for (let o = 0; o < n.length; ++o) { let e = n[o], a = o === n.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = P({ path: e.relativePath, caseSensitive: e.caseSensitive, end: a }, l); if (!c) return null; Object.assign(r, c.params); let u = e.route; s.push({ params: r, pathname: L([i, c.pathname]), pathnameBase: F(L([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = L([i, c.pathnameBase])) } return s } function P(e, t) { "string" === typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1); void 0 === n && (n = !0); d("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, ((e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)"))); e.endsWith("*") ? (r.push({ paramName: "*" }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"); let s = new RegExp(i, t ? void 0 : "i"); return [s, r] }(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let s = i[0], o = s.replace(/(.)\/+$/, "$1"), a = i.slice(1), l = r.reduce(((e, t, n) => { let { paramName: r, isOptional: i } = t; if ("*" === r) { let e = a[n] || ""; o = s.slice(0, s.length - e.length).replace(/(.)\/+$/, "$1") } const l = a[n]; return e[r] = i && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e }), {}); return { params: l, pathname: s, pathnameBase: o, pattern: e } } function I(e) { try { return e.split("/").map((e => decodeURIComponent(e).replace(/\//g, "%2F"))).join("/") } catch (No) { return d(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + No + ")."), e } } function R(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } function O(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function D(e) { return e.filter(((e, t) => 0 === t || e.route.path && e.route.path.length > 0)) } function _(e, t) { let n = D(e); return t ? n.map(((t, n) => n === e.length - 1 ? t.pathname : t.pathnameBase)) : n.map((e => e.pathnameBase)) } function M(e, t, n, r) { let i; void 0 === r && (r = !1), "string" === typeof e ? i = m(e) : (i = l({}, e), u(!i.pathname || !i.pathname.includes("?"), O("?", "pathname", "search", i)), u(!i.pathname || !i.pathname.includes("#"), O("#", "pathname", "hash", i)), u(!i.search || !i.search.includes("#"), O("#", "search", "hash", i))); let s, o = "" === e || "" === i.pathname, a = o ? "/" : i.pathname; if (null == a) s = n; else { let e = t.length - 1; if (!r && a.startsWith("..")) { let t = a.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; i.pathname = t.join("/") } s = e >= 0 ? t[e] : "/" } let c = function (e, t) { void 0 === t && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = "string" === typeof e ? m(e) : e, s = n ? n.startsWith("/") ? n : function (e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach((e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) })), n.length > 1 ? n.join("/") : "/" }(n, t) : t; return { pathname: s, search: U(r), hash: B(i) } }(i, s), d = a && "/" !== a && a.endsWith("/"), h = (o || "." === a) && n.endsWith("/"); return c.pathname.endsWith("/") || !d && !h || (c.pathname += "/"), c } const L = e => e.join("/").replace(/\/\/+/g, "/"), F = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), U = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", B = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; function V(e) { return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e } const z = ["post", "put", "patch", "delete"], q = (new Set(z), ["get", ...z]); new Set(q), new Set([301, 302, 303, 307, 308]), new Set([307, 308]); Symbol("deferred"); function H() { return H = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, H.apply(this, arguments) } const W = r.createContext(null); const K = r.createContext(null); const G = r.createContext(null); const Q = r.createContext(null); const Y = r.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const J = r.createContext(null); function X() { return null != r.useContext(Q) } function Z() { return X() || u(!1), r.useContext(Q).location } function $(e) { r.useContext(G).static || r.useLayoutEffect(e) } function ee() { let { isDataRoute: e } = r.useContext(Y); return e ? function () { let { router: e } = ue(le.UseNavigateStable), t = he(ce.UseNavigateStable), n = r.useRef(!1); $((() => { n.current = !0 })); let i = r.useCallback((function (r, i) { void 0 === i && (i = {}), n.current && ("number" === typeof r ? e.navigate(r) : e.navigate(r, H({ fromRouteId: t }, i))) }), [e, t]); return i }() : function () { X() || u(!1); let e = r.useContext(W), { basename: t, future: n, navigator: i } = r.useContext(G), { matches: s } = r.useContext(Y), { pathname: o } = Z(), a = JSON.stringify(_(s, n.v7_relativeSplatPath)), l = r.useRef(!1); $((() => { l.current = !0 })); let c = r.useCallback((function (n, r) { if (void 0 === r && (r = {}), !l.current) return; if ("number" === typeof n) return void i.go(n); let s = M(n, JSON.parse(a), o, "path" === r.relative); null == e && "/" !== t && (s.pathname = "/" === s.pathname ? t : L([t, s.pathname])), (r.replace ? i.replace : i.push)(s, r.state, r) }), [t, i, a, o, e]); return c }() } function te(e, t) { let { relative: n } = void 0 === t ? {} : t, { future: i } = r.useContext(G), { matches: s } = r.useContext(Y), { pathname: o } = Z(), a = JSON.stringify(_(s, i.v7_relativeSplatPath)); return r.useMemo((() => M(e, JSON.parse(a), o, "path" === n)), [e, a, o, n]) } function ne(e, n, i, s) { X() || u(!1); let { navigator: o } = r.useContext(G), { matches: a } = r.useContext(Y), l = a[a.length - 1], c = l ? l.params : {}, d = (l && l.pathname, l ? l.pathnameBase : "/"); l && l.route; let h, f = Z(); if (n) { var p; let e = "string" === typeof n ? m(n) : n; "/" === d || (null == (p = e.pathname) ? void 0 : p.startsWith(d)) || u(!1), h = e } else h = f; let g = h.pathname || "/", v = g; if ("/" !== d) { let e = d.replace(/^\//, "").split("/"); v = "/" + g.replace(/^\//, "").split("/").slice(e.length).join("/") } let b = y(e, { pathname: v }); let w = ae(b && b.map((e => Object.assign({}, e, { params: Object.assign({}, c, e.params), pathname: L([d, o.encodeLocation ? o.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? d : L([d, o.encodeLocation ? o.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) }))), a, i, s); return n && w ? r.createElement(Q.Provider, { value: { location: H({ pathname: "/", search: "", hash: "", state: null, key: "default" }, h), navigationType: t.Pop } }, w) : w } function re() { let e = function () { var e; let t = r.useContext(J), n = de(ce.UseRouteError), i = he(ce.UseRouteError); if (void 0 !== t) return t; return null == (e = n.errors) ? void 0 : e[i] }(), t = V(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, i = "rgba(200,200,200, 0.5)", s = { padding: "0.5rem", backgroundColor: i }; return r.createElement(r.Fragment, null, r.createElement("h2", null, "Unexpected Application Error!"), r.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? r.createElement("pre", { style: s }, n) : null, null) } const ie = r.createElement(re, null); class se extends r.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return void 0 !== this.state.error ? r.createElement(Y.Provider, { value: this.props.routeContext }, r.createElement(J.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function oe(e) { let { routeContext: t, match: n, children: i } = e, s = r.useContext(W); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), r.createElement(Y.Provider, { value: t }, i) } function ae(e, t, n, i) { var s; if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === i && (i = null), null == e) { var o; if (null == (o = n) || !o.errors) return null; e = n.matches } let a = e, l = null == (s = n) ? void 0 : s.errors; if (null != l) { let e = a.findIndex((e => e.route.id && void 0 !== (null == l ? void 0 : l[e.route.id]))); e >= 0 || u(!1), a = a.slice(0, Math.min(a.length, e + 1)) } let c = !1, d = -1; if (n && i && i.v7_partialHydration) for (let r = 0; r < a.length; r++) { let e = a[r]; if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (d = r), e.route.id) { let { loaderData: t, errors: r } = n, i = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]); if (e.route.lazy || i) { c = !0, a = d >= 0 ? a.slice(0, d + 1) : [a[0]]; break } } } return a.reduceRight(((e, i, s) => { let o, u = !1, h = null, f = null; var p; n && (o = l && i.route.id ? l[i.route.id] : void 0, h = i.route.errorElement || ie, c && (d < 0 && 0 === s ? (p = "route-fallback", !1 || fe[p] || (fe[p] = !0), u = !0, f = null) : d === s && (u = !0, f = i.route.hydrateFallbackElement || null))); let m = t.concat(a.slice(0, s + 1)), g = () => { let t; return t = o ? h : u ? f : i.route.Component ? r.createElement(i.route.Component, null) : i.route.element ? i.route.element : e, r.createElement(oe, { match: i, routeContext: { outlet: e, matches: m, isDataRoute: null != n }, children: t }) }; return n && (i.route.ErrorBoundary || i.route.errorElement || 0 === s) ? r.createElement(se, { location: n.location, revalidation: n.revalidation, component: h, error: o, children: g(), routeContext: { outlet: null, matches: m, isDataRoute: !0 } }) : g() }), null) } var le = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(le || {}), ce = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(ce || {}); function ue(e) { let t = r.useContext(W); return t || u(!1), t } function de(e) { let t = r.useContext(K); return t || u(!1), t } function he(e) { let t = function (e) { let t = r.useContext(Y); return t || u(!1), t }(), n = t.matches[t.matches.length - 1]; return n.route.id || u(!1), n.route.id } const fe = {}; i.startTransition; function pe(e) { u(!1) } function me(e) { let { basename: n = "/", children: i = null, location: s, navigationType: o = t.Pop, navigator: a, static: l = !1, future: c } = e; X() && u(!1); let d = n.replace(/^\/*/, "/"), h = r.useMemo((() => ({ basename: d, navigator: a, static: l, future: H({ v7_relativeSplatPath: !1 }, c) })), [d, c, a, l]); "string" === typeof s && (s = m(s)); let { pathname: f = "/", search: p = "", hash: g = "", state: v = null, key: y = "default" } = s, b = r.useMemo((() => { let e = R(f, d); return null == e ? null : { location: { pathname: e, search: p, hash: g, state: v, key: y }, navigationType: o } }), [d, f, p, g, v, y, o]); return null == b ? null : r.createElement(G.Provider, { value: h }, r.createElement(Q.Provider, { children: i, value: b })) } function ge(e) { let { children: t, location: n } = e; return ne(ve(t), n) } new Promise((() => { })); r.Component; function ve(e, t) { void 0 === t && (t = []); let n = []; return r.Children.forEach(e, ((e, i) => { if (!r.isValidElement(e)) return; let s = [...t, i]; if (e.type === r.Fragment) return void n.push.apply(n, ve(e.props.children, s)); e.type !== pe && u(!1), e.props.index && e.props.children && u(!1); let o = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (o.children = ve(e.props.children, s)), n.push(o) })), n } function ye() { return ye = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ye.apply(this, arguments) } function be(e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i } new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); const we = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]; try { window.__reactRouterVersion = "6" } catch (sI) { } new Map; const xe = i.startTransition; a.flushSync, i.useId; function Ee(e) { let { basename: t, children: n, future: i, window: s } = e, o = r.useRef(); null == o.current && (o.current = function (e) { return void 0 === e && (e = {}), g((function (e, t) { let { pathname: n, search: r, hash: i } = e.location; return f("", { pathname: n, search: r, hash: i }, t.state && t.state.usr || null, t.state && t.state.key || "default") }), (function (e, t) { return "string" === typeof t ? t : p(t) }), null, e) }({ window: s, v5Compat: !0 })); let a = o.current, [l, c] = r.useState({ action: a.action, location: a.location }), { v7_startTransition: u } = i || {}, d = r.useCallback((e => { u && xe ? xe((() => c(e))) : c(e) }), [c, u]); return r.useLayoutEffect((() => a.listen(d)), [a, d]), r.createElement(me, { basename: t, children: n, location: l.location, navigationType: l.action, navigator: a, future: i }) } const Se = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, Ne = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ce = r.forwardRef((function (e, t) { let n, { onClick: i, relative: s, reloadDocument: o, replace: a, state: l, target: c, to: d, preventScrollReset: h, unstable_viewTransition: f } = e, m = be(e, we), { basename: g } = r.useContext(G), v = !1; if ("string" === typeof d && Ne.test(d) && (n = d, Se)) try { let e = new URL(window.location.href), t = d.startsWith("//") ? new URL(e.protocol + d) : new URL(d), n = R(t.pathname, g); t.origin === e.origin && null != n ? d = n + t.search + t.hash : v = !0 } catch (sI) { } let y = function (e, t) { let { relative: n } = void 0 === t ? {} : t; X() || u(!1); let { basename: i, navigator: s } = r.useContext(G), { hash: o, pathname: a, search: l } = te(e, { relative: n }), c = a; return "/" !== i && (c = "/" === a ? i : L([i, a])), s.createHref({ pathname: c, search: l, hash: o }) }(d, { relative: s }), b = function (e, t) { let { target: n, replace: i, state: s, preventScrollReset: o, relative: a, unstable_viewTransition: l } = void 0 === t ? {} : t, c = ee(), u = Z(), d = te(e, { relative: a }); return r.useCallback((t => { if (function (e, t) { return 0 === e.button && (!t || "_self" === t) && !function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e) }(t, n)) { t.preventDefault(); let n = void 0 !== i ? i : p(u) === p(d); c(e, { replace: n, state: s, preventScrollReset: o, relative: a, unstable_viewTransition: l }) } }), [u, c, d, i, s, n, e, o, a, l]) }(d, { replace: a, state: l, target: c, preventScrollReset: h, relative: s, unstable_viewTransition: f }); return r.createElement("a", ye({}, m, { href: n || y, onClick: v || o ? i : function (e) { i && i(e), e.defaultPrevented || b(e) }, ref: t, target: c })) })); var Te, Ae; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(Te || (Te = {})), function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" }(Ae || (Ae = {})); const ke = n.p + "static/media/AFOT.f4b84aef5c86ddf14b8f.png"; var je = n(139), Pe = n.n(je); const Ie = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return null != e ? String(e) : t || null }, Re = r.createContext(null); function Oe() { return Oe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Oe.apply(this, arguments) } function De(e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i } n(740); function _e(e) { return "default" + e.charAt(0).toUpperCase() + e.substr(1) } function Me(e) { var t = function (e, t) { if ("object" !== typeof e || null === e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" !== typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" === typeof t ? t : String(t) } function Le(e, t) { return Object.keys(t).reduce((function (n, i) { var s, o = n, a = o[_e(i)], l = o[i], c = De(o, [_e(i), i].map(Me)), u = t[i], d = function (e, t, n) { var i = (0, r.useRef)(void 0 !== e), s = (0, r.useState)(t), o = s[0], a = s[1], l = void 0 !== e, c = i.current; return i.current = l, !l && c && o !== t && a(t), [l ? e : o, (0, r.useCallback)((function (e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; n && n.apply(void 0, [e].concat(r)), a(e) }), [n])] }(l, a, e[u]), h = d[0], f = d[1]; return Oe({}, c, ((s = {})[i] = h, s[u] = f, s)) }), e) } function Fe() { var e = this.constructor.getDerivedStateFromProps(this.props, this.state); null !== e && void 0 !== e && this.setState(e) } function Ue(e) { this.setState(function (t) { var n = this.constructor.getDerivedStateFromProps(e, t); return null !== n && void 0 !== n ? n : null }.bind(this)) } function Be(e, t) { try { var n = this.props, r = this.state; this.props = e, this.state = t, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(n, r) } finally { this.props = n, this.state = r } } Fe.__suppressDeprecationWarning = !0, Ue.__suppressDeprecationWarning = !0, Be.__suppressDeprecationWarning = !0; var Ve = n(579); const ze = ["xxl", "xl", "lg", "md", "sm", "xs"], qe = "xs", He = r.createContext({ prefixes: {}, breakpoints: ze, minBreakpoint: qe }), { Consumer: We, Provider: Ke } = He; function Ge(e, t) { const { prefixes: n } = (0, r.useContext)(He); return e || n[t] || t } const Qe = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i, ...s } = e; n = Ge(n, "navbar-brand"); const o = i || (s.href ? "a" : "span"); return (0, Ve.jsx)(o, { ...s, ref: t, className: Pe()(r, n) }) })); Qe.displayName = "NavbarBrand"; const Ye = Qe; function Je(e) { return e && e.ownerDocument || document } function Xe(e, t) { return function (e) { var t = Je(e); return t && t.defaultView || window }(e).getComputedStyle(e, t) } var Ze = /([A-Z])/g; var $e = /^ms-/; function et(e) { return function (e) { return e.replace(Ze, "-$1").toLowerCase() }(e).replace($e, "-ms-") } var tt = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i; const nt = function (e, t) { var n = "", r = ""; if ("string" === typeof t) return e.style.getPropertyValue(et(t)) || Xe(e).getPropertyValue(et(t)); Object.keys(t).forEach((function (i) { var s = t[i]; s || 0 === s ? !function (e) { return !(!e || !tt.test(e)) }(i) ? n += et(i) + ": " + s + ";" : r += i + "(" + s + ") " : e.style.removeProperty(et(i)) })), r && (n += "transform: " + r + ";"), e.style.cssText += ";" + n }; function rt(e, t) { return rt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, rt(e, t) } function it(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, rt(e, t) } const st = !1, ot = r.createContext(null); var at = "unmounted", lt = "exited", ct = "entering", ut = "entered", dt = "exiting", ht = function (e) { function t(t, n) { var r; r = e.call(this, t, n) || this; var i, s = n && !n.isMounting ? t.enter : t.appear; return r.appearStatus = null, t.in ? s ? (i = lt, r.appearStatus = ct) : i = ut : i = t.unmountOnExit || t.mountOnEnter ? at : lt, r.state = { status: i }, r.nextCallback = null, r } it(t, e), t.getDerivedStateFromProps = function (e, t) { return e.in && t.status === at ? { status: lt } : null }; var n = t.prototype; return n.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, n.componentDidUpdate = function (e) { var t = null; if (e !== this.props) { var n = this.state.status; this.props.in ? n !== ct && n !== ut && (t = ct) : n !== ct && n !== ut || (t = dt) } this.updateStatus(!1, t) }, n.componentWillUnmount = function () { this.cancelNextCallback() }, n.getTimeouts = function () { var e, t, n, r = this.props.timeout; return e = t = n = r, null != r && "number" !== typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), { exit: e, enter: t, appear: n } }, n.updateStatus = function (e, t) { if (void 0 === e && (e = !1), null !== t) if (this.cancelNextCallback(), t === ct) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var n = this.props.nodeRef ? this.props.nodeRef.current : o.findDOMNode(this); n && function (e) { e.scrollTop }(n) } this.performEnter(e) } else this.performExit(); else this.props.unmountOnExit && this.state.status === lt && this.setState({ status: at }) }, n.performEnter = function (e) { var t = this, n = this.props.enter, r = this.context ? this.context.isMounting : e, i = this.props.nodeRef ? [r] : [o.findDOMNode(this), r], s = i[0], a = i[1], l = this.getTimeouts(), c = r ? l.appear : l.enter; !e && !n || st ? this.safeSetState({ status: ut }, (function () { t.props.onEntered(s) })) : (this.props.onEnter(s, a), this.safeSetState({ status: ct }, (function () { t.props.onEntering(s, a), t.onTransitionEnd(c, (function () { t.safeSetState({ status: ut }, (function () { t.props.onEntered(s, a) })) })) }))) }, n.performExit = function () { var e = this, t = this.props.exit, n = this.getTimeouts(), r = this.props.nodeRef ? void 0 : o.findDOMNode(this); t && !st ? (this.props.onExit(r), this.safeSetState({ status: dt }, (function () { e.props.onExiting(r), e.onTransitionEnd(n.exit, (function () { e.safeSetState({ status: lt }, (function () { e.props.onExited(r) })) })) }))) : this.safeSetState({ status: lt }, (function () { e.props.onExited(r) })) }, n.cancelNextCallback = function () { null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null) }, n.safeSetState = function (e, t) { t = this.setNextCallback(t), this.setState(e, t) }, n.setNextCallback = function (e) { var t = this, n = !0; return this.nextCallback = function (r) { n && (n = !1, t.nextCallback = null, e(r)) }, this.nextCallback.cancel = function () { n = !1 }, this.nextCallback }, n.onTransitionEnd = function (e, t) { this.setNextCallback(t); var n = this.props.nodeRef ? this.props.nodeRef.current : o.findDOMNode(this), r = null == e && !this.props.addEndListener; if (n && !r) { if (this.props.addEndListener) { var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback], s = i[0], a = i[1]; this.props.addEndListener(s, a) } null != e && setTimeout(this.nextCallback, e) } else setTimeout(this.nextCallback, 0) }, n.render = function () { var e = this.state.status; if (e === at) return null; var t = this.props, n = t.children, i = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, De(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"])); return r.createElement(ot.Provider, { value: null }, "function" === typeof n ? n(e, i) : r.cloneElement(r.Children.only(n), i)) }, t }(r.Component); function ft() { } ht.contextType = ot, ht.propTypes = {}, ht.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: ft, onEntering: ft, onEntered: ft, onExit: ft, onExiting: ft, onExited: ft }, ht.UNMOUNTED = at, ht.EXITED = lt, ht.ENTERING = ct, ht.ENTERED = ut, ht.EXITING = dt; const pt = ht, mt = !("undefined" === typeof window || !window.document || !window.document.createElement); var gt = !1, vt = !1; try { var yt = { get passive() { return gt = !0 }, get once() { return vt = gt = !0 } }; mt && (window.addEventListener("test", yt, yt), window.removeEventListener("test", yt, !0)) } catch (sI) { } const bt = function (e, t, n, r) { if (r && "boolean" !== typeof r && !vt) { var i = r.once, s = r.capture, o = n; !vt && i && (o = n.__once || function e(r) { this.removeEventListener(t, e, s), n.call(this, r) }, n.__once = o), e.addEventListener(t, o, gt ? r : s) } e.addEventListener(t, n, r) }; const wt = function (e, t, n, r) { var i = r && "boolean" !== typeof r ? r.capture : r; e.removeEventListener(t, n, i), n.__once && e.removeEventListener(t, n.__once, i) }; const xt = function (e, t, n, r) { return bt(e, t, n, r), function () { wt(e, t, n, r) } }; function Et(e, t, n) { void 0 === n && (n = 5); var r = !1, i = setTimeout((function () { r || function (e, t, n, r) { if (void 0 === n && (n = !1), void 0 === r && (r = !0), e) { var i = document.createEvent("HTMLEvents"); i.initEvent(t, n, r), e.dispatchEvent(i) } }(e, "transitionend", !0) }), t + n), s = xt(e, "transitionend", (function () { r = !0 }), { once: !0 }); return function () { clearTimeout(i), s() } } function St(e, t, n, r) { null == n && (n = function (e) { var t = nt(e, "transitionDuration") || "", n = -1 === t.indexOf("ms") ? 1e3 : 1; return parseFloat(t) * n }(e) || 0); var i = Et(e, n, r), s = xt(e, "transitionend", t); return function () { i(), s() } } function Nt(e, t) { const n = nt(e, t) || "", r = -1 === n.indexOf("ms") ? 1e3 : 1; return parseFloat(n) * r } function Ct(e, t) { const n = Nt(e, "transitionDuration"), r = Nt(e, "transitionDelay"), i = St(e, (n => { n.target === e && (i(), t(n)) }), n + r) } const Tt = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.filter((e => null != e)).reduce(((e, t) => { if ("function" !== typeof t) throw new Error("Invalid Argument Type, must only provide functions, undefined, or null."); return null === e ? t : function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; e.apply(this, r), t.apply(this, r) } }), null) }; function At(e) { e.offsetHeight } const kt = e => e && "function" !== typeof e ? t => { e.current = t } : e; const jt = function (e, t) { return (0, r.useMemo)((() => function (e, t) { const n = kt(e), r = kt(t); return e => { n && n(e), r && r(e) } }(e, t)), [e, t]) }; const Pt = r.forwardRef(((e, t) => { let { onEnter: n, onEntering: i, onEntered: s, onExit: a, onExiting: l, onExited: c, addEndListener: u, children: d, childRef: h, ...f } = e; const p = (0, r.useRef)(null), m = jt(p, h), g = e => { var t; m((t = e) && "setState" in t ? o.findDOMNode(t) : null != t ? t : null) }, v = e => t => { e && p.current && e(p.current, t) }, y = (0, r.useCallback)(v(n), [n]), b = (0, r.useCallback)(v(i), [i]), w = (0, r.useCallback)(v(s), [s]), x = (0, r.useCallback)(v(a), [a]), E = (0, r.useCallback)(v(l), [l]), S = (0, r.useCallback)(v(c), [c]), N = (0, r.useCallback)(v(u), [u]); return (0, Ve.jsx)(pt, { ref: t, ...f, onEnter: y, onEntered: w, onEntering: b, onExit: x, onExited: S, onExiting: E, addEndListener: N, nodeRef: p, children: "function" === typeof d ? (e, t) => d(e, { ...t, ref: g }) : r.cloneElement(d, { ref: g }) }) })), It = Pt, Rt = { height: ["marginTop", "marginBottom"], width: ["marginLeft", "marginRight"] }; function Ot(e, t) { const n = t["offset".concat(e[0].toUpperCase()).concat(e.slice(1))], r = Rt[e]; return n + parseInt(nt(t, r[0]), 10) + parseInt(nt(t, r[1]), 10) } const Dt = { [lt]: "collapse", [dt]: "collapsing", [ct]: "collapsing", [ut]: "collapse show" }, _t = r.forwardRef(((e, t) => { let { onEnter: n, onEntering: i, onEntered: s, onExit: o, onExiting: a, className: l, children: c, dimension: u = "height", in: d = !1, timeout: h = 300, mountOnEnter: f = !1, unmountOnExit: p = !1, appear: m = !1, getDimensionValue: g = Ot, ...v } = e; const y = "function" === typeof u ? u() : u, b = (0, r.useMemo)((() => Tt((e => { e.style[y] = "0" }), n)), [y, n]), w = (0, r.useMemo)((() => Tt((e => { const t = "scroll".concat(y[0].toUpperCase()).concat(y.slice(1)); e.style[y] = "".concat(e[t], "px") }), i)), [y, i]), x = (0, r.useMemo)((() => Tt((e => { e.style[y] = null }), s)), [y, s]), E = (0, r.useMemo)((() => Tt((e => { e.style[y] = "".concat(g(y, e), "px"), At(e) }), o)), [o, g, y]), S = (0, r.useMemo)((() => Tt((e => { e.style[y] = null }), a)), [y, a]); return (0, Ve.jsx)(It, { ref: t, addEndListener: Ct, ...v, "aria-expanded": v.role ? d : null, onEnter: b, onEntering: w, onEntered: x, onExit: E, onExiting: S, childRef: c.ref, in: d, timeout: h, mountOnEnter: f, unmountOnExit: p, appear: m, children: (e, t) => r.cloneElement(c, { ...t, className: Pe()(l, c.props.className, Dt[e], "width" === y && "collapse-horizontal") }) }) })), Mt = _t, Lt = r.createContext(null); Lt.displayName = "NavbarContext"; const Ft = Lt, Ut = r.forwardRef(((e, t) => { let { children: n, bsPrefix: i, ...s } = e; i = Ge(i, "navbar-collapse"); const o = (0, r.useContext)(Ft); return (0, Ve.jsx)(Mt, { in: !(!o || !o.expanded), ...s, children: (0, Ve.jsx)("div", { ref: t, className: i, children: n }) }) })); Ut.displayName = "NavbarCollapse"; const Bt = Ut; const Vt = function (e) { const t = (0, r.useRef)(e); return (0, r.useEffect)((() => { t.current = e }), [e]), t }; function zt(e) { const t = Vt(e); return (0, r.useCallback)((function () { return t.current && t.current(...arguments) }), [t]) } const qt = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, children: s, label: o = "Toggle navigation", as: a = "button", onClick: l, ...c } = e; n = Ge(n, "navbar-toggler"); const { onToggle: u, expanded: d } = (0, r.useContext)(Ft) || {}, h = zt((e => { l && l(e), u && u() })); return "button" === a && (c.type = "button"), (0, Ve.jsx)(a, { ...c, ref: t, onClick: h, "aria-label": o, className: Pe()(i, n, !d && "collapsed"), children: s || (0, Ve.jsx)("span", { className: "".concat(n, "-icon") }) }) })); qt.displayName = "NavbarToggle"; const Ht = qt, Wt = "undefined" !== typeof n.g && n.g.navigator && "ReactNative" === n.g.navigator.product, Kt = "undefined" !== typeof document || Wt ? r.useLayoutEffect : r.useEffect, Gt = new WeakMap, Qt = (e, t) => { if (!e || !t) return; const n = Gt.get(t) || new Map; Gt.set(t, n); let r = n.get(e); return r || (r = t.matchMedia(e), r.refCount = 0, n.set(r.media, r)), r }; function Yt(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "undefined" === typeof window ? void 0 : window; const n = Qt(e, t), [i, s] = (0, r.useState)((() => !!n && n.matches)); return Kt((() => { let n = Qt(e, t); if (!n) return s(!1); let r = Gt.get(t); const i = () => { s(n.matches) }; return n.refCount++, n.addListener(i), i(), () => { n.removeListener(i), n.refCount--, n.refCount <= 0 && (null == r || r.delete(n.media)), n = void 0 } }), [e]), i } const Jt = function (e) { const t = Object.keys(e); function n(e, t) { return e === t ? t : e ? "".concat(e, " and ").concat(t) : t } function i(n) { const r = function (e) { return t[Math.min(t.indexOf(e) + 1, t.length - 1)] }(n); let i = e[r]; return i = "number" === typeof i ? "".concat(i - .2, "px") : "calc(".concat(i, " - 0.2px)"), "(max-width: ".concat(i, ")") } return function (t, s, o) { let a; "object" === typeof t ? (a = t, o = s, s = !0) : a = { [t]: s = s || !0 }; let l = (0, r.useMemo)((() => Object.entries(a).reduce(((t, r) => { let [s, o] = r; return "up" !== o && !0 !== o || (t = n(t, function (t) { let n = e[t]; return "number" === typeof n && (n = "".concat(n, "px")), "(min-width: ".concat(n, ")") }(s))), "down" !== o && !0 !== o || (t = n(t, i(s))), t }), "")), [JSON.stringify(a)]); return Yt(l, o) } }({ xs: 0, sm: 576, md: 768, lg: 992, xl: 1200, xxl: 1400 }), Xt = Jt; function Zt(e) { void 0 === e && (e = Je()); try { var t = e.activeElement; return t && t.nodeName ? t : null } catch (sI) { return e.body } } function $t(e, t) { return e.contains ? e.contains(t) : e.compareDocumentPosition ? e === t || !!(16 & e.compareDocumentPosition(t)) : void 0 } function en() { const e = (0, r.useRef)(!0), t = (0, r.useRef)((() => e.current)); return (0, r.useEffect)((() => (e.current = !0, () => { e.current = !1 })), []), t.current } function tn(e) { const t = function (e) { const t = (0, r.useRef)(e); return t.current = e, t }(e); (0, r.useEffect)((() => () => t.current()), []) } function nn(e) { const t = (0, r.useRef)(null); return (0, r.useEffect)((() => { t.current = e })), t.current } const rn = "data-rr-ui-"; function sn(e) { return "".concat(rn).concat(e) } const on = sn("modal-open"); const an = class { constructor() { let { ownerDocument: e, handleContainerOverflow: t = !0, isRTL: n = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.handleContainerOverflow = t, this.isRTL = n, this.modals = [], this.ownerDocument = e } getScrollbarWidth() { return function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document; const t = e.defaultView; return Math.abs(t.innerWidth - e.documentElement.clientWidth) }(this.ownerDocument) } getElement() { return (this.ownerDocument || document).body } setModalAttributes(e) { } removeModalAttributes(e) { } setContainerStyle(e) { const t = { overflow: "hidden" }, n = this.isRTL ? "paddingLeft" : "paddingRight", r = this.getElement(); e.style = { overflow: r.style.overflow, [n]: r.style[n] }, e.scrollBarWidth && (t[n] = "".concat(parseInt(nt(r, n) || "0", 10) + e.scrollBarWidth, "px")), r.setAttribute(on, ""), nt(r, t) } reset() { [...this.modals].forEach((e => this.remove(e))) } removeContainerStyle(e) { const t = this.getElement(); t.removeAttribute(on), Object.assign(t.style, e.style) } add(e) { let t = this.modals.indexOf(e); return -1 !== t ? t : (t = this.modals.length, this.modals.push(e), this.setModalAttributes(e), 0 !== t || (this.state = { scrollBarWidth: this.getScrollbarWidth(), style: {} }, this.handleContainerOverflow && this.setContainerStyle(this.state)), t) } remove(e) { const t = this.modals.indexOf(e); -1 !== t && (this.modals.splice(t, 1), !this.modals.length && this.handleContainerOverflow && this.removeContainerStyle(this.state), this.removeModalAttributes(e)) } isTopModal(e) { return !!this.modals.length && this.modals[this.modals.length - 1] === e } }, ln = (0, r.createContext)(mt ? window : void 0); ln.Provider; function cn() { return (0, r.useContext)(ln) } const un = (e, t) => mt ? null == e ? (t || Je()).body : ("function" === typeof e && (e = e()), e && "current" in e && (e = e.current), e && ("nodeType" in e || e.getBoundingClientRect) ? e : null) : null; const dn = function (e) { let { children: t, in: n, onExited: i, mountOnEnter: s, unmountOnExit: o } = e; const a = (0, r.useRef)(null), l = (0, r.useRef)(n), c = zt(i); (0, r.useEffect)((() => { n ? l.current = !0 : c(a.current) }), [n, c]); const u = jt(a, t.ref), d = (0, r.cloneElement)(t, { ref: u }); return n ? d : o || !l.current && s ? null : d }, hn = ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "addEndListener", "children"]; function fn(e) { let { onEnter: t, onEntering: n, onEntered: i, onExit: s, onExiting: o, onExited: a, addEndListener: l, children: c } = e, u = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, hn); const d = (0, r.useRef)(null), h = jt(d, "function" === typeof c ? null : c.ref), f = e => t => { e && d.current && e(d.current, t) }, p = (0, r.useCallback)(f(t), [t]), m = (0, r.useCallback)(f(n), [n]), g = (0, r.useCallback)(f(i), [i]), v = (0, r.useCallback)(f(s), [s]), y = (0, r.useCallback)(f(o), [o]), b = (0, r.useCallback)(f(a), [a]), w = (0, r.useCallback)(f(l), [l]); return Object.assign({}, u, { nodeRef: d }, t && { onEnter: p }, n && { onEntering: m }, i && { onEntered: g }, s && { onExit: v }, o && { onExiting: y }, a && { onExited: b }, l && { addEndListener: w }, { children: "function" === typeof c ? (e, t) => c(e, Object.assign({}, t, { ref: h })) : (0, r.cloneElement)(c, { ref: h }) }) } const pn = ["component"]; const mn = r.forwardRef(((e, t) => { let { component: n } = e, r = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, pn); const i = fn(r); return (0, Ve.jsx)(n, Object.assign({ ref: t }, i)) })), gn = mn; function vn(e) { let { children: t, in: n, onExited: i, onEntered: s, transition: o } = e; const [a, l] = (0, r.useState)(!n); n && a && l(!1); const c = function (e) { let { in: t, onTransition: n } = e; const i = (0, r.useRef)(null), s = (0, r.useRef)(!0), o = zt(n); return Kt((() => { if (!i.current) return; let e = !1; return o({ in: t, element: i.current, initial: s.current, isStale: () => e }), () => { e = !0 } }), [t, o]), Kt((() => (s.current = !1, () => { s.current = !0 })), []), i }({ in: !!n, onTransition: e => { Promise.resolve(o(e)).then((() => { e.isStale() || (e.in ? null == s || s(e.element, e.initial) : (l(!0), null == i || i(e.element))) }), (t => { throw e.in || l(!0), t })) } }), u = jt(c, t.ref); return a && !n ? null : (0, r.cloneElement)(t, { ref: u }) } function yn(e, t, n) { return e ? (0, Ve.jsx)(gn, Object.assign({}, n, { component: e })) : t ? (0, Ve.jsx)(vn, Object.assign({}, n, { transition: t })) : (0, Ve.jsx)(dn, Object.assign({}, n)) } const bn = ["show", "role", "className", "style", "children", "backdrop", "keyboard", "onBackdropClick", "onEscapeKeyDown", "transition", "runTransition", "backdropTransition", "runBackdropTransition", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "renderDialog", "renderBackdrop", "manager", "container", "onShow", "onHide", "onExit", "onExited", "onExiting", "onEnter", "onEntering", "onEntered"]; let wn; function xn(e) { const t = cn(), n = e || function (e) { return wn || (wn = new an({ ownerDocument: null == e ? void 0 : e.document })), wn }(t), i = (0, r.useRef)({ dialog: null, backdrop: null }); return Object.assign(i.current, { add: () => n.add(i.current), remove: () => n.remove(i.current), isTopModal: () => n.isTopModal(i.current), setDialogRef: (0, r.useCallback)((e => { i.current.dialog = e }), []), setBackdropRef: (0, r.useCallback)((e => { i.current.backdrop = e }), []) }) } const En = (0, r.forwardRef)(((e, t) => { let { show: n = !1, role: i = "dialog", className: s, style: a, children: l, backdrop: c = !0, keyboard: u = !0, onBackdropClick: d, onEscapeKeyDown: h, transition: f, runTransition: p, backdropTransition: m, runBackdropTransition: g, autoFocus: v = !0, enforceFocus: y = !0, restoreFocus: b = !0, restoreFocusOptions: w, renderDialog: x, renderBackdrop: E = (e => (0, Ve.jsx)("div", Object.assign({}, e))), manager: S, container: N, onShow: C, onHide: T = (() => { }), onExit: A, onExited: k, onExiting: j, onEnter: P, onEntering: I, onEntered: R } = e, O = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, bn); const D = cn(), _ = function (e, t) { const n = cn(), [i, s] = (0, r.useState)((() => un(e, null == n ? void 0 : n.document))); if (!i) { const t = un(e); t && s(t) } return (0, r.useEffect)((() => { t && i && t(i) }), [t, i]), (0, r.useEffect)((() => { const t = un(e); t !== i && s(t) }), [e, i]), i }(N), M = xn(S), L = en(), F = nn(n), [U, B] = (0, r.useState)(!n), V = (0, r.useRef)(null); (0, r.useImperativeHandle)(t, (() => M), [M]), mt && !F && n && (V.current = Zt(null == D ? void 0 : D.document)), n && U && B(!1); const z = zt((() => { if (M.add(), Q.current = xt(document, "keydown", K), G.current = xt(document, "focus", (() => setTimeout(H)), !0), C && C(), v) { var e, t; const n = Zt(null != (e = null == (t = M.dialog) ? void 0 : t.ownerDocument) ? e : null == D ? void 0 : D.document); M.dialog && n && !$t(M.dialog, n) && (V.current = n, M.dialog.focus()) } })), q = zt((() => { var e; (M.remove(), null == Q.current || Q.current(), null == G.current || G.current(), b) && (null == (e = V.current) || null == e.focus || e.focus(w), V.current = null) })); (0, r.useEffect)((() => { n && _ && z() }), [n, _, z]), (0, r.useEffect)((() => { U && q() }), [U, q]), tn((() => { q() })); const H = zt((() => { if (!y || !L() || !M.isTopModal()) return; const e = Zt(null == D ? void 0 : D.document); M.dialog && e && !$t(M.dialog, e) && M.dialog.focus() })), W = zt((e => { e.target === e.currentTarget && (null == d || d(e), !0 === c && T()) })), K = zt((e => { u && function (e) { return "Escape" === e.code || 27 === e.keyCode }(e) && M.isTopModal() && (null == h || h(e), e.defaultPrevented || T()) })), G = (0, r.useRef)(), Q = (0, r.useRef)(); if (!_) return null; const Y = Object.assign({ role: i, ref: M.setDialogRef, "aria-modal": "dialog" === i || void 0 }, O, { style: a, className: s, tabIndex: -1 }); let J = x ? x(Y) : (0, Ve.jsx)("div", Object.assign({}, Y, { children: r.cloneElement(l, { role: "document" }) })); J = yn(f, p, { unmountOnExit: !0, mountOnEnter: !0, appear: !0, in: !!n, onExit: A, onExiting: j, onExited: function () { B(!0), null == k || k(...arguments) }, onEnter: P, onEntering: I, onEntered: R, children: J }); let X = null; return c && (X = E({ ref: M.setBackdropRef, onClick: W }), X = yn(m, g, { in: !!n, appear: !0, mountOnEnter: !0, unmountOnExit: !0, children: X })), (0, Ve.jsx)(Ve.Fragment, { children: o.createPortal((0, Ve.jsxs)(Ve.Fragment, { children: [X, J] }), _) }) })); En.displayName = "Modal"; const Sn = Object.assign(En, { Manager: an }), Nn = { [ct]: "show", [ut]: "show" }, Cn = r.forwardRef(((e, t) => { let { className: n, children: i, transitionClasses: s = {}, onEnter: o, ...a } = e; const l = { in: !1, timeout: 300, mountOnEnter: !1, unmountOnExit: !1, appear: !1, ...a }, c = (0, r.useCallback)(((e, t) => { At(e), null == o || o(e, t) }), [o]); return (0, Ve.jsx)(It, { ref: t, addEndListener: Ct, ...l, onEnter: c, childRef: i.ref, children: (e, t) => r.cloneElement(i, { ...t, className: Pe()("fade", n, i.props.className, Nn[e], s[e]) }) }) })); Cn.displayName = "Fade"; const Tn = Cn, An = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = Ge(r, "offcanvas-body"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); An.displayName = "OffcanvasBody"; const kn = An, jn = { [ct]: "show", [ut]: "show" }, Pn = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, children: s, in: o = !1, mountOnEnter: a = !1, unmountOnExit: l = !1, appear: c = !1, ...u } = e; return n = Ge(n, "offcanvas"), (0, Ve.jsx)(It, { ref: t, addEndListener: Ct, in: o, mountOnEnter: a, unmountOnExit: l, appear: c, ...u, childRef: s.ref, children: (e, t) => r.cloneElement(s, { ...t, className: Pe()(i, s.props.className, (e === ct || e === dt) && "".concat(n, "-toggling"), jn[e]) }) }) })); Pn.displayName = "OffcanvasToggling"; const In = Pn, Rn = r.createContext({ onHide() { } }); var On = n(173), Dn = n.n(On); const _n = { "aria-label": Dn().string, onClick: Dn().func, variant: Dn().oneOf(["white"]) }, Mn = r.forwardRef(((e, t) => { let { className: n, variant: r, "aria-label": i = "Close", ...s } = e; return (0, Ve.jsx)("button", { ref: t, type: "button", className: Pe()("btn-close", r && "btn-close-".concat(r), n), "aria-label": i, ...s }) })); Mn.displayName = "CloseButton", Mn.propTypes = _n; const Ln = Mn, Fn = r.forwardRef(((e, t) => { let { closeLabel: n = "Close", closeVariant: i, closeButton: s = !1, onHide: o, children: a, ...l } = e; const c = (0, r.useContext)(Rn), u = zt((() => { null == c || c.onHide(), null == o || o() })); return (0, Ve.jsxs)("div", { ref: t, ...l, children: [a, s && (0, Ve.jsx)(Ln, { "aria-label": n, variant: i, onClick: u })] }) })), Un = Fn, Bn = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, closeLabel: i = "Close", closeButton: s = !1, ...o } = e; return n = Ge(n, "offcanvas-header"), (0, Ve.jsx)(Un, { ref: t, ...o, className: Pe()(r, n), closeLabel: i, closeButton: s }) })); Bn.displayName = "OffcanvasHeader"; const Vn = Bn, zn = (qn = "h5", r.forwardRef(((e, t) => (0, Ve.jsx)("div", { ...e, ref: t, className: Pe()(e.className, qn) })))); var qn; const Hn = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = zn, ...s } = e; return r = Ge(r, "offcanvas-title"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); Hn.displayName = "OffcanvasTitle"; const Wn = Hn; var Kn = Function.prototype.bind.call(Function.prototype.call, [].slice); function Gn(e, t) { return Kn(e.querySelectorAll(t)) } function Qn(e, t) { return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "") } const Yn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Jn = ".sticky-top", Xn = ".navbar-toggler"; class Zn extends an { adjustAndStore(e, t, n) { const r = t.style[e]; t.dataset[e] = r, nt(t, { [e]: "".concat(parseFloat(nt(t, e)) + n, "px") }) } restore(e, t) { const n = t.dataset[e]; void 0 !== n && (delete t.dataset[e], nt(t, { [e]: n })) } setContainerStyle(e) { super.setContainerStyle(e); const t = this.getElement(); if (function (e, t) { e.classList ? e.classList.add(t) : function (e, t) { return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") }(e, t) || ("string" === typeof e.className ? e.className = e.className + " " + t : e.setAttribute("class", (e.className && e.className.baseVal || "") + " " + t)) }(t, "modal-open"), !e.scrollBarWidth) return; const n = this.isRTL ? "paddingLeft" : "paddingRight", r = this.isRTL ? "marginLeft" : "marginRight"; Gn(t, Yn).forEach((t => this.adjustAndStore(n, t, e.scrollBarWidth))), Gn(t, Jn).forEach((t => this.adjustAndStore(r, t, -e.scrollBarWidth))), Gn(t, Xn).forEach((t => this.adjustAndStore(r, t, e.scrollBarWidth))) } removeContainerStyle(e) { super.removeContainerStyle(e); const t = this.getElement(); !function (e, t) { e.classList ? e.classList.remove(t) : "string" === typeof e.className ? e.className = Qn(e.className, t) : e.setAttribute("class", Qn(e.className && e.className.baseVal || "", t)) }(t, "modal-open"); const n = this.isRTL ? "paddingLeft" : "paddingRight", r = this.isRTL ? "marginLeft" : "marginRight"; Gn(t, Yn).forEach((e => this.restore(n, e))), Gn(t, Jn).forEach((e => this.restore(r, e))), Gn(t, Xn).forEach((e => this.restore(r, e))) } } let $n; const er = Zn; function tr(e) { return (0, Ve.jsx)(In, { ...e }) } function nr(e) { return (0, Ve.jsx)(Tn, { ...e }) } const rr = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, children: s, "aria-labelledby": o, placement: a = "start", responsive: l, show: c = !1, backdrop: u = !0, keyboard: d = !0, scroll: h = !1, onEscapeKeyDown: f, onShow: p, onHide: m, container: g, autoFocus: v = !0, enforceFocus: y = !0, restoreFocus: b = !0, restoreFocusOptions: w, onEntered: x, onExit: E, onExiting: S, onEnter: N, onEntering: C, onExited: T, backdropClassName: A, manager: k, renderStaticNode: j = !1, ...P } = e; const I = (0, r.useRef)(); n = Ge(n, "offcanvas"); const { onToggle: R } = (0, r.useContext)(Ft) || {}, [O, D] = (0, r.useState)(!1), _ = Xt(l || "xs", "up"); (0, r.useEffect)((() => { D(l ? c && !_ : c) }), [c, l, _]); const M = zt((() => { null == R || R(), null == m || m() })), L = (0, r.useMemo)((() => ({ onHide: M })), [M]); const F = (0, r.useCallback)((e => (0, Ve.jsx)("div", { ...e, className: Pe()("".concat(n, "-backdrop"), A) })), [A, n]), U = e => (0, Ve.jsx)("div", { ...e, ...P, className: Pe()(i, l ? "".concat(n, "-").concat(l) : n, "".concat(n, "-").concat(a)), "aria-labelledby": o, children: s }); return (0, Ve.jsxs)(Ve.Fragment, { children: [!O && (l || j) && U({}), (0, Ve.jsx)(Rn.Provider, { value: L, children: (0, Ve.jsx)(Sn, { show: O, ref: t, backdrop: u, container: g, keyboard: d, autoFocus: v, enforceFocus: y && !h, restoreFocus: b, restoreFocusOptions: w, onEscapeKeyDown: f, onShow: p, onHide: M, onEnter: function (e) { e && (e.style.visibility = "visible"); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; null == N || N(e, ...n) }, onEntering: C, onEntered: x, onExit: E, onExiting: S, onExited: function (e) { e && (e.style.visibility = ""); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; null == T || T(...n) }, manager: k || (h ? (I.current || (I.current = new er({ handleContainerOverflow: !1 })), I.current) : function (e) { return $n || ($n = new Zn(e)), $n }()), transition: tr, backdropTransition: nr, renderBackdrop: F, renderDialog: U }) })] }) })); rr.displayName = "Offcanvas"; const ir = Object.assign(rr, { Body: kn, Header: Vn, Title: Wn }), sr = r.forwardRef(((e, t) => { const n = (0, r.useContext)(Ft); return (0, Ve.jsx)(ir, { ref: t, show: !(null == n || !n.expanded), ...e, renderStaticNode: !0 }) })); sr.displayName = "NavbarOffcanvas"; const or = sr, ar = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "span", ...s } = e; return r = Ge(r, "navbar-text"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); ar.displayName = "NavbarText"; const lr = ar, cr = r.forwardRef(((e, t) => { const { bsPrefix: n, expand: i = !0, variant: s = "light", bg: o, fixed: a, sticky: l, className: c, as: u = "nav", expanded: d, onToggle: h, onSelect: f, collapseOnSelect: p = !1, ...m } = Le(e, { expanded: "onToggle" }), g = Ge(n, "navbar"), v = (0, r.useCallback)((function () { null == f || f(...arguments), p && d && (null == h || h(!1)) }), [f, p, d, h]); void 0 === m.role && "nav" !== u && (m.role = "navigation"); let y = "".concat(g, "-expand"); "string" === typeof i && (y = "".concat(y, "-").concat(i)); const b = (0, r.useMemo)((() => ({ onToggle: () => null == h ? void 0 : h(!d), bsPrefix: g, expanded: !!d, expand: i })), [g, d, i, h]); return (0, Ve.jsx)(Ft.Provider, { value: b, children: (0, Ve.jsx)(Re.Provider, { value: v, children: (0, Ve.jsx)(u, { ref: t, ...m, className: Pe()(c, g, i && y, s && "".concat(g, "-").concat(s), o && "bg-".concat(o), l && "sticky-".concat(l), a && "fixed-".concat(a)) }) }) }) })); cr.displayName = "Navbar"; const ur = Object.assign(cr, { Brand: Ye, Collapse: Bt, Offcanvas: or, Text: lr, Toggle: Ht }), dr = r.forwardRef(((e, t) => { let { bsPrefix: n, fluid: r = !1, as: i = "div", className: s, ...o } = e; const a = Ge(n, "container"), l = "string" === typeof r ? "-".concat(r) : "-fluid"; return (0, Ve.jsx)(i, { ref: t, ...o, className: Pe()(s, r ? "".concat(a).concat(l) : a) }) })); dr.displayName = "Container"; const hr = dr; n(197); function fr() { const [, e] = (0, r.useReducer)((e => !e), !1); return e } const pr = r.createContext(null); pr.displayName = "NavContext"; const mr = pr, gr = r.createContext(null), vr = ["as", "disabled"]; function yr(e) { let { tagName: t, disabled: n, href: r, target: i, rel: s, role: o, onClick: a, tabIndex: l = 0, type: c } = e; t || (t = null != r || null != i || null != s ? "a" : "button"); const u = { tagName: t }; if ("button" === t) return [{ type: c || "button", disabled: n }, u]; const d = e => { (n || "a" === t && function (e) { return !e || "#" === e.trim() }(r)) && e.preventDefault(), n ? e.stopPropagation() : null == a || a(e) }; return "a" === t && (r || (r = "#"), n && (r = void 0)), [{ role: null != o ? o : "button", disabled: void 0, tabIndex: n ? void 0 : l, href: r, target: "a" === t ? i : void 0, "aria-disabled": n || void 0, rel: "a" === t ? s : void 0, onClick: d, onKeyDown: e => { " " === e.key && (e.preventDefault(), d(e)) } }, u] } const br = r.forwardRef(((e, t) => { let { as: n, disabled: r } = e, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, vr); const [s, { tagName: o }] = yr(Object.assign({ tagName: n, disabled: r }, i)); return (0, Ve.jsx)(o, Object.assign({}, i, s, { ref: t })) })); br.displayName = "Button"; const wr = br, xr = ["as", "active", "eventKey"]; function Er(e) { let { key: t, onClick: n, active: i, id: s, role: o, disabled: a } = e; const l = (0, r.useContext)(Re), c = (0, r.useContext)(mr), u = (0, r.useContext)(gr); let d = i; const h = { role: o }; if (c) { o || "tablist" !== c.role || (h.role = "tab"); const e = c.getControllerId(null != t ? t : null), n = c.getControlledId(null != t ? t : null); h[sn("event-key")] = t, h.id = e || s, d = null == i && null != t ? c.activeKey === t : i, !d && (null != u && u.unmountOnExit || null != u && u.mountOnEnter) || (h["aria-controls"] = n) } return "tab" === h.role && (h["aria-selected"] = d, d || (h.tabIndex = -1), a && (h.tabIndex = -1, h["aria-disabled"] = !0)), h.onClick = zt((e => { a || (null == n || n(e), null != t && l && !e.isPropagationStopped() && l(t, e)) })), [h, { isActive: d }] } const Sr = r.forwardRef(((e, t) => { let { as: n = wr, active: r, eventKey: i } = e, s = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, xr); const [o, a] = Er(Object.assign({ key: Ie(i, s.href), active: r }, s)); return o[sn("active")] = a.isActive, (0, Ve.jsx)(n, Object.assign({}, s, o, { ref: t })) })); Sr.displayName = "NavItem"; const Nr = Sr, Cr = ["as", "onSelect", "activeKey", "role", "onKeyDown"]; const Tr = () => { }, Ar = sn("event-key"), kr = r.forwardRef(((e, t) => { let { as: n = "div", onSelect: i, activeKey: s, role: o, onKeyDown: a } = e, l = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, Cr); const c = fr(), u = (0, r.useRef)(!1), d = (0, r.useContext)(Re), h = (0, r.useContext)(gr); let f, p; h && (o = o || "tablist", s = h.activeKey, f = h.getControlledId, p = h.getControllerId); const m = (0, r.useRef)(null), g = e => { const t = m.current; if (!t) return null; const n = Gn(t, "[".concat(Ar, "]:not([aria-disabled=true])")), r = t.querySelector("[aria-selected=true]"); if (!r || r !== document.activeElement) return null; const i = n.indexOf(r); if (-1 === i) return null; let s = i + e; return s >= n.length && (s = 0), s < 0 && (s = n.length - 1), n[s] }, v = (e, t) => { null != e && (null == i || i(e, t), null == d || d(e, t)) }; (0, r.useEffect)((() => { if (m.current && u.current) { const e = m.current.querySelector("[".concat(Ar, "][aria-selected=true]")); null == e || e.focus() } u.current = !1 })); const y = jt(t, m); return (0, Ve.jsx)(Re.Provider, { value: v, children: (0, Ve.jsx)(mr.Provider, { value: { role: o, activeKey: Ie(s), getControlledId: f || Tr, getControllerId: p || Tr }, children: (0, Ve.jsx)(n, Object.assign({}, l, { onKeyDown: e => { if (null == a || a(e), !h) return; let t; switch (e.key) { case "ArrowLeft": case "ArrowUp": t = g(-1); break; case "ArrowRight": case "ArrowDown": t = g(1); break; default: return }var n; t && (e.preventDefault(), v(t.dataset[(n = "EventKey", "".concat("rrUi").concat(n))] || null, e), u.current = !0, c()) }, ref: y, role: o })) }) }) })); kr.displayName = "Nav"; const jr = Object.assign(kr, { Item: Nr }), Pr = r.createContext(null); Pr.displayName = "CardHeaderContext"; const Ir = Pr, Rr = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = Ge(r, "nav-item"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); Rr.displayName = "NavItem"; const Or = Rr; new WeakMap; const Dr = ["onKeyDown"]; const _r = r.forwardRef(((e, t) => { let { onKeyDown: n } = e, r = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, Dr); const [i] = yr(Object.assign({ tagName: "a" }, r)), s = zt((e => { i.onKeyDown(e), null == n || n(e) })); return (o = r.href) && "#" !== o.trim() && "button" !== r.role ? (0, Ve.jsx)("a", Object.assign({ ref: t }, r, { onKeyDown: n })) : (0, Ve.jsx)("a", Object.assign({ ref: t }, r, i, { onKeyDown: s })); var o })); _r.displayName = "Anchor"; const Mr = _r, Lr = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i = Mr, active: s, eventKey: o, disabled: a = !1, ...l } = e; n = Ge(n, "nav-link"); const [c, u] = Er({ key: Ie(o, l.href), active: s, disabled: a, ...l }); return (0, Ve.jsx)(i, { ...l, ...c, ref: t, disabled: a, className: Pe()(r, n, a && "disabled", u.isActive && "active") }) })); Lr.displayName = "NavLink"; const Fr = Lr, Ur = r.forwardRef(((e, t) => { const { as: n = "div", bsPrefix: i, variant: s, fill: o = !1, justify: a = !1, navbar: l, navbarScroll: c, className: u, activeKey: d, ...h } = Le(e, { activeKey: "onSelect" }), f = Ge(i, "nav"); let p, m, g = !1; const v = (0, r.useContext)(Ft), y = (0, r.useContext)(Ir); return v ? (p = v.bsPrefix, g = null == l || l) : y && ({ cardHeaderBsPrefix: m } = y), (0, Ve.jsx)(jr, { as: n, ref: t, activeKey: d, className: Pe()(u, { [f]: !g, ["".concat(p, "-nav")]: g, ["".concat(p, "-nav-scroll")]: g && c, ["".concat(m, "-").concat(s)]: !!m, ["".concat(f, "-").concat(s)]: !!s, ["".concat(f, "-fill")]: o, ["".concat(f, "-justified")]: a }), ...h }) })); Ur.displayName = "Nav"; const Br = Object.assign(Ur, { Item: Or, Link: Fr }); function Vr(e, t, n) { const i = (0, r.useRef)(void 0 !== e), [s, o] = (0, r.useState)(t), a = void 0 !== e, l = i.current; return i.current = a, !a && l && s !== t && o(t), [a ? e : s, (0, r.useCallback)((function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; const [i, ...s] = t; let a = null == n ? void 0 : n(i, ...s); return o(i), a }), [n])] } const zr = r.createContext(null); var qr = Object.prototype.hasOwnProperty; function Hr(e, t, n) { for (n of e.keys()) if (Wr(n, t)) return n } function Wr(e, t) { var n, r, i; if (e === t) return !0; if (e && t && (n = e.constructor) === t.constructor) { if (n === Date) return e.getTime() === t.getTime(); if (n === RegExp) return e.toString() === t.toString(); if (n === Array) { if ((r = e.length) === t.length) for (; r-- && Wr(e[r], t[r]);); return -1 === r } if (n === Set) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r) && "object" === typeof i && !(i = Hr(t, i))) return !1; if (!t.has(i)) return !1 } return !0 } if (n === Map) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r[0]) && "object" === typeof i && !(i = Hr(t, i))) return !1; if (!Wr(r[1], t.get(i))) return !1 } return !0 } if (n === ArrayBuffer) e = new Uint8Array(e), t = new Uint8Array(t); else if (n === DataView) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e.getInt8(r) === t.getInt8(r);); return -1 === r } if (ArrayBuffer.isView(e)) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e[r] === t[r];); return -1 === r } if (!n || "object" === typeof e) { for (n in r = 0, e) { if (qr.call(e, n) && ++r && !qr.call(t, n)) return !1; if (!(n in t) || !Wr(e[n], t[n])) return !1 } return Object.keys(t).length === r } } return e !== e && t !== t } const Kr = function (e) { const t = en(); return [e[0], (0, r.useCallback)((n => { if (t()) return e[1](n) }), [t, e[1]])] }; function Gr(e) { return e.split("-")[0] } function Qr(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function Yr(e) { return e instanceof Qr(e).Element || e instanceof Element } function Jr(e) { return e instanceof Qr(e).HTMLElement || e instanceof HTMLElement } function Xr(e) { return "undefined" !== typeof ShadowRoot && (e instanceof Qr(e).ShadowRoot || e instanceof ShadowRoot) } var Zr = Math.max, $r = Math.min, ei = Math.round; function ti() { var e = navigator.userAgentData; return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map((function (e) { return e.brand + "/" + e.version })).join(" ") : navigator.userAgent } function ni() { return !/^((?!chrome|android).)*safari/i.test(ti()) } function ri(e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !1); var r = e.getBoundingClientRect(), i = 1, s = 1; t && Jr(e) && (i = e.offsetWidth > 0 && ei(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && ei(r.height) / e.offsetHeight || 1); var o = (Yr(e) ? Qr(e) : window).visualViewport, a = !ni() && n, l = (r.left + (a && o ? o.offsetLeft : 0)) / i, c = (r.top + (a && o ? o.offsetTop : 0)) / s, u = r.width / i, d = r.height / s; return { width: u, height: d, top: c, right: l + u, bottom: c + d, left: l, x: l, y: c } } function ii(e) { var t = ri(e), n = e.offsetWidth, r = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function si(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && Xr(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function oi(e) { return e ? (e.nodeName || "").toLowerCase() : null } function ai(e) { return Qr(e).getComputedStyle(e) } function li(e) { return ["table", "td", "th"].indexOf(oi(e)) >= 0 } function ci(e) { return ((Yr(e) ? e.ownerDocument : e.document) || window.document).documentElement } function ui(e) { return "html" === oi(e) ? e : e.assignedSlot || e.parentNode || (Xr(e) ? e.host : null) || ci(e) } function di(e) { return Jr(e) && "fixed" !== ai(e).position ? e.offsetParent : null } function hi(e) { for (var t = Qr(e), n = di(e); n && li(n) && "static" === ai(n).position;)n = di(n); return n && ("html" === oi(n) || "body" === oi(n) && "static" === ai(n).position) ? t : n || function (e) { var t = /firefox/i.test(ti()); if (/Trident/i.test(ti()) && Jr(e) && "fixed" === ai(e).position) return null; var n = ui(e); for (Xr(n) && (n = n.host); Jr(n) && ["html", "body"].indexOf(oi(n)) < 0;) { var r = ai(n); if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n; n = n.parentNode } return null }(e) || t } function fi(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function pi(e, t, n) { return Zr(e, $r(t, n)) } function mi(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function gi(e, t) { return t.reduce((function (t, n) { return t[n] = e, t }), {}) } var vi = "top", yi = "bottom", bi = "right", wi = "left", xi = "auto", Ei = [vi, yi, bi, wi], Si = "start", Ni = "end", Ci = "clippingParents", Ti = "viewport", Ai = "popper", ki = "reference", ji = Ei.reduce((function (e, t) { return e.concat([t + "-" + Si, t + "-" + Ni]) }), []), Pi = [].concat(Ei, [xi]).reduce((function (e, t) { return e.concat([t, t + "-" + Si, t + "-" + Ni]) }), []), Ii = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; const Ri = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Gr(n.placement), l = fi(a), c = [wi, bi].indexOf(a) >= 0 ? "height" : "width"; if (s && o) { var u = function (e, t) { return mi("number" !== typeof (e = "function" === typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : gi(e, Ei)) }(i.padding, n), d = ii(s), h = "y" === l ? vi : wi, f = "y" === l ? yi : bi, p = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c], m = o[l] - n.rects.reference[l], g = hi(s), v = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, y = p / 2 - m / 2, b = u[h], w = v - d[c] - u[f], x = v / 2 - d[c] / 2 + y, E = pi(b, x, w), S = l; n.modifiersData[r] = ((t = {})[S] = E, t.centerOffset = E - x, t) } }, effect: function (e) { var t = e.state, n = e.options.element, r = void 0 === n ? "[data-popper-arrow]" : n; null != r && ("string" !== typeof r || (r = t.elements.popper.querySelector(r))) && si(t.elements.popper, r) && (t.elements.arrow = r) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Oi(e) { return e.split("-")[1] } var Di = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function _i(e) { var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, h = o.x, f = void 0 === h ? 0 : h, p = o.y, m = void 0 === p ? 0 : p, g = "function" === typeof u ? u({ x: f, y: m }) : { x: f, y: m }; f = g.x, m = g.y; var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = wi, w = vi, x = window; if (c) { var E = hi(n), S = "clientHeight", N = "clientWidth"; if (E === Qr(n) && "static" !== ai(E = ci(n)).position && "absolute" === a && (S = "scrollHeight", N = "scrollWidth"), i === vi || (i === wi || i === bi) && s === Ni) w = yi, m -= (d && E === x && x.visualViewport ? x.visualViewport.height : E[S]) - r.height, m *= l ? 1 : -1; if (i === wi || (i === vi || i === yi) && s === Ni) b = bi, f -= (d && E === x && x.visualViewport ? x.visualViewport.width : E[N]) - r.width, f *= l ? 1 : -1 } var C, T = Object.assign({ position: a }, c && Di), A = !0 === u ? function (e, t) { var n = e.x, r = e.y, i = t.devicePixelRatio || 1; return { x: ei(n * i) / i || 0, y: ei(r * i) / i || 0 } }({ x: f, y: m }, Qr(n)) : { x: f, y: m }; return f = A.x, m = A.y, l ? Object.assign({}, T, ((C = {})[w] = y ? "0" : "", C[b] = v ? "0" : "", C.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, T, ((t = {})[w] = y ? m + "px" : "", t[b] = v ? f + "px" : "", t.transform = "", t)) } const Mi = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, n = e.options, r = n.gpuAcceleration, i = void 0 === r || r, s = n.adaptive, o = void 0 === s || s, a = n.roundOffsets, l = void 0 === a || a, c = { placement: Gr(t.placement), variation: Oi(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, _i(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, _i(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }; var Li = { passive: !0 }; const Fi = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = void 0 === i || i, o = r.resize, a = void 0 === o || o, l = Qr(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return s && c.forEach((function (e) { e.addEventListener("scroll", n.update, Li) })), a && l.addEventListener("resize", n.update, Li), function () { s && c.forEach((function (e) { e.removeEventListener("scroll", n.update, Li) })), a && l.removeEventListener("resize", n.update, Li) } }, data: {} }; var Ui = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Bi(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return Ui[e] })) } var Vi = { start: "end", end: "start" }; function zi(e) { return e.replace(/start|end/g, (function (e) { return Vi[e] })) } function qi(e) { var t = Qr(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Hi(e) { return ri(ci(e)).left + qi(e).scrollLeft } function Wi(e) { var t = ai(e), n = t.overflow, r = t.overflowX, i = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r) } function Ki(e) { return ["html", "body", "#document"].indexOf(oi(e)) >= 0 ? e.ownerDocument.body : Jr(e) && Wi(e) ? e : Ki(ui(e)) } function Gi(e, t) { var n; void 0 === t && (t = []); var r = Ki(e), i = r === (null == (n = e.ownerDocument) ? void 0 : n.body), s = Qr(r), o = i ? [s].concat(s.visualViewport || [], Wi(r) ? r : []) : r, a = t.concat(o); return i ? a : a.concat(Gi(ui(o))) } function Qi(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Yi(e, t, n) { return t === Ti ? Qi(function (e, t) { var n = Qr(e), r = ci(e), i = n.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, l = 0; if (i) { s = i.width, o = i.height; var c = ni(); (c || !c && "fixed" === t) && (a = i.offsetLeft, l = i.offsetTop) } return { width: s, height: o, x: a + Hi(e), y: l } }(e, n)) : Yr(t) ? function (e, t) { var n = ri(e, !1, "fixed" === t); return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n }(t, n) : Qi(function (e) { var t, n = ci(e), r = qi(e), i = null == (t = e.ownerDocument) ? void 0 : t.body, s = Zr(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Zr(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + Hi(e), l = -r.scrollTop; return "rtl" === ai(i || n).direction && (a += Zr(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l } }(ci(e))) } function Ji(e, t, n, r) { var i = "clippingParents" === t ? function (e) { var t = Gi(ui(e)), n = ["absolute", "fixed"].indexOf(ai(e).position) >= 0 && Jr(e) ? hi(e) : e; return Yr(n) ? t.filter((function (e) { return Yr(e) && si(e, n) && "body" !== oi(e) })) : [] }(e) : [].concat(t), s = [].concat(i, [n]), o = s[0], a = s.reduce((function (t, n) { var i = Yi(e, n, r); return t.top = Zr(i.top, t.top), t.right = $r(i.right, t.right), t.bottom = $r(i.bottom, t.bottom), t.left = Zr(i.left, t.left), t }), Yi(e, o, r)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Xi(e) { var t, n = e.reference, r = e.element, i = e.placement, s = i ? Gr(i) : null, o = i ? Oi(i) : null, a = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2; switch (s) { case vi: t = { x: a, y: n.y - r.height }; break; case yi: t = { x: a, y: n.y + n.height }; break; case bi: t = { x: n.x + n.width, y: l }; break; case wi: t = { x: n.x - r.width, y: l }; break; default: t = { x: n.x, y: n.y } }var c = s ? fi(s) : null; if (null != c) { var u = "y" === c ? "height" : "width"; switch (o) { case Si: t[c] = t[c] - (n[u] / 2 - r[u] / 2); break; case Ni: t[c] = t[c] + (n[u] / 2 - r[u] / 2) } } return t } function Zi(e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = void 0 === r ? e.placement : r, s = n.strategy, o = void 0 === s ? e.strategy : s, a = n.boundary, l = void 0 === a ? Ci : a, c = n.rootBoundary, u = void 0 === c ? Ti : c, d = n.elementContext, h = void 0 === d ? Ai : d, f = n.altBoundary, p = void 0 !== f && f, m = n.padding, g = void 0 === m ? 0 : m, v = mi("number" !== typeof g ? g : gi(g, Ei)), y = h === Ai ? ki : Ai, b = e.rects.popper, w = e.elements[p ? y : h], x = Ji(Yr(w) ? w : w.contextElement || ci(e.elements.popper), l, u, o), E = ri(e.elements.reference), S = Xi({ reference: E, element: b, strategy: "absolute", placement: i }), N = Qi(Object.assign({}, b, S)), C = h === Ai ? N : E, T = { top: x.top - C.top + v.top, bottom: C.bottom - x.bottom + v.bottom, left: x.left - C.left + v.left, right: C.right - x.right + v.right }, A = e.modifiersData.offset; if (h === Ai && A) { var k = A[i]; Object.keys(T).forEach((function (e) { var t = [bi, yi].indexOf(e) >= 0 ? 1 : -1, n = [vi, yi].indexOf(e) >= 0 ? "y" : "x"; T[e] += k[n] * t })) } return T } const $i = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var i = n.mainAxis, s = void 0 === i || i, o = n.altAxis, a = void 0 === o || o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, f = n.flipVariations, p = void 0 === f || f, m = n.allowedAutoPlacements, g = t.options.placement, v = Gr(g), y = l || (v === g || !p ? [Bi(g)] : function (e) { if (Gr(e) === xi) return []; var t = Bi(e); return [zi(e), t, zi(t)] }(g)), b = [g].concat(y).reduce((function (e, n) { return e.concat(Gr(n) === xi ? function (e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = void 0 === l ? Pi : l, u = Oi(r), d = u ? a ? ji : ji.filter((function (e) { return Oi(e) === u })) : Ei, h = d.filter((function (e) { return c.indexOf(e) >= 0 })); 0 === h.length && (h = d); var f = h.reduce((function (t, n) { return t[n] = Zi(e, { placement: n, boundary: i, rootBoundary: s, padding: o })[Gr(n)], t }), {}); return Object.keys(f).sort((function (e, t) { return f[e] - f[t] })) }(t, { placement: n, boundary: u, rootBoundary: d, padding: c, flipVariations: p, allowedAutoPlacements: m }) : n) }), []), w = t.rects.reference, x = t.rects.popper, E = new Map, S = !0, N = b[0], C = 0; C < b.length; C++) { var T = b[C], A = Gr(T), k = Oi(T) === Si, j = [vi, yi].indexOf(A) >= 0, P = j ? "width" : "height", I = Zi(t, { placement: T, boundary: u, rootBoundary: d, altBoundary: h, padding: c }), R = j ? k ? bi : wi : k ? yi : vi; w[P] > x[P] && (R = Bi(R)); var O = Bi(R), D = []; if (s && D.push(I[A] <= 0), a && D.push(I[R] <= 0, I[O] <= 0), D.every((function (e) { return e }))) { N = T, S = !1; break } E.set(T, D) } if (S) for (var _ = function (e) { var t = b.find((function (t) { var n = E.get(t); if (n) return n.slice(0, e).every((function (e) { return e })) })); if (t) return N = t, "break" }, M = p ? 3 : 1; M > 0; M--) { if ("break" === _(M)) break } t.placement !== N && (t.modifiersData[r]._skip = !0, t.placement = N, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function es(e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function ts(e) { return [vi, bi, yi, wi].some((function (t) { return e[t] >= 0 })) } const ns = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.offset, s = void 0 === i ? [0, 0] : i, o = Pi.reduce((function (e, n) { return e[n] = function (e, t, n) { var r = Gr(e), i = [wi, vi].indexOf(r) >= 0 ? -1 : 1, s = "function" === typeof n ? n(Object.assign({}, t, { placement: e })) : n, o = s[0], a = s[1]; return o = o || 0, a = (a || 0) * i, [wi, bi].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a } }(n, t.rects, s), e }), {}), a = o[t.placement], l = a.x, c = a.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = o } }; const rs = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = void 0 === i || i, o = n.altAxis, a = void 0 !== o && o, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, h = n.tether, f = void 0 === h || h, p = n.tetherOffset, m = void 0 === p ? 0 : p, g = Zi(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }), v = Gr(t.placement), y = Oi(t.placement), b = !y, w = fi(v), x = "x" === w ? "y" : "x", E = t.modifiersData.popperOffsets, S = t.rects.reference, N = t.rects.popper, C = "function" === typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, T = "number" === typeof C ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C), A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, k = { x: 0, y: 0 }; if (E) { if (s) { var j, P = "y" === w ? vi : wi, I = "y" === w ? yi : bi, R = "y" === w ? "height" : "width", O = E[w], D = O + g[P], _ = O - g[I], M = f ? -N[R] / 2 : 0, L = y === Si ? S[R] : N[R], F = y === Si ? -N[R] : -S[R], U = t.elements.arrow, B = f && U ? ii(U) : { width: 0, height: 0 }, V = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, z = V[P], q = V[I], H = pi(0, S[R], B[R]), W = b ? S[R] / 2 - M - H - z - T.mainAxis : L - H - z - T.mainAxis, K = b ? -S[R] / 2 + M + H + q + T.mainAxis : F + H + q + T.mainAxis, G = t.elements.arrow && hi(t.elements.arrow), Q = G ? "y" === w ? G.clientTop || 0 : G.clientLeft || 0 : 0, Y = null != (j = null == A ? void 0 : A[w]) ? j : 0, J = O + K - Y, X = pi(f ? $r(D, O + W - Y - Q) : D, O, f ? Zr(_, J) : _); E[w] = X, k[w] = X - O } if (a) { var Z, $ = "x" === w ? vi : wi, ee = "x" === w ? yi : bi, te = E[x], ne = "y" === x ? "height" : "width", re = te + g[$], ie = te - g[ee], se = -1 !== [vi, wi].indexOf(v), oe = null != (Z = null == A ? void 0 : A[x]) ? Z : 0, ae = se ? re : te - S[ne] - N[ne] - oe + T.altAxis, le = se ? te + S[ne] + N[ne] - oe - T.altAxis : ie, ce = f && se ? function (e, t, n) { var r = pi(e, t, n); return r > n ? n : r }(ae, te, le) : pi(f ? ae : re, te, f ? le : ie); E[x] = ce, k[x] = ce - te } t.modifiersData[r] = k } }, requiresIfExists: ["offset"] }; function is(e, t, n) { void 0 === n && (n = !1); var r = Jr(t), i = Jr(t) && function (e) { var t = e.getBoundingClientRect(), n = ei(t.width) / e.offsetWidth || 1, r = ei(t.height) / e.offsetHeight || 1; return 1 !== n || 1 !== r }(t), s = ci(t), o = ri(e, i, n), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (r || !r && !n) && (("body" !== oi(t) || Wi(s)) && (a = function (e) { return e !== Qr(e) && Jr(e) ? { scrollLeft: (t = e).scrollLeft, scrollTop: t.scrollTop } : qi(e); var t }(t)), Jr(t) ? ((l = ri(t, !0)).x += t.clientLeft, l.y += t.clientTop) : s && (l.x = Hi(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height } } function ss(e) { var t = new Map, n = new Set, r = []; function i(e) { n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { if (!n.has(e)) { var r = t.get(e); r && i(r) } })), r.push(e) } return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { n.has(e.name) || i(e) })), r } function os(e) { var t; return function () { return t || (t = new Promise((function (n) { Promise.resolve().then((function () { t = void 0, n(e()) })) }))), t } } var as = { placement: "bottom", modifiers: [], strategy: "absolute" }; function ls() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some((function (e) { return !(e && "function" === typeof e.getBoundingClientRect) })) } function cs(e) { void 0 === e && (e = {}); var t = e, n = t.defaultModifiers, r = void 0 === n ? [] : n, i = t.defaultOptions, s = void 0 === i ? as : i; return function (e, t, n) { void 0 === n && (n = s); var i = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, as, s), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, o = [], a = !1, l = { state: i, setOptions: function (n) { var a = "function" === typeof n ? n(i.options) : n; c(), i.options = Object.assign({}, s, i.options, a), i.scrollParents = { reference: Yr(e) ? Gi(e) : e.contextElement ? Gi(e.contextElement) : [], popper: Gi(t) }; var u = function (e) { var t = ss(e); return Ii.reduce((function (e, n) { return e.concat(t.filter((function (e) { return e.phase === n }))) }), []) }(function (e) { var t = e.reduce((function (e, t) { var n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }), {}); return Object.keys(t).map((function (e) { return t[e] })) }([].concat(r, i.options.modifiers))); return i.orderedModifiers = u.filter((function (e) { return e.enabled })), i.orderedModifiers.forEach((function (e) { var t = e.name, n = e.options, r = void 0 === n ? {} : n, s = e.effect; if ("function" === typeof s) { var a = s({ state: i, name: t, instance: l, options: r }), c = function () { }; o.push(a || c) } })), l.update() }, forceUpdate: function () { if (!a) { var e = i.elements, t = e.reference, n = e.popper; if (ls(t, n)) { i.rects = { reference: is(t, hi(n), "fixed" === i.options.strategy), popper: ii(n) }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function (e) { return i.modifiersData[e.name] = Object.assign({}, e.data) })); for (var r = 0; r < i.orderedModifiers.length; r++)if (!0 !== i.reset) { var s = i.orderedModifiers[r], o = s.fn, c = s.options, u = void 0 === c ? {} : c, d = s.name; "function" === typeof o && (i = o({ state: i, options: u, name: d, instance: l }) || i) } else i.reset = !1, r = -1 } } }, update: os((function () { return new Promise((function (e) { l.forceUpdate(), e(i) })) })), destroy: function () { c(), a = !0 } }; if (!ls(e, t)) return l; function c() { o.forEach((function (e) { return e() })), o = [] } return l.setOptions(n).then((function (e) { !a && n.onFirstUpdate && n.onFirstUpdate(e) })), l } } const us = cs({ defaultModifiers: [{ name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, o = Zi(t, { elementContext: "reference" }), a = Zi(t, { altBoundary: !0 }), l = es(o, r), c = es(a, i, s), u = ts(l), d = ts(c); t.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } }, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, n = e.name; t.modifiersData[n] = Xi({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, Mi, Fi, ns, $i, rs, Ri] }), ds = ["enabled", "placement", "strategy", "modifiers"]; const hs = { name: "applyStyles", enabled: !1, phase: "afterWrite", fn: () => { } }, fs = { name: "ariaDescribedBy", enabled: !0, phase: "afterWrite", effect: e => { let { state: t } = e; return () => { const { reference: e, popper: n } = t.elements; if ("removeAttribute" in e) { const t = (e.getAttribute("aria-describedby") || "").split(",").filter((e => e.trim() !== n.id)); t.length ? e.setAttribute("aria-describedby", t.join(",")) : e.removeAttribute("aria-describedby") } } }, fn: e => { let { state: t } = e; var n; const { popper: r, reference: i } = t.elements, s = null == (n = r.getAttribute("role")) ? void 0 : n.toLowerCase(); if (r.id && "tooltip" === s && "setAttribute" in i) { const e = i.getAttribute("aria-describedby"); if (e && -1 !== e.split(",").indexOf(r.id)) return; i.setAttribute("aria-describedby", e ? "".concat(e, ",").concat(r.id) : r.id) } } }, ps = []; const ms = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, { enabled: i = !0, placement: s = "bottom", strategy: o = "absolute", modifiers: a = ps } = n, l = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(n, ds); const c = (0, r.useRef)(a), u = (0, r.useRef)(), d = (0, r.useCallback)((() => { var e; null == (e = u.current) || e.update() }), []), h = (0, r.useCallback)((() => { var e; null == (e = u.current) || e.forceUpdate() }), []), [f, p] = Kr((0, r.useState)({ placement: s, update: d, forceUpdate: h, attributes: {}, styles: { popper: {}, arrow: {} } })), m = (0, r.useMemo)((() => ({ name: "updateStateModifier", enabled: !0, phase: "write", requires: ["computeStyles"], fn: e => { let { state: t } = e; const n = {}, r = {}; Object.keys(t.elements).forEach((e => { n[e] = t.styles[e], r[e] = t.attributes[e] })), p({ state: t, styles: n, attributes: r, update: d, forceUpdate: h, placement: t.placement }) } })), [d, h, p]), g = (0, r.useMemo)((() => (Wr(c.current, a) || (c.current = a), c.current)), [a]); return (0, r.useEffect)((() => { u.current && i && u.current.setOptions({ placement: s, strategy: o, modifiers: [...g, m, hs] }) }), [o, s, m, i, g]), (0, r.useEffect)((() => { if (i && null != e && null != t) return u.current = us(e, t, Object.assign({}, l, { placement: s, strategy: o, modifiers: [...g, fs, m] })), () => { null != u.current && (u.current.destroy(), u.current = void 0, p((e => Object.assign({}, e, { attributes: {}, styles: { popper: {} } })))) } }), [i, e, t]), f }; var gs = n(440), vs = n.n(gs); const ys = () => { }; const bs = e => e && ("current" in e ? e.current : e), ws = { click: "mousedown", mouseup: "mousedown", pointerup: "pointerdown" }; const xs = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ys, { disabled: n, clickTrigger: i = "click" } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const s = (0, r.useRef)(!1), o = (0, r.useRef)(!1), a = (0, r.useCallback)((t => { const n = bs(e); var r; vs()(!!n, "ClickOutside captured a close event but does not have a ref to compare it to. useClickOutside(), should be passed a ref that resolves to a DOM node"), s.current = !n || !!((r = t).metaKey || r.altKey || r.ctrlKey || r.shiftKey) || !function (e) { return 0 === e.button }(t) || !!$t(n, t.target) || o.current, o.current = !1 }), [e]), l = zt((t => { const n = bs(e); n && $t(n, t.target) && (o.current = !0) })), c = zt((e => { s.current || t(e) })); (0, r.useEffect)((() => { var t, r; if (n || null == e) return; const s = Je(bs(e)), o = s.defaultView || window; let u = null != (t = o.event) ? t : null == (r = o.parent) ? void 0 : r.event, d = null; ws[i] && (d = xt(s, ws[i], l, !0)); const h = xt(s, i, a, !0), f = xt(s, i, (e => { e !== u ? c(e) : u = void 0 })); let p = []; return "ontouchstart" in s.documentElement && (p = [].slice.call(s.body.children).map((e => xt(e, "mousemove", ys)))), () => { null == d || d(), h(), f(), p.forEach((e => e())) } }), [e, n, i, a, l, c]) }; function Es() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return Array.isArray(e) ? e : Object.keys(e).map((t => (e[t].name = t, e[t]))) } function Ss(e) { let { enabled: t, enableEvents: n, placement: r, flip: i, offset: s, fixed: o, containerPadding: a, arrowElement: l, popperConfig: c = {} } = e; var u, d, h, f, p; const m = function (e) { const t = {}; return Array.isArray(e) ? (null == e || e.forEach((e => { t[e.name] = e })), t) : e || t }(c.modifiers); return Object.assign({}, c, { placement: r, enabled: t, strategy: o ? "fixed" : c.strategy, modifiers: Es(Object.assign({}, m, { eventListeners: { enabled: n, options: null == (u = m.eventListeners) ? void 0 : u.options }, preventOverflow: Object.assign({}, m.preventOverflow, { options: a ? Object.assign({ padding: a }, null == (d = m.preventOverflow) ? void 0 : d.options) : null == (h = m.preventOverflow) ? void 0 : h.options }), offset: { options: Object.assign({ offset: s }, null == (f = m.offset) ? void 0 : f.options) }, arrow: Object.assign({}, m.arrow, { enabled: !!l, options: Object.assign({}, null == (p = m.arrow) ? void 0 : p.options, { element: l }) }), flip: Object.assign({ enabled: !!i }, m.flip) })) }) } const Ns = ["children"]; const Cs = () => { }; function Ts() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = (0, r.useContext)(zr), [n, i] = (0, r.useState)(null), s = (0, r.useRef)(!1), { flip: o, offset: a, rootCloseEvent: l, fixed: c = !1, placement: u, popperConfig: d = {}, enableEventListeners: h = !0, usePopper: f = !!t } = e, p = null == (null == t ? void 0 : t.show) ? !!e.show : t.show; p && !s.current && (s.current = !0); const { placement: m, setMenu: g, menuElement: v, toggleElement: y } = t || {}, b = ms(y, v, Ss({ placement: u || m || "bottom-start", enabled: f, enableEvents: null == h ? p : h, offset: a, flip: o, fixed: c, arrowElement: n, popperConfig: d })), w = Object.assign({ ref: g || Cs, "aria-labelledby": null == y ? void 0 : y.id }, b.attributes.popper, { style: b.styles.popper }), x = { show: p, placement: m, hasShown: s.current, toggle: null == t ? void 0 : t.toggle, popper: f ? b : null, arrowProps: f ? Object.assign({ ref: i }, b.attributes.arrow, { style: b.styles.arrow }) : {} }; return xs(v, (e => { null == t || t.toggle(!1, e) }), { clickTrigger: l, disabled: !p }), [w, x] } function As(e) { let { children: t } = e, n = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, Ns); const [r, i] = Ts(n); return (0, Ve.jsx)(Ve.Fragment, { children: t(r, i) }) } As.displayName = "DropdownMenu", As.defaultProps = { usePopper: !0 }; const ks = As, js = { prefix: String(Math.round(1e10 * Math.random())), current: 0 }, Ps = r.createContext(js), Is = r.createContext(!1); let Rs = Boolean("undefined" !== typeof window && window.document && window.document.createElement), Os = new WeakMap; function Ds() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t = (0, r.useContext)(Ps), n = (0, r.useRef)(null); if (null === n.current && !e) { var i, s; let e = null === (s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) || void 0 === s || null === (i = s.ReactCurrentOwner) || void 0 === i ? void 0 : i.current; if (e) { let n = Os.get(e); null == n ? Os.set(e, { id: t.current, state: e.memoizedState }) : e.memoizedState !== n.state && (t.current = n.id, Os.delete(e)) } n.current = ++t.current } return n.current } const _s = "function" === typeof r.useId ? function (e) { let t = r.useId(), [n] = (0, r.useState)("function" === typeof r.useSyncExternalStore ? r.useSyncExternalStore(Fs, Ms, Ls) : (0, r.useContext)(Is)), i = n ? "react-aria" : "react-aria".concat(js.prefix); return e || "".concat(i, "-").concat(t) } : function (e) { let t = (0, r.useContext)(Ps); t !== js || Rs || console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server."); let n = Ds(!!e), i = "react-aria".concat(t.prefix); return e || "".concat(i, "-").concat(n) }; function Ms() { return !1 } function Ls() { return !0 } function Fs(e) { return () => { } } const Us = e => { var t; return "menu" === (null == (t = e.getAttribute("role")) ? void 0 : t.toLowerCase()) }, Bs = () => { }; function Vs() { const e = _s(), { show: t = !1, toggle: n = Bs, setToggle: i, menuElement: s } = (0, r.useContext)(zr) || {}, o = (0, r.useCallback)((e => { n(!t, e) }), [t, n]), a = { id: e, ref: i || Bs, onClick: o, "aria-expanded": !!t }; return s && Us(s) && (a["aria-haspopup"] = !0), [a, { show: t, toggle: n }] } function zs(e) { let { children: t } = e; const [n, r] = Vs(); return (0, Ve.jsx)(Ve.Fragment, { children: t(n, r) }) } zs.displayName = "DropdownToggle"; const qs = zs, Hs = ["eventKey", "disabled", "onClick", "active", "as"]; function Ws(e) { let { key: t, href: n, active: i, disabled: s, onClick: o } = e; const a = (0, r.useContext)(Re), l = (0, r.useContext)(mr), { activeKey: c } = l || {}, u = Ie(t, n), d = null == i && null != t ? Ie(c) === u : i; return [{ onClick: zt((e => { s || (null == o || o(e), a && !e.isPropagationStopped() && a(u, e)) })), "aria-disabled": s || void 0, "aria-selected": d, [sn("dropdown-item")]: "" }, { isActive: d }] } const Ks = r.forwardRef(((e, t) => { let { eventKey: n, disabled: r, onClick: i, active: s, as: o = wr } = e, a = function (e, t) { if (null == e) return {}; var n, r, i = {}, s = Object.keys(e); for (r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, Hs); const [l] = Ws({ key: n, href: a.href, disabled: r, onClick: i, active: s }); return (0, Ve.jsx)(o, Object.assign({}, a, { ref: t }, l)) })); Ks.displayName = "DropdownItem"; const Gs = Ks; function Qs() { const e = fr(), t = (0, r.useRef)(null), n = (0, r.useCallback)((n => { t.current = n, e() }), [e]); return [t, n] } function Ys(e) { let { defaultShow: t, show: n, onSelect: i, onToggle: s, itemSelector: o = "* [".concat(sn("dropdown-item"), "]"), focusFirstItemOnShow: a, placement: l = "bottom-start", children: c } = e; const u = cn(), [d, h] = Vr(n, t, s), [f, p] = Qs(), m = f.current, [g, v] = Qs(), y = g.current, b = nn(d), w = (0, r.useRef)(null), x = (0, r.useRef)(!1), E = (0, r.useContext)(Re), S = (0, r.useCallback)((function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null == t ? void 0 : t.type; h(e, { originalEvent: t, source: n }) }), [h]), N = zt(((e, t) => { null == i || i(e, t), S(!1, t, "select"), t.isPropagationStopped() || null == E || E(e, t) })), C = (0, r.useMemo)((() => ({ toggle: S, placement: l, show: d, menuElement: m, toggleElement: y, setMenu: p, setToggle: v })), [S, l, d, m, y, p, v]); m && b && !d && (x.current = m.contains(m.ownerDocument.activeElement)); const T = zt((() => { y && y.focus && y.focus() })), A = zt((() => { const e = w.current; let t = a; if (null == t && (t = !(!f.current || !Us(f.current)) && "keyboard"), !1 === t || "keyboard" === t && !/^key.+$/.test(e)) return; const n = Gn(f.current, o)[0]; n && n.focus && n.focus() })); (0, r.useEffect)((() => { d ? A() : x.current && (x.current = !1, T()) }), [d, x, T, A]), (0, r.useEffect)((() => { w.current = null })); const k = (e, t) => { if (!f.current) return null; const n = Gn(f.current, o); let r = n.indexOf(e) + t; return r = Math.max(0, Math.min(r, n.length)), n[r] }; return function (e, t, n) { let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const s = zt(n); (0, r.useEffect)((() => { const n = "function" === typeof e ? e() : e; return n.addEventListener(t, s, i), () => n.removeEventListener(t, s, i) }), [e]) }((0, r.useCallback)((() => u.document), [u]), "keydown", (e => { var t, n; const { key: r } = e, i = e.target, s = null == (t = f.current) ? void 0 : t.contains(i), o = null == (n = g.current) ? void 0 : n.contains(i); if (/input|textarea/i.test(i.tagName) && (" " === r || "Escape" !== r && s || "Escape" === r && "search" === i.type)) return; if (!s && !o) return; if ("Tab" === r && (!f.current || !d)) return; w.current = e.type; const a = { originalEvent: e, source: e.type }; switch (r) { case "ArrowUp": { const t = k(i, -1); return t && t.focus && t.focus(), void e.preventDefault() } case "ArrowDown": if (e.preventDefault(), d) { const e = k(i, 1); e && e.focus && e.focus() } else h(!0, a); return; case "Tab": bt(i.ownerDocument, "keyup", (e => { var t; ("Tab" !== e.key || e.target) && null != (t = f.current) && t.contains(e.target) || h(!1, a) }), { once: !0 }); break; case "Escape": "Escape" === r && (e.preventDefault(), e.stopPropagation()), h(!1, a) } })), (0, Ve.jsx)(Re.Provider, { value: N, children: (0, Ve.jsx)(zr.Provider, { value: C, children: c }) }) } Ys.displayName = "Dropdown", Ys.Menu = ks, Ys.Toggle = qs, Ys.Item = Gs; const Js = Ys, Xs = r.createContext({}); Xs.displayName = "DropdownContext"; const Zs = Xs, $s = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "hr", role: s = "separator", ...o } = e; return r = Ge(r, "dropdown-divider"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), role: s, ...o }) })); $s.displayName = "DropdownDivider"; const eo = $s, to = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", role: s = "heading", ...o } = e; return r = Ge(r, "dropdown-header"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), role: s, ...o }) })); to.displayName = "DropdownHeader"; const no = to, ro = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, eventKey: i, disabled: s = !1, onClick: o, active: a, as: l = Mr, ...c } = e; const u = Ge(n, "dropdown-item"), [d, h] = Ws({ key: i, href: c.href, disabled: s, onClick: o, active: a }); return (0, Ve.jsx)(l, { ...c, ...d, ref: t, className: Pe()(r, u, h.isActive && "active", s && "disabled") }) })); ro.displayName = "DropdownItem"; const io = ro, so = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "span", ...s } = e; return r = Ge(r, "dropdown-item-text"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); so.displayName = "DropdownItemText"; const oo = so, ao = r.createContext(null); ao.displayName = "InputGroupContext"; const lo = ao; function co(e, t) { return e } function uo(e, t, n) { let r = e ? n ? "bottom-start" : "bottom-end" : n ? "bottom-end" : "bottom-start"; return "up" === t ? r = e ? n ? "top-start" : "top-end" : n ? "top-end" : "top-start" : "end" === t ? r = e ? n ? "left-end" : "right-end" : n ? "left-start" : "right-start" : "start" === t ? r = e ? n ? "right-end" : "left-end" : n ? "right-start" : "left-start" : "down-centered" === t ? r = "bottom" : "up-centered" === t && (r = "top"), r } const ho = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, align: s, rootCloseEvent: o, flip: a = !0, show: l, renderOnMount: c, as: u = "div", popperConfig: d, variant: h, ...f } = e, p = !1; const m = (0, r.useContext)(Ft), g = Ge(n, "dropdown-menu"), { align: v, drop: y, isRTL: b } = (0, r.useContext)(Zs); s = s || v; const w = (0, r.useContext)(lo), x = []; if (s) if ("object" === typeof s) { const e = Object.keys(s); if (e.length) { const t = e[0], n = s[t]; p = "start" === n, x.push("".concat(g, "-").concat(t, "-").concat(n)) } } else "end" === s && (p = !0); const E = uo(p, y, b), [S, { hasShown: N, popper: C, show: T, toggle: A }] = Ts({ flip: a, rootCloseEvent: o, show: l, usePopper: !m && 0 === x.length, offset: [0, 2], popperConfig: d, placement: E }); if (S.ref = jt(co(t), S.ref), Kt((() => { T && (null == C || C.update()) }), [T]), !N && !c && !w) return null; "string" !== typeof u && (S.show = T, S.close = () => null == A ? void 0 : A(!1), S.align = s); let k = f.style; return null != C && C.placement && (k = { ...f.style, ...S.style }, f["x-placement"] = C.placement), (0, Ve.jsx)(u, { ...f, ...S, style: k, ...(x.length || m) && { "data-bs-popper": "static" }, className: Pe()(i, g, T && "show", p && "".concat(g, "-end"), h && "".concat(g, "-").concat(h), ...x) }) })); ho.displayName = "DropdownMenu"; const fo = ho, po = r.forwardRef(((e, t) => { let { as: n, bsPrefix: r, variant: i = "primary", size: s, active: o = !1, disabled: a = !1, className: l, ...c } = e; const u = Ge(r, "btn"), [d, { tagName: h }] = yr({ tagName: n, disabled: a, ...c }), f = h; return (0, Ve.jsx)(f, { ...d, ...c, ref: t, disabled: a, className: Pe()(l, u, o && "active", i && "".concat(u, "-").concat(i), s && "".concat(u, "-").concat(s), c.href && a && "disabled") }) })); po.displayName = "Button"; const mo = po, go = r.forwardRef(((e, t) => { let { bsPrefix: n, split: i, className: s, childBsPrefix: o, as: a = mo, ...l } = e; const c = Ge(n, "dropdown-toggle"), u = (0, r.useContext)(zr); void 0 !== o && (l.bsPrefix = o); const [d] = Vs(); return d.ref = jt(d.ref, co(t)), (0, Ve.jsx)(a, { className: Pe()(s, c, i && "".concat(c, "-split"), (null == u ? void 0 : u.show) && "show"), ...d, ...l }) })); go.displayName = "DropdownToggle"; const vo = go, yo = r.forwardRef(((e, t) => { const { bsPrefix: n, drop: i = "down", show: s, className: o, align: a = "start", onSelect: l, onToggle: c, focusFirstItemOnShow: u, as: d = "div", navbar: h, autoClose: f = !0, ...p } = Le(e, { show: "onToggle" }), m = (0, r.useContext)(lo), g = Ge(n, "dropdown"), v = function () { const { dir: e } = (0, r.useContext)(He); return "rtl" === e }(), y = zt(((e, t) => { var n, r; var i; (null == (n = t.originalEvent) || null == (r = n.target) ? void 0 : r.classList.contains("dropdown-toggle")) && "mousedown" === t.source || (t.originalEvent.currentTarget !== document || "keydown" === t.source && "Escape" !== t.originalEvent.key || (t.source = "rootClose"), i = t.source, (!1 === f ? "click" === i : "inside" === f ? "rootClose" !== i : "outside" !== f || "select" !== i) && (null == c || c(e, t))) })), b = uo("end" === a, i, v), w = (0, r.useMemo)((() => ({ align: a, drop: i, isRTL: v })), [a, i, v]), x = { down: g, "down-centered": "".concat(g, "-center"), up: "dropup", "up-centered": "dropup-center dropup", end: "dropend", start: "dropstart" }; return (0, Ve.jsx)(Zs.Provider, { value: w, children: (0, Ve.jsx)(Js, { placement: b, show: s, onSelect: l, onToggle: y, focusFirstItemOnShow: u, itemSelector: ".".concat(g, "-item:not(.disabled):not(:disabled)"), children: m ? p.children : (0, Ve.jsx)(d, { ...p, ref: t, className: Pe()(o, s && "show", x[i]) }) }) }) })); yo.displayName = "Dropdown"; const bo = Object.assign(yo, { Toggle: vo, Menu: fo, Item: io, ItemText: oo, Divider: eo, Header: no }), wo = r.forwardRef(((e, t) => { let { id: n, title: r, children: i, bsPrefix: s, className: o, rootCloseEvent: a, menuRole: l, disabled: c, active: u, renderMenuOnMount: d, menuVariant: h, ...f } = e; const p = Ge(void 0, "nav-item"); return (0, Ve.jsxs)(bo, { ref: t, ...f, className: Pe()(o, p), children: [(0, Ve.jsx)(bo.Toggle, { id: n, eventKey: null, active: u, disabled: c, childBsPrefix: s, as: Fr, children: r }), (0, Ve.jsx)(bo.Menu, { role: l, renderOnMount: d, rootCloseEvent: a, variant: h, children: i })] }) })); wo.displayName = "NavDropdown"; const xo = Object.assign(wo, { Item: bo.Item, ItemText: bo.ItemText, Divider: bo.Divider, Header: bo.Header }), Eo = n.p + "static/media/afot logo2.0f8259dc801e95ae3e73.png", So = () => { const { darkTheme: e, toggleTheme: t } = (0, r.useContext)(nI), [n, i] = (0, r.useState)(!1); return (0, Ve.jsx)("body", { children: (0, Ve.jsxs)(ur, { className: "navbar", expand: "md", children: [(0, Ve.jsxs)(hr, { fluid: !0, className: "c", children: [(0, Ve.jsx)(Br.Link, { as: Ce, to: "/", children: (0, Ve.jsx)("img", { className: "afortlogo", src: Eo, alt: "" }) }), (0, Ve.jsxs)(ur.Brand, { children: [" ", (0, Ve.jsx)(Br.Link, { as: Ce, to: "/", children: (0, Ve.jsx)("img", { className: "pic4", src: ke, alt: "" }) })] }), (0, Ve.jsx)(ur.Toggle, { className: "pic8", "aria-controls": "navbar-brand", children: (0, Ve.jsx)("img", { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAQAAAAngNWGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB+gEBAYJNlbUULoAAABVSURBVCjPY2CgNmBEYgsxCOFQ9Z/hEyOSskkM1gz/cCh9xER1q6nuaQZGBlEGPhQH4PT1fgY5IgwkxddEWk0LX2MCzIBHiWuEMmxxTl5c47Wa+r4GAF/lE8uniCb8AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDI0LTA0LTA0VDA2OjA5OjM3KzAwOjAwerx57QAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyNC0wNC0wNFQwNjowOTozNyswMDowMAvhwVEAAAAodEVYdGRhdGU6dGltZXN0YW1wADIwMjQtMDQtMDRUMDY6MDk6NTQrMDA6MDCrc/OUAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==", alt: "" }) }), (0, Ve.jsx)(ur.Collapse, { id: "navbar-brand", children: (0, Ve.jsxs)(Br, { className: "  ms-auto  my-lg-6 mx-5 navi fs-4 ", style: { maxHeight: "1000px", px: "5" }, navbar: !0, children: [(0, Ve.jsx)(Br.Link, { className: "link4", as: Ce, to: "/about", children: "About" }), (0, Ve.jsx)(Br.Link, { className: "link4", as: Ce, to: "/contact", children: "Contact" }), (0, Ve.jsxs)(xo, { className: "link4 ", title: "Freelance", show: n, onMouseLeave: e => { i(!1) }, onMouseEnter: e => { i(!n) }, children: [(0, Ve.jsx)(xo.Item, { className: "link1 ", as: Ce, to: "/sell", children: "Sell Your Project" }), (0, Ve.jsx)(xo.Item, { className: "link1", as: Ce, to: "/buy", children: "Buy Another Project" })] }), (0, Ve.jsx)(Br.Link, { className: "link4", as: Ce, to: "/products", children: "Products " })] }) })] }), (0, Ve.jsxs)("div", { className: "position-relative", children: [" ", (0, Ve.jsx)("nav", { className: "bbd position-absolute top-0 end-0", onClick: t, children: (0, Ve.jsx)("img", { src: e ? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABAJJREFUaIHtmE1v3FQUhp87U2k8diZVvkihJZEQ7BCpkOAPEEUtsE6XEEVI/QPlY0MkNqT9CbAAtukGFmmIVH4DAbGpAKlpQQlk4gjG59pDGR8WY4dhNB/xfHRAzCtd2b46Pu95bd9z7rFRVf7LyI06gH4xFjBqjAWMGmMBnRAEwVwQBHPD5BiaAN/3J3O53L1cLnevXC6XhsUzNAGe5z0BTAFTpVJpflg84zUwamQWEIbhNWvtjogsdbJT1UcN5390shWRJWvtThiGq1njOZf1BlV9E7hijHlJRJY9z9trZec4zr61dgNQx3EetPMnIpeNMXeBGa3vLLeyxGOy7kZFZMkY8xUwAxyralsRZ/B1Gnzi6xXP877J4iOzgBbEh67rXgTijG7y1tqfgXn6eBCZPyEAz/P2RGTZGLMDHAKnT+Hk5OR8oVC4BqwATyfTD4HdarW6NTU19VsyFwMHgKrq1V7fYk9voAHngBqJAGvtOnCT+ptphbKqvu153icpP5AH/uw1gH4FnCIMw1uqeiO5FFXdNsZ8B6CqzxtjXgdcAGPMzWKx+O5AiFW17yEi6yKiyfg8CIL5FjZPisgXqV0QBGuD4O7bge/750WknAavqrkO9rkGEUfHx8eT/fL3XYmTBTtD/bO5TudsFAPXAQvMOo6TuXA1o6sA3/cnq9XqM+mIomihyWQFQFW3Pc877ObPdd0D4E7jvSmiKFpo5PJ9f7IvAUEQzDmOc79Wq/2YjjiO96217zeYLQCkC/aM+DY5LqYT1tqNOI73G7kcx7lfqVRmexbQAdrm/KwwXXye2XfHQjYxMXFULpcXS6XSaVcVx/GjYrH4sMHsAfAy0HFz14TLyXE/nXBd94Moij41xpzGVKlUjmZnZysdPQ0ghb6VZBURkae62VtrL4mITe5ZH3kWqlarW0CZepH6iHplbYe8qn4MFIGjKIpu98s/kEIWBMFaQyHbbvUmrLUXReROQyF7YxDcg9xKbKrqO+kl9VSZZpsXgNcAB8AYs1ksFt8bBG+/AvLUN3MAiMiaMeYW0C71HanqDc/zPmvnIyt6FpD0BF8CB67rvkiS8nzfn0wq7ApJjaCeqXajKLo9PT39e8ptrf0auKCqVx7rdrqpoTlwXfcSvTU0PwEX6KOhyZyFkpaysQ18lezBA9RU9SpwDMwYY+52+1HQCpkFGGM2OWM/bK3daNp2/AOe5+2p6jJ/i/gwazyZ05a1dlVEdoMgWOpkF4bhYpoywzBc6JKGl0Rk11q7OrI02oxqtfpsrVb7HiCfzz9XKBR+GAbP/+/P3L8NQxMgIr8CJ4BfqVR+GRbP0NYA1BsiVdVSqVQeFsdQBTwOjNfAqDEWMGqMBYwafwFHWptp6Ki24QAAAABJRU5ErkJggg==" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAkBJREFUWIXt10+IzVEUB/DPRcpsRDKR5D+jEClZaGo2YsrCxkLJgqRsbWxIkQ1ZWViQjVhNUsKwYpSwkKKU/IlSpsZCUTzH4ndf87x+b9573rxm49bt9Lvnnnu+nXPu99xfighTOaZNqff/ADCjXYOU0noMYCO+40hE/PpnBBHR0sRuPEbUzN9Y1OoZpee24Hg+btY5rs6TnThvCgBL8Do7+4nzeJG/byF1DQDm4E129gmbsTJ/V9DXqfNmAG5kZx+xNK8dzWsPJsN5RJRfw5TSduzKYd8TEW+zakOW9/6l4MtGIx44nuWliBipWV+Q5ceuAUgpLcVWxRU7Xaeu3veZXQOAwSyfRsSHOt37LJd3E0BfliMluidZ7uwmgIVZfirRDSnS0JdS6u8WgEqW0+sVETGKq/nzXEqp41ooA1DN8+IGNsfwDZtwMaWUOkJQQkAHFWTzvEljquR9Q5g9aUyIXkWewwR0i0MKogp8UbDk4pJ9KxTX+RUOt0TFGM4HX2vSrPrxzt8d8i0e4aEinbW6K60C2KIgot/Y3gTETBzBs7y/rG1Xu+madprR5Wz4FetaymdB1QPYi304WwPqVLvdsMf4C2gMg20VFwcUT7bAXcxoC0BNQT4z/ga4jrUT7E/YpuiW1dDfRk8jm5QNG46U0ixcwP6a5Ze4j88YxVysykW5LO/5hTM4EREVjUYbId2COyYutMAPBVuubuXcphEoiUgvdiie5fPy/IoPimY1HBFjLZ/XLoDJHlP+Z/QfwB932N1QUrJRcAAAAABJRU5ErkJggg==", alt: "" }) }), " "] })] }) }) }; const No = function () { return (0, Ve.jsx)("div", { className: "error-message", style: { display: "flex", justifyContent: "center", alignItems: "center", height: "80vh", fontSize: "30px", fontWeight: "bolder" }, children: "404-error!....... " }) }, Co = e => { let { projects: t } = e; return (0, Ve.jsx)("div", { children: (0, Ve.jsxs)("div", { className: "product-list", children: [(0, Ve.jsx)("h2", { children: "Products" }), t.length > 0 ? t.map(((e, t) => (0, Ve.jsxs)("div", { className: "product-item", children: [(0, Ve.jsx)("img", { src: e.image, alt: e.name }), (0, Ve.jsxs)("div", { children: [(0, Ve.jsx)("h3", { children: e.name }), (0, Ve.jsxs)("p", { children: ["Price: $", e.price] }), (0, Ve.jsx)("p", { children: e.description })] })] }, t))) : (0, Ve.jsx)("p", { children: "No products available" })] }) }) }, To = n.p + "static/media/hour 24.7d47932d8517c5207209.png", Ao = n.p + "static/media/communication.7903a2d7e54b4756d735.png", ko = n.p + "static/media/message.ae7cf1cde37b810c12b3.png", jo = n.p + "static/media/location.87e13a7bb1bb254a20cc.png"; function Po(e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)("A108 Adam Street Newyork, NY536487"), [s, o] = (0, r.useState)(["+5674 89788", "+5674 89788"]), [a, l] = (0, r.useState)(["info@example.com", "contact@example.com"]), [c, u] = (0, r.useState)(["Monday-friday 9:00AM-5:00pm"]), [d, h] = (0, r.useState)({ name: "", email: "", subject: "", message: "" }), [f, p] = (0, r.useState)(!1); (0, r.useEffect)((() => { f && setTimeout((() => { t(!0) }), 500) }), [f, t]); const m = e => { const { name: t, value: n } = e.target; h((e => ({ ...e, [t]: n }))) }; return (0, Ve.jsx)("div", { className: "main-div", children: (0, Ve.jsx)("div", { className: " container body-content", children: (0, Ve.jsxs)("div", { className: " row content-mainbox", children: [(0, Ve.jsxs)("div", { className: " col-lg-6 col-md-6 content-firstbox", children: [(0, Ve.jsxs)("div", { className: " row content-firstflex", children: [(0, Ve.jsxs)("div", { className: " col-lg-5 col-5 col-sm-5 col-md-5 content-address", children: [(0, Ve.jsx)("img", { src: jo, alt: "" }), (0, Ve.jsx)("h3", { children: "Address" }), (0, Ve.jsx)("p", { children: n })] }), (0, Ve.jsxs)("div", { className: " col-lg-5 col-5   col-md-5 content-callus", children: [(0, Ve.jsx)("img", { src: Ao, alt: "" }), (0, Ve.jsx)("h3", { children: "Call Us" }), s.map(((e, t) => (0, Ve.jsx)("p", { children: e }, t)))] })] }), (0, Ve.jsxs)("div", { className: " row content-secondflex", children: [(0, Ve.jsxs)("div", { className: " col-lg-5 col-5 col-sm-5 col-md-5  content-emailus", children: [(0, Ve.jsx)("img", { src: ko, alt: "" }), (0, Ve.jsx)("h3", { children: "Email Us" }), a.map(((e, t) => (0, Ve.jsx)("p", { children: e }, t)))] }), (0, Ve.jsxs)("div", { className: " col-lg-5 col-5 col-sm-5 col-md-5   content-openhours", children: [(0, Ve.jsx)("img", { src: To, alt: "" }), (0, Ve.jsx)("h3", { children: "Open Hours" }), c.map(((e, t) => (0, Ve.jsx)("p", { children: e }, t)))] })] })] }), (0, Ve.jsx)("div", { className: " col-lg-6 col-sm-11 col-md-6  content-form ", children: (0, Ve.jsx)("form", { onSubmit: e => { e.preventDefault(), console.log(d), h({ name: "", email: "", subject: "", message: "" }), p(!0) }, children: (0, Ve.jsxs)("div", { className: "row form-content", children: [(0, Ve.jsxs)("div", { className: "col-lg-6 col-md-4 col-6 first", children: [(0, Ve.jsx)("label", { className: "content-yourname", htmlFor: "name", children: "Name" }), (0, Ve.jsx)("input", { className: "content-yoursemail", id: "name", name: "name", value: d.name, onChange: m, required: !0 }), " ", (0, Ve.jsx)("br", {})] }), (0, Ve.jsxs)("div", { className: "col-lg-6 col-md-4 col-6 first", children: [(0, Ve.jsx)("label", { className: "content-youremail", htmlFor: "email", children: " Email " }), (0, Ve.jsx)("input", { className: "content-yoursemail", id: "email", name: "email", value: d.email, onChange: m, required: !0 }), (0, Ve.jsx)("br", {})] }), (0, Ve.jsxs)("div", { className: "col-lg-12 col-md-1 col-12 second", children: [(0, Ve.jsx)("label", { htmlFor: "subject", children: "Subject " }), (0, Ve.jsx)("input", { className: "subject", name: "subject", value: d.subject, onChange: m, required: !0 }), (0, Ve.jsx)("br", {})] }), (0, Ve.jsxs)("div", { className: "col-lg-6 col-sm-12 third", children: [(0, Ve.jsx)("label", { htmlFor: "message", children: "Message" }), (0, Ve.jsx)("textarea", { className: "content-message", name: "message", value: d.message, onChange: m, required: !0 }), (0, Ve.jsx)("br", {})] }), (0, Ve.jsxs)("div", { className: "button-div ", children: [(0, Ve.jsx)("button", { className: "content-button", type: "submit", children: "Submit" }), " "] })] }) }) })] }) }) }) } const Io = n.p + "static/media/afot logo2.0f8259dc801e95ae3e73.png", Ro = n.p + "static/media/mukesh k.b8da6d141c91a8b06c0d.png", Oo = n.p + "static/media/kishore RBt.f821607970ac47d4ce92.png", Do = n.p + "static/media/johit raj ss.97a1b3e6f0139c2348cb.png", _o = n.p + "static/media/krishann R.514fce27f9a930716f7d.png", Mo = n.p + "static/media/gowtham.ec438b48635cc1cc58b3.png", Lo = (0, r.createContext)({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), Fo = (0, r.createContext)({}), Uo = (0, r.createContext)(null), Bo = "undefined" !== typeof document, Vo = Bo ? r.useLayoutEffect : r.useEffect, zo = (0, r.createContext)({ strict: !1 }), qo = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Ho = "data-" + qo("framerAppearId"), Wo = !1, Ko = !1; class Go { constructor() { this.order = [], this.scheduled = new Set } add(e) { if (!this.scheduled.has(e)) return this.scheduled.add(e), this.order.push(e), !0 } remove(e) { const t = this.order.indexOf(e); -1 !== t && (this.order.splice(t, 1), this.scheduled.delete(e)) } clear() { this.order.length = 0, this.scheduled.clear() } } const Qo = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]; function Yo(e, t) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, s = Qo.reduce(((e, t) => (e[t] = function (e) { let t = new Go, n = new Go, r = 0, i = !1, s = !1; const o = new WeakSet, a = { schedule: function (e) { const s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2] && i, a = s ? t : n; return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && o.add(e), a.add(e) && s && i && (r = t.order.length), e }, cancel: e => { n.remove(e), o.delete(e) }, process: l => { if (i) s = !0; else { if (i = !0, [t, n] = [n, t], n.clear(), r = t.order.length, r) for (let n = 0; n < r; n++) { const r = t.order[n]; o.has(r) && (a.schedule(r), e()), r(l) } i = !1, s && (s = !1, a.process(l)) } } }; return a }((() => n = !0)), e)), {}), o = e => { s[e].process(i) }, a = () => { const s = Ko ? i.timestamp : performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(s - i.timestamp, 40), 1), i.timestamp = s, i.isProcessing = !0, Qo.forEach(o), i.isProcessing = !1, n && t && (r = !1, e(a)) }, l = Qo.reduce(((t, o) => { const l = s[o]; return t[o] = function (t) { let s = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return n || (n = !0, r = !0, i.isProcessing || e(a)), l.schedule(t, s, o) }, t }), {}); return { schedule: l, cancel: e => Qo.forEach((t => s[t].cancel(e))), state: i, steps: s } } const { schedule: Jo, cancel: Xo } = Yo(queueMicrotask, !1); function Zo(e) { return e && "object" === typeof e && Object.prototype.hasOwnProperty.call(e, "current") } function $o(e, t, n) { return (0, r.useCallback)((r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && ("function" === typeof n ? n(r) : Zo(n) && (n.current = r)) }), [t]) } function ea(e) { return "string" === typeof e || Array.isArray(e) } function ta(e) { return null !== e && "object" === typeof e && "function" === typeof e.start } const na = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], ra = ["initial", ...na]; function ia(e) { return ta(e.animate) || ra.some((t => ea(e[t]))) } function sa(e) { return Boolean(ia(e) || e.variants) } function oa(e) { const { initial: t, animate: n } = function (e, t) { if (ia(e)) { const { initial: t, animate: n } = e; return { initial: !1 === t || ea(t) ? t : void 0, animate: ea(n) ? n : void 0 } } return !1 !== e.inherit ? t : {} }(e, (0, r.useContext)(Fo)); return (0, r.useMemo)((() => ({ initial: t, animate: n })), [aa(t), aa(n)]) } function aa(e) { return Array.isArray(e) ? e.join(" ") : e } const la = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ca = {}; for (const n in la) ca[n] = { isEnabled: e => la[n].some((t => !!e[t])) }; const ua = (0, r.createContext)({}), da = (0, r.createContext)({}), ha = Symbol.for("motionComponentSymbol"); function fa(e) { let { preloadedFeatures: t, createVisualElement: n, useRender: i, useVisualState: s, Component: o } = e; t && function (e) { for (const t in e) ca[t] = { ...ca[t], ...e[t] } }(t); const a = (0, r.forwardRef)((function (e, a) { let l; const c = { ...(0, r.useContext)(Lo), ...e, layoutId: pa(e) }, { isStatic: u } = c, d = oa(e), h = s(e, u); if (!u && Bo) { d.visualElement = function (e, t, n, i) { const { visualElement: s } = (0, r.useContext)(Fo), o = (0, r.useContext)(zo), a = (0, r.useContext)(Uo), l = (0, r.useContext)(Lo).reducedMotion, c = (0, r.useRef)(); i = i || o.renderer, !c.current && i && (c.current = i(e, { visualState: t, parent: s, props: n, presenceContext: a, blockInitialAnimation: !!a && !1 === a.initial, reducedMotionConfig: l })); const u = c.current; (0, r.useInsertionEffect)((() => { u && u.update(n, a) })); const d = (0, r.useRef)(Boolean(n[Ho] && !window.HandoffComplete)); return Vo((() => { u && (Jo.postRender(u.render), d.current && u.animationState && u.animationState.animateChanges()) })), (0, r.useEffect)((() => { u && (u.updateFeatures(), !d.current && u.animationState && u.animationState.animateChanges(), d.current && (d.current = !1, window.HandoffComplete = !0)) })), u }(o, h, c, n); const e = (0, r.useContext)(da), i = (0, r.useContext)(zo).strict; d.visualElement && (l = d.visualElement.loadFeatures(c, i, t, e)) } return (0, Ve.jsxs)(Fo.Provider, { value: d, children: [l && d.visualElement ? (0, Ve.jsx)(l, { visualElement: d.visualElement, ...c }) : null, i(o, e, $o(h, d.visualElement, a), h, u, d.visualElement)] }) })); return a[ha] = o, a } function pa(e) { let { layoutId: t } = e; const n = (0, r.useContext)(ua).id; return n && void 0 !== t ? n + "-" + t : t } function ma(e) { function t(t) { return fa(e(t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})) } if ("undefined" === typeof Proxy) return t; const n = new Map; return new Proxy(t, { get: (e, r) => (n.has(r) || n.set(r, t(r)), n.get(r)) }) } const ga = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function va(e) { return "string" === typeof e && !e.includes("-") && !!(ga.indexOf(e) > -1 || /[A-Z]/u.test(e)) } const ya = {}; const ba = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], wa = new Set(ba); function xa(e, t) { let { layout: n, layoutId: r } = t; return wa.has(e) || e.startsWith("origin") || (n || void 0 !== r) && (!!ya[e] || "opacity" === e) } const Ea = e => Boolean(e && e.getVelocity), Sa = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, Na = ba.length; const Ca = e => t => "string" === typeof t && t.startsWith(e), Ta = Ca("--"), Aa = Ca("var(--"), ka = e => !!Aa(e) && ja.test(e.split("/*")[0].trim()), ja = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Pa = (e, t) => t && "number" === typeof e ? t.transform(e) : e, Ia = (e, t, n) => n > t ? t : n < e ? e : n, Ra = { test: e => "number" === typeof e, parse: parseFloat, transform: e => e }, Oa = { ...Ra, transform: e => Ia(0, 1, e) }, Da = { ...Ra, default: 1 }, _a = e => Math.round(1e5 * e) / 1e5, Ma = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, La = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, Fa = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function Ua(e) { return "string" === typeof e } const Ba = e => ({ test: t => Ua(t) && t.endsWith(e) && 1 === t.split(" ").length, parse: parseFloat, transform: t => "".concat(t).concat(e) }), Va = Ba("deg"), za = Ba("%"), qa = Ba("px"), Ha = Ba("vh"), Wa = Ba("vw"), Ka = { ...za, parse: e => za.parse(e) / 100, transform: e => za.transform(100 * e) }, Ga = { ...Ra, transform: Math.round }, Qa = { borderWidth: qa, borderTopWidth: qa, borderRightWidth: qa, borderBottomWidth: qa, borderLeftWidth: qa, borderRadius: qa, radius: qa, borderTopLeftRadius: qa, borderTopRightRadius: qa, borderBottomRightRadius: qa, borderBottomLeftRadius: qa, width: qa, maxWidth: qa, height: qa, maxHeight: qa, size: qa, top: qa, right: qa, bottom: qa, left: qa, padding: qa, paddingTop: qa, paddingRight: qa, paddingBottom: qa, paddingLeft: qa, margin: qa, marginTop: qa, marginRight: qa, marginBottom: qa, marginLeft: qa, rotate: Va, rotateX: Va, rotateY: Va, rotateZ: Va, scale: Da, scaleX: Da, scaleY: Da, scaleZ: Da, skew: Va, skewX: Va, skewY: Va, distance: qa, translateX: qa, translateY: qa, translateZ: qa, x: qa, y: qa, z: qa, perspective: qa, transformPerspective: qa, opacity: Oa, originX: Ka, originY: Ka, originZ: qa, zIndex: Ga, backgroundPositionX: qa, backgroundPositionY: qa, fillOpacity: Oa, strokeOpacity: Oa, numOctaves: Ga }; function Ya(e, t, n, r) { const { style: i, vars: s, transform: o, transformOrigin: a } = e; let l = !1, c = !1, u = !0; for (const d in t) { const e = t[d]; if (Ta(d)) { s[d] = e; continue } const n = Qa[d], r = Pa(e, n); if (wa.has(d)) { if (l = !0, o[d] = r, !u) continue; e !== (n.default || 0) && (u = !1) } else d.startsWith("origin") ? (c = !0, a[d] = r) : i[d] = r } if (t.transform || (l || r ? i.transform = function (e, t, n, r) { let { enableHardwareAcceleration: i = !0, allowTransformNone: s = !0 } = t, o = ""; for (let a = 0; a < Na; a++) { const t = ba[a]; if (void 0 !== e[t]) { const n = Sa[t] || t; o += "".concat(n, "(").concat(e[t], ") ") } } return i && !e.z && (o += "translateZ(0)"), o = o.trim(), r ? o = r(e, n ? "" : o) : s && n && (o = "none"), o }(e.transform, n, u, r) : i.transform && (i.transform = "none")), c) { const { originX: e = "50%", originY: t = "50%", originZ: n = 0 } = a; i.transformOrigin = "".concat(e, " ").concat(t, " ").concat(n) } } const Ja = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Xa(e, t, n) { for (const r in t) Ea(t[r]) || xa(r, n) || (e[r] = t[r]) } function Za(e, t, n) { const i = {}; return Xa(i, e.style || {}, e), Object.assign(i, function (e, t, n) { let { transformTemplate: i } = e; return (0, r.useMemo)((() => { const e = Ja(); return Ya(e, t, { enableHardwareAcceleration: !n }, i), Object.assign({}, e.vars, e.style) }), [t]) }(e, t, n)), i } function $a(e, t, n) { const r = {}, i = Za(e, t, n); return e.drag && !1 !== e.dragListener && (r.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = !0 === e.drag ? "none" : "pan-".concat("x" === e.drag ? "y" : "x")), void 0 === e.tabIndex && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0), r.style = i, r } const el = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function tl(e) { return e.startsWith("while") || e.startsWith("drag") && "draggable" !== e || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || el.has(e) } let nl = e => !tl(e); try { (rl = require("@emotion/is-prop-valid").default) && (nl = e => e.startsWith("on") ? !tl(e) : rl(e)) } catch (oI) { } var rl; function il(e, t, n) { return "string" === typeof e ? e : qa.transform(t + n * e) } const sl = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, ol = { offset: "strokeDashoffset", array: "strokeDasharray" }; function al(e, t, n, r, i) { let { attrX: s, attrY: o, attrScale: a, originX: l, originY: c, pathLength: u, pathSpacing: d = 1, pathOffset: h = 0, ...f } = t; if (Ya(e, f, n, i), r) return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)); e.attrs = e.style, e.style = {}; const { attrs: p, style: m, dimensions: g } = e; p.transform && (g && (m.transform = p.transform), delete p.transform), g && (void 0 !== l || void 0 !== c || m.transform) && (m.transformOrigin = function (e, t, n) { const r = il(t, e.x, e.width), i = il(n, e.y, e.height); return "".concat(r, " ").concat(i) }(g, void 0 !== l ? l : .5, void 0 !== c ? c : .5)), void 0 !== s && (p.x = s), void 0 !== o && (p.y = o), void 0 !== a && (p.scale = a), void 0 !== u && function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; e.pathLength = 1; const s = i ? sl : ol; e[s.offset] = qa.transform(-r); const o = qa.transform(t), a = qa.transform(n); e[s.array] = "".concat(o, " ").concat(a) }(p, u, d, h, !1) } const ll = () => ({ ...Ja(), attrs: {} }), cl = e => "string" === typeof e && "svg" === e.toLowerCase(); function ul(e, t, n, i) { const s = (0, r.useMemo)((() => { const n = ll(); return al(n, t, { enableHardwareAcceleration: !1 }, cl(i), e.transformTemplate), { ...n.attrs, style: { ...n.style } } }), [t]); if (e.style) { const t = {}; Xa(t, e.style, e), s.style = { ...t, ...s.style } } return s } function dl() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return (t, n, i, s, o) => { let { latestValues: a } = s; const l = (va(t) ? ul : $a)(n, a, o, t), c = function (e, t, n) { const r = {}; for (const i in e) "values" === i && "object" === typeof e.values || (nl(i) || !0 === n && tl(i) || !t && !tl(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r }(n, "string" === typeof t, e), u = t !== r.Fragment ? { ...c, ...l, ref: i } : {}, { children: d } = n, h = (0, r.useMemo)((() => Ea(d) ? d.get() : d), [d]); return (0, r.createElement)(t, { ...u, children: h }) } } function hl(e, t, n, r) { let { style: i, vars: s } = t; Object.assign(e.style, i, r && r.getProjectionStyles(n)); for (const o in s) e.style.setProperty(o, s[o]) } const fl = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function pl(e, t, n, r) { hl(e, t, void 0, r); for (const i in t.attrs) e.setAttribute(fl.has(i) ? i : qo(i), t.attrs[i]) } function ml(e, t, n) { var r; const { style: i } = e, s = {}; for (const o in i) (Ea(i[o]) || t.style && Ea(t.style[o]) || xa(o, e) || void 0 !== (null === (r = null === n || void 0 === n ? void 0 : n.getValue(o)) || void 0 === r ? void 0 : r.liveStyle)) && (s[o] = i[o]); return s } function gl(e, t, n) { const r = ml(e, t, n); for (const i in e) if (Ea(e[i]) || Ea(t[i])) { r[-1 !== ba.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = e[i] } return r } function vl(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; return "function" === typeof t && (t = t(void 0 !== n ? n : e.custom, r, i)), "string" === typeof t && (t = e.variants && e.variants[t]), "function" === typeof t && (t = t(void 0 !== n ? n : e.custom, r, i)), t } function yl(e) { const t = (0, r.useRef)(null); return null === t.current && (t.current = e()), t.current } const bl = e => Array.isArray(e), wl = e => Boolean(e && "object" === typeof e && e.mix && e.toValue), xl = e => bl(e) ? e[e.length - 1] || 0 : e; function El(e) { const t = Ea(e) ? e.get() : e; return wl(t) ? t.toValue() : t } const Sl = e => (t, n) => { const i = (0, r.useContext)(Fo), s = (0, r.useContext)(Uo), o = () => function (e, t, n, r) { let { scrapeMotionValuesFromProps: i, createRenderState: s, onMount: o } = e; const a = { latestValues: Nl(t, n, r, i), renderState: s() }; return o && (a.mount = e => o(t, e, a)), a }(e, t, i, s); return n ? o() : yl(o) }; function Nl(e, t, n, r) { const i = {}, s = r(e, {}); for (const h in s) i[h] = El(s[h]); let { initial: o, animate: a } = e; const l = ia(e), c = sa(e); t && c && !l && !1 !== e.inherit && (void 0 === o && (o = t.initial), void 0 === a && (a = t.animate)); let u = !!n && !1 === n.initial; u = u || !1 === o; const d = u ? a : o; if (d && "boolean" !== typeof d && !ta(d)) { (Array.isArray(d) ? d : [d]).forEach((t => { const n = vl(e, t); if (!n) return; const { transitionEnd: r, transition: s, ...o } = n; for (const e in o) { let t = o[e]; if (Array.isArray(t)) { t = t[u ? t.length - 1 : 0] } null !== t && (i[e] = t) } for (const e in r) i[e] = r[e] })) } return i } const Cl = e => e, { schedule: Tl, cancel: Al, state: kl, steps: jl } = Yo("undefined" !== typeof requestAnimationFrame ? requestAnimationFrame : Cl, !0), Pl = { useVisualState: Sl({ scrapeMotionValuesFromProps: gl, createRenderState: ll, onMount: (e, t, n) => { let { renderState: r, latestValues: i } = n; Tl.read((() => { try { r.dimensions = "function" === typeof t.getBBox ? t.getBBox() : t.getBoundingClientRect() } catch (sI) { r.dimensions = { x: 0, y: 0, width: 0, height: 0 } } })), Tl.render((() => { al(r, i, { enableHardwareAcceleration: !1 }, cl(t.tagName), e.transformTemplate), pl(t, r) })) } }) }, Il = { useVisualState: Sl({ scrapeMotionValuesFromProps: ml, createRenderState: Ja }) }; function Rl(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { passive: !0 }; return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } const Ol = e => "mouse" === e.pointerType ? "number" !== typeof e.button || e.button <= 0 : !1 !== e.isPrimary; function Dl(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "page"; return { point: { x: e["".concat(t, "X")], y: e["".concat(t, "Y")] } } } const _l = e => t => Ol(t) && e(t, Dl(t)); function Ml(e, t, n, r) { return Rl(e, t, _l(n), r) } const Ll = (e, t) => n => t(e(n)), Fl = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.reduce(Ll) }; function Ul(e) { let t = null; return () => { const n = () => { t = null }; return null === t && (t = e, n) } } const Bl = Ul("dragHorizontal"), Vl = Ul("dragVertical"); function zl(e) { let t = !1; if ("y" === e) t = Vl(); else if ("x" === e) t = Bl(); else { const e = Bl(), n = Vl(); e && n ? t = () => { e(), n() } : (e && e(), n && n()) } return t } function ql() { const e = zl(!0); return !e || (e(), !1) } class Hl { constructor(e) { this.isMounted = !1, this.node = e } update() { } } function Wl(e, t) { const n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd"; return Ml(e.current, n, ((n, i) => { if ("touch" === n.pointerType || ql()) return; const s = e.getProps(); e.animationState && s.whileHover && e.animationState.setActive("whileHover", t); const o = s[r]; o && Tl.postRender((() => o(n, i))) }), { passive: !e.getProps()[r] }) } const Kl = (e, t) => !!t && (e === t || Kl(e, t.parentElement)); function Gl(e, t) { if (!t) return; const n = new PointerEvent("pointer" + e); t(n, Dl(n)) } const Ql = new WeakMap, Yl = new WeakMap, Jl = e => { const t = Ql.get(e.target); t && t(e) }, Xl = e => { e.forEach(Jl) }; function Zl(e, t, n) { const r = function (e) { let { root: t, ...n } = e; const r = t || document; Yl.has(r) || Yl.set(r, {}); const i = Yl.get(r), s = JSON.stringify(n); return i[s] || (i[s] = new IntersectionObserver(Xl, { root: t, ...n })), i[s] }(t); return Ql.set(e, n), r.observe(e), () => { Ql.delete(e), r.unobserve(e) } } const $l = { some: 0, all: 1 }; const ec = { inView: { Feature: class extends Hl { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: i } = e, s = { root: t ? t.current : void 0, rootMargin: n, threshold: "number" === typeof r ? r : $l[r] }; return Zl(this.node.current, s, (e => { const { isIntersecting: t } = e; if (this.isInView === t) return; if (this.isInView = t, i && !t && this.hasEnteredView) return; t && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", t); const { onViewportEnter: n, onViewportLeave: r } = this.node.getProps(), s = t ? n : r; s && s(e) })) } mount() { this.startObserver() } update() { if ("undefined" === typeof IntersectionObserver) return; const { props: e, prevProps: t } = this.node, n = ["amount", "margin", "root"].some(function (e) { let { viewport: t = {} } = e, { viewport: n = {} } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return e => t[e] !== n[e] }(e, t)); n && this.startObserver() } unmount() { } } }, tap: { Feature: class extends Hl { constructor() { super(...arguments), this.removeStartListeners = Cl, this.removeEndListeners = Cl, this.removeAccessibleListeners = Cl, this.startPointerPress = (e, t) => { if (this.isPressing) return; this.removeEndListeners(); const n = this.node.getProps(), r = Ml(window, "pointerup", ((e, t) => { if (!this.checkPressEnd()) return; const { onTap: n, onTapCancel: r, globalTapTarget: i } = this.node.getProps(), s = i || Kl(this.node.current, e.target) ? n : r; s && Tl.update((() => s(e, t))) }), { passive: !(n.onTap || n.onPointerUp) }), i = Ml(window, "pointercancel", ((e, t) => this.cancelPress(e, t)), { passive: !(n.onTapCancel || n.onPointerCancel) }); this.removeEndListeners = Fl(r, i), this.startPress(e, t) }, this.startAccessiblePress = () => { const e = Rl(this.node.current, "keydown", (e => { if ("Enter" !== e.key || this.isPressing) return; this.removeEndListeners(), this.removeEndListeners = Rl(this.node.current, "keyup", (e => { "Enter" === e.key && this.checkPressEnd() && Gl("up", ((e, t) => { const { onTap: n } = this.node.getProps(); n && Tl.postRender((() => n(e, t))) })) })), Gl("down", ((e, t) => { this.startPress(e, t) })) })), t = Rl(this.node.current, "blur", (() => { this.isPressing && Gl("cancel", ((e, t) => this.cancelPress(e, t))) })); this.removeAccessibleListeners = Fl(e, t) } } startPress(e, t) { this.isPressing = !0; const { onTapStart: n, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Tl.postRender((() => n(e, t))) } checkPressEnd() { this.removeEndListeners(), this.isPressing = !1; return this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !ql() } cancelPress(e, t) { if (!this.checkPressEnd()) return; const { onTapCancel: n } = this.node.getProps(); n && Tl.postRender((() => n(e, t))) } mount() { const e = this.node.getProps(), t = Ml(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = Rl(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Fl(t, n) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } }, focus: { Feature: class extends Hl { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch (sI) { e = !0 } e && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Fl(Rl(this.node.current, "focus", (() => this.onFocus())), Rl(this.node.current, "blur", (() => this.onBlur()))) } unmount() { } } }, hover: { Feature: class extends Hl { mount() { this.unmount = Fl(Wl(this.node, !0), Wl(this.node, !1)) } unmount() { } } } }; function tc(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function nc(e, t, n) { const r = e.getProps(); return vl(r, t, void 0 !== n ? n : r.custom, function (e) { const t = {}; return e.values.forEach(((e, n) => t[n] = e.get())), t }(e), function (e) { const t = {}; return e.values.forEach(((e, n) => t[n] = e.getVelocity())), t }(e)) } const rc = e => 1e3 * e, ic = e => e / 1e3, sc = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, oc = { type: "keyframes", duration: .8 }, ac = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, lc = (e, t) => { let { keyframes: n } = t; return n.length > 2 ? oc : wa.has(e) ? e.startsWith("scale") ? { type: "spring", stiffness: 550, damping: 0 === n[1] ? 2 * Math.sqrt(550) : 30, restSpeed: 10 } : sc : ac }; function cc(e, t) { return e[t] || e.default || e } const uc = !1, dc = e => null !== e; function hc(e, t, n) { let { repeat: r, repeatType: i = "loop" } = t; const s = e.filter(dc), o = r && "loop" !== i && r % 2 === 1 ? 0 : s.length - 1; return o && void 0 !== n ? n : s[o] } let fc; function pc() { fc = void 0 } const mc = { now: () => (void 0 === fc && mc.set(kl.isProcessing || Ko ? kl.timestamp : performance.now()), fc), set: e => { fc = e, queueMicrotask(pc) } }, gc = e => /^0[^.\s]+$/u.test(e); let vc = Cl, yc = Cl; const bc = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), wc = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function xc(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; yc(n <= 4, 'Max CSS variable fallback depth detected in property "'.concat(e, '". This may indicate a circular fallback dependency.')); const [r, i] = function (e) { const t = wc.exec(e); if (!t) return [,]; const [, n, r, i] = t; return ["--".concat(null !== n && void 0 !== n ? n : r), i] }(e); if (!r) return; const s = window.getComputedStyle(t).getPropertyValue(r); if (s) { const e = s.trim(); return bc(e) ? parseFloat(e) : e } return ka(i) ? xc(i, t, n + 1) : i } const Ec = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), Sc = e => e === Ra || e === qa, Nc = (e, t) => parseFloat(e.split(", ")[t]), Cc = (e, t) => (n, r) => { let { transform: i } = r; if ("none" === i || !i) return 0; const s = i.match(/^matrix3d\((.+)\)$/u); if (s) return Nc(s[1], t); { const t = i.match(/^matrix\((.+)\)$/u); return t ? Nc(t[1], e) : 0 } }, Tc = new Set(["x", "y", "z"]), Ac = ba.filter((e => !Tc.has(e))); const kc = { width: (e, t) => { let { x: n } = e, { paddingLeft: r = "0", paddingRight: i = "0" } = t; return n.max - n.min - parseFloat(r) - parseFloat(i) }, height: (e, t) => { let { y: n } = e, { paddingTop: r = "0", paddingBottom: i = "0" } = t; return n.max - n.min - parseFloat(r) - parseFloat(i) }, top: (e, t) => { let { top: n } = t; return parseFloat(n) }, left: (e, t) => { let { left: n } = t; return parseFloat(n) }, bottom: (e, t) => { let { y: n } = e, { top: r } = t; return parseFloat(r) + (n.max - n.min) }, right: (e, t) => { let { x: n } = e, { left: r } = t; return parseFloat(r) + (n.max - n.min) }, x: Cc(4, 13), y: Cc(5, 14) }; kc.translateX = kc.x, kc.translateY = kc.y; const jc = e => t => t.test(e), Pc = [Ra, qa, za, Va, Wa, Ha, { test: e => "auto" === e, parse: e => e }], Ic = e => Pc.find(jc(e)), Rc = new Set; let Oc = !1, Dc = !1; function _c() { if (Dc) { const e = Array.from(Rc).filter((e => e.needsMeasurement)), t = new Set(e.map((e => e.element))), n = new Map; t.forEach((e => { const t = function (e) { const t = []; return Ac.forEach((n => { const r = e.getValue(n); void 0 !== r && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) })), t }(e); t.length && (n.set(e, t), e.render()) })), e.forEach((e => e.measureInitialState())), t.forEach((e => { e.render(); const t = n.get(e); t && t.forEach((t => { let [n, r] = t; var i; null === (i = e.getValue(n)) || void 0 === i || i.set(r) })) })), e.forEach((e => e.measureEndState())), e.forEach((e => { void 0 !== e.suspendedScrollY && window.scrollTo(0, e.suspendedScrollY) })) } Dc = !1, Oc = !1, Rc.forEach((e => e.complete())), Rc.clear() } function Mc() { Rc.forEach((e => { e.readKeyframes(), e.needsMeasurement && (Dc = !0) })) } class Lc { constructor(e, t, n, r, i) { let s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]; this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = r, this.element = i, this.isAsync = s } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Rc.add(this), Oc || (Oc = !0, Tl.read(Mc), Tl.resolveKeyframes(_c))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this; for (let i = 0; i < e.length; i++)if (null === e[i]) if (0 === i) { const i = null === r || void 0 === r ? void 0 : r.get(), s = e[e.length - 1]; if (void 0 !== i) e[0] = i; else if (n && t) { const r = n.readValue(t, s); void 0 !== r && null !== r && (e[0] = r) } void 0 === e[0] && (e[0] = s), r && void 0 === i && r.set(e[0]) } else e[i] = e[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Rc.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Rc.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const Fc = (e, t) => n => Boolean(Ua(n) && Fa.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), Uc = (e, t, n) => r => { if (!Ua(r)) return r; const [i, s, o, a] = r.match(Ma); return { [e]: parseFloat(i), [t]: parseFloat(s), [n]: parseFloat(o), alpha: void 0 !== a ? parseFloat(a) : 1 } }, Bc = { ...Ra, transform: e => Math.round((e => Ia(0, 255, e))(e)) }, Vc = { test: Fc("rgb", "red"), parse: Uc("red", "green", "blue"), transform: e => { let { red: t, green: n, blue: r, alpha: i = 1 } = e; return "rgba(" + Bc.transform(t) + ", " + Bc.transform(n) + ", " + Bc.transform(r) + ", " + _a(Oa.transform(i)) + ")" } }; const zc = { test: Fc("#"), parse: function (e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } }, transform: Vc.transform }, qc = { test: Fc("hsl", "hue"), parse: Uc("hue", "saturation", "lightness"), transform: e => { let { hue: t, saturation: n, lightness: r, alpha: i = 1 } = e; return "hsla(" + Math.round(t) + ", " + za.transform(_a(n)) + ", " + za.transform(_a(r)) + ", " + _a(Oa.transform(i)) + ")" } }, Hc = { test: e => Vc.test(e) || zc.test(e) || qc.test(e), parse: e => Vc.test(e) ? Vc.parse(e) : qc.test(e) ? qc.parse(e) : zc.parse(e), transform: e => Ua(e) ? e : e.hasOwnProperty("red") ? Vc.transform(e) : qc.transform(e) }; const Wc = "number", Kc = "color", Gc = "var", Qc = "var(", Yc = "${}", Jc = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Xc(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let s = 0; const o = t.replace(Jc, (e => (Hc.test(e) ? (r.color.push(s), i.push(Kc), n.push(Hc.parse(e))) : e.startsWith(Qc) ? (r.var.push(s), i.push(Gc), n.push(e)) : (r.number.push(s), i.push(Wc), n.push(parseFloat(e))), ++s, Yc))).split(Yc); return { values: n, split: o, indexes: r, types: i } } function Zc(e) { return Xc(e).values } function $c(e) { const { split: t, types: n } = Xc(e), r = t.length; return e => { let i = ""; for (let s = 0; s < r; s++)if (i += t[s], void 0 !== e[s]) { const t = n[s]; i += t === Wc ? _a(e[s]) : t === Kc ? Hc.transform(e[s]) : e[s] } return i } } const eu = e => "number" === typeof e ? 0 : e; const tu = { test: function (e) { var t, n; return isNaN(e) && Ua(e) && ((null === (t = e.match(Ma)) || void 0 === t ? void 0 : t.length) || 0) + ((null === (n = e.match(La)) || void 0 === n ? void 0 : n.length) || 0) > 0 }, parse: Zc, createTransformer: $c, getAnimatableNone: function (e) { const t = Zc(e); return $c(e)(t.map(eu)) } }, nu = new Set(["brightness", "contrast", "saturate", "opacity"]); function ru(e) { const [t, n] = e.slice(0, -1).split("("); if ("drop-shadow" === t) return e; const [r] = n.match(Ma) || []; if (!r) return e; const i = n.replace(r, ""); let s = nu.has(t) ? 1 : 0; return r !== n && (s *= 100), t + "(" + s + i + ")" } const iu = /\b([a-z-]*)\(.*?\)/gu, su = { ...tu, getAnimatableNone: e => { const t = e.match(iu); return t ? t.map(ru).join(" ") : e } }, ou = { ...Qa, color: Hc, backgroundColor: Hc, outlineColor: Hc, fill: Hc, stroke: Hc, borderColor: Hc, borderTopColor: Hc, borderRightColor: Hc, borderBottomColor: Hc, borderLeftColor: Hc, filter: su, WebkitFilter: su }, au = e => ou[e]; function lu(e, t) { let n = au(e); return n !== su && (n = tu), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const cu = new Set(["auto", "none", "0"]); class uu extends Lc { constructor(e, t, n, r) { super(e, t, n, r, null === r || void 0 === r ? void 0 : r.owner, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: t, name: n } = this; if (!t.current) return; super.readKeyframes(); for (let a = 0; a < e.length; a++) { const n = e[a]; if ("string" === typeof n && ka(n)) { const r = xc(n, t.current); void 0 !== r && (e[a] = r), a === e.length - 1 && (this.finalKeyframe = n) } } if (this.resolveNoneKeyframes(), !Ec.has(n) || 2 !== e.length) return; const [r, i] = e, s = Ic(r), o = Ic(i); if (s !== o) if (Sc(s) && Sc(o)) for (let a = 0; a < e.length; a++) { const t = e[a]; "string" === typeof t && (e[a] = parseFloat(t)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: t } = this, n = []; for (let i = 0; i < e.length; i++)("number" === typeof (r = e[i]) ? 0 === r : null === r || "none" === r || "0" === r || gc(r)) && n.push(i); var r; n.length && function (e, t, n) { let r, i = 0; for (; i < e.length && !r;) { const t = e[i]; "string" !== typeof t || cu.has(t) || (r = e[i]), i++ } if (r && n) for (const s of t) e[s] = lu(n, r) }(e, n, t) } measureInitialState() { const { element: e, unresolvedKeyframes: t, name: n } = this; if (!e.current) return; "height" === n && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = kc[n](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin; const r = t[t.length - 1]; void 0 !== r && e.getValue(n, r).jump(r, !1) } measureEndState() { var e; const { element: t, name: n, unresolvedKeyframes: r } = this; if (!t.current) return; const i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); const s = r.length - 1, o = r[s]; r[s] = kc[n](t.measureViewportBox(), window.getComputedStyle(t.current)), null !== o && void 0 === this.finalKeyframe && (this.finalKeyframe = o), (null === (e = this.removedTransforms) || void 0 === e ? void 0 : e.length) && this.removedTransforms.forEach((e => { let [n, r] = e; t.getValue(n).set(r) })), this.resolveNoneKeyframes() } } const du = (e, t) => "zIndex" !== t && (!("number" !== typeof e && !Array.isArray(e)) || !("string" !== typeof e || !tu.test(e) && "0" !== e || e.startsWith("url("))); class hu { constructor(e) { let { autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: o = "loop", ...a } = e; this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = { autoplay: t, delay: n, type: r, repeat: i, repeatDelay: s, repeatType: o, ...a }, this.updateFinishedPromise() } get resolved() { return this._resolved || this.hasAttemptedResolve || (Mc(), _c()), this._resolved } onKeyframesResolved(e, t) { this.hasAttemptedResolve = !0; const { name: n, type: r, velocity: i, delay: s, onComplete: o, onUpdate: a, isGenerator: l } = this.options; if (!l && !function (e, t, n, r) { const i = e[0]; if (null === i) return !1; const s = e[e.length - 1], o = du(i, t), a = du(s, t); return vc(o === a, "You are trying to animate ".concat(t, ' from "').concat(i, '" to "').concat(s, '". ').concat(i, " is not an animatable value - to enable this animation set ").concat(i, " to a value animatable to ").concat(s, " via the `style` property.")), !(!o || !a) && (function (e) { const t = e[0]; if (1 === e.length) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 }(e) || "spring" === n && r) }(e, n, r, i)) { if (uc || !s) return null === a || void 0 === a || a(hc(e, this.options, t)), null === o || void 0 === o || o(), void this.resolveFinishedPromise(); this.options.duration = 0 } const c = this.initPlayback(e, t); !1 !== c && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } updateFinishedPromise() { this.currentFinishedPromise = new Promise((e => { this.resolveFinishedPromise = e })) } } function fu(e, t) { return t ? e * (1e3 / t) : 0 } const pu = 5; function mu(e, t, n) { const r = Math.max(t - pu, 0); return fu(n - e(r), t - r) } const gu = .001, vu = .01, yu = 10, bu = .05, wu = 1; function xu(e) { let t, n, { duration: r = 800, bounce: i = .25, velocity: s = 0, mass: o = 1 } = e; vc(r <= rc(yu), "Spring duration must be 10 seconds or less"); let a = 1 - i; a = Ia(bu, wu, a), r = Ia(vu, yu, ic(r)), a < 1 ? (t = e => { const t = e * a, n = t * r, i = t - s, o = Su(e, a), l = Math.exp(-n); return gu - i / o * l }, n = e => { const n = e * a * r, i = n * s + s, o = Math.pow(a, 2) * Math.pow(e, 2) * r, l = Math.exp(-n), c = Su(Math.pow(e, 2), a); return (-t(e) + gu > 0 ? -1 : 1) * ((i - o) * l) / c }) : (t = e => Math.exp(-e * r) * ((e - s) * r + 1) - gu, n = e => Math.exp(-e * r) * (r * r * (s - e))); const l = function (e, t, n) { let r = n; for (let i = 1; i < Eu; i++)r -= e(r) / t(r); return r }(t, n, 5 / r); if (r = rc(r), isNaN(l)) return { stiffness: 100, damping: 10, duration: r }; { const e = Math.pow(l, 2) * o; return { stiffness: e, damping: 2 * a * Math.sqrt(o * e), duration: r } } } const Eu = 12; function Su(e, t) { return e * Math.sqrt(1 - t * t) } const Nu = ["duration", "bounce"], Cu = ["stiffness", "damping", "mass"]; function Tu(e, t) { return t.some((t => void 0 !== e[t])) } function Au(e) { let { keyframes: t, restDelta: n, restSpeed: r, ...i } = e; const s = t[0], o = t[t.length - 1], a = { done: !1, value: s }, { stiffness: l, damping: c, mass: u, duration: d, velocity: h, isResolvedFromDuration: f } = function (e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!Tu(e, Cu) && Tu(e, Nu)) { const n = xu(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t }({ ...i, velocity: -ic(i.velocity || 0) }), p = h || 0, m = c / (2 * Math.sqrt(l * u)), g = o - s, v = ic(Math.sqrt(l / u)), y = Math.abs(g) < 5; let b; if (r || (r = y ? .01 : 2), n || (n = y ? .005 : .5), m < 1) { const e = Su(v, m); b = t => { const n = Math.exp(-m * v * t); return o - n * ((p + m * v * g) / e * Math.sin(e * t) + g * Math.cos(e * t)) } } else if (1 === m) b = e => o - Math.exp(-v * e) * (g + (p + v * g) * e); else { const e = v * Math.sqrt(m * m - 1); b = t => { const n = Math.exp(-m * v * t), r = Math.min(e * t, 300); return o - n * ((p + m * v * g) * Math.sinh(r) + e * g * Math.cosh(r)) / e } } return { calculatedDuration: f && d || null, next: e => { const t = b(e); if (f) a.done = e >= d; else { let i = p; 0 !== e && (i = m < 1 ? mu(b, e, t) : 0); const s = Math.abs(i) <= r, l = Math.abs(o - t) <= n; a.done = s && l } return a.value = a.done ? o : t, a } } } function ku(e) { let { keyframes: t, velocity: n = 0, power: r = .8, timeConstant: i = 325, bounceDamping: s = 10, bounceStiffness: o = 500, modifyTarget: a, min: l, max: c, restDelta: u = .5, restSpeed: d } = e; const h = t[0], f = { done: !1, value: h }, p = e => void 0 === l ? c : void 0 === c || Math.abs(l - e) < Math.abs(c - e) ? l : c; let m = r * n; const g = h + m, v = void 0 === a ? g : a(g); v !== g && (m = v - h); const y = e => -m * Math.exp(-e / i), b = e => v + y(e), w = e => { const t = y(e), n = b(e); f.done = Math.abs(t) <= u, f.value = f.done ? v : n }; let x, E; const S = e => { (e => void 0 !== l && e < l || void 0 !== c && e > c)(f.value) && (x = e, E = Au({ keyframes: [f.value, p(f.value)], velocity: mu(b, e, f.value), damping: s, stiffness: o, restDelta: u, restSpeed: d })) }; return S(0), { calculatedDuration: null, next: e => { let t = !1; return E || void 0 !== x || (t = !0, w(e), S(e)), void 0 !== x && e >= x ? E.next(e - x) : (!t && w(e), f) } } } const ju = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, Pu = 1e-7, Iu = 12; function Ru(e, t, n, r) { if (e === t && n === r) return Cl; const i = t => function (e, t, n, r, i) { let s, o, a = 0; do { o = t + (n - t) / 2, s = ju(o, r, i) - e, s > 0 ? n = o : t = o } while (Math.abs(s) > Pu && ++a < Iu); return o }(t, 0, 1, e, n); return e => 0 === e || 1 === e ? e : ju(i(e), t, r) } const Ou = Ru(.42, 0, 1, 1), Du = Ru(0, 0, .58, 1), _u = Ru(.42, 0, .58, 1), Mu = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, Lu = e => t => 1 - e(1 - t), Fu = e => 1 - Math.sin(Math.acos(e)), Uu = Lu(Fu), Bu = Mu(Fu), Vu = Ru(.33, 1.53, .69, .99), zu = Lu(Vu), qu = Mu(zu), Hu = { linear: Cl, easeIn: Ou, easeInOut: _u, easeOut: Du, circIn: Fu, circInOut: Bu, circOut: Uu, backIn: zu, backInOut: qu, backOut: Vu, anticipate: e => (e *= 2) < 1 ? .5 * zu(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))) }, Wu = e => { if (Array.isArray(e)) { yc(4 === e.length, "Cubic bezier arrays must contain four numerical values."); const [t, n, r, i] = e; return Ru(t, n, r, i) } return "string" === typeof e ? (yc(void 0 !== Hu[e], "Invalid easing type '".concat(e, "'")), Hu[e]) : e }, Ku = (e, t, n) => { const r = t - e; return 0 === r ? 1 : (n - e) / r }, Gu = (e, t, n) => e + (t - e) * n; function Qu(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } const Yu = (e, t, n) => { const r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, Ju = [zc, Vc, qc]; function Xu(e) { const t = (e => Ju.find((t => t.test(e))))(e); yc(Boolean(t), "'".concat(e, "' is not an animatable color. Use the equivalent color code instead.")); let n = t.parse(e); return t === qc && (n = function (e) { let { hue: t, saturation: n, lightness: r, alpha: i } = e; t /= 360, n /= 100, r /= 100; let s = 0, o = 0, a = 0; if (n) { const e = r < .5 ? r * (1 + n) : r + n - r * n, i = 2 * r - e; s = Qu(i, e, t + 1 / 3), o = Qu(i, e, t), a = Qu(i, e, t - 1 / 3) } else s = o = a = r; return { red: Math.round(255 * s), green: Math.round(255 * o), blue: Math.round(255 * a), alpha: i } }(n)), n } const Zu = (e, t) => { const n = Xu(e), r = Xu(t), i = { ...n }; return e => (i.red = Yu(n.red, r.red, e), i.green = Yu(n.green, r.green, e), i.blue = Yu(n.blue, r.blue, e), i.alpha = Gu(n.alpha, r.alpha, e), Vc.transform(i)) }; function $u(e, t) { return n => n > 0 ? t : e } function ed(e, t) { return n => Gu(e, t, n) } function td(e) { return "number" === typeof e ? ed : "string" === typeof e ? ka(e) ? $u : Hc.test(e) ? Zu : id : Array.isArray(e) ? nd : "object" === typeof e ? Hc.test(e) ? Zu : rd : $u } function nd(e, t) { const n = [...e], r = n.length, i = e.map(((e, n) => td(e)(e, t[n]))); return e => { for (let t = 0; t < r; t++)n[t] = i[t](e); return n } } function rd(e, t) { const n = { ...e, ...t }, r = {}; for (const i in n) void 0 !== e[i] && void 0 !== t[i] && (r[i] = td(e[i])(e[i], t[i])); return e => { for (const t in r) n[t] = r[t](e); return n } } const id = (e, t) => { const n = tu.createTransformer(t), r = Xc(e), i = Xc(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Fl(nd(function (e, t) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let s = 0; s < t.values.length; s++) { const o = t.types[s], a = e.indexes[o][i[o]], l = null !== (n = e.values[a]) && void 0 !== n ? n : 0; r[s] = l, i[o]++ } return r }(r, i), i.values), n) : (vc(!0, "Complex values '".concat(e, "' and '").concat(t, "' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.")), $u(e, t)) }; function sd(e, t, n) { if ("number" === typeof e && "number" === typeof t && "number" === typeof n) return Gu(e, t, n); return td(e)(e, t) } function od(e, t) { let { clamp: n = !0, ease: r, mixer: i } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const s = e.length; if (yc(s === t.length, "Both input and output ranges must be the same length"), 1 === s) return () => t[0]; if (2 === s && e[0] === e[1]) return () => t[1]; e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse()); const o = function (e, t, n) { const r = [], i = n || sd, s = e.length - 1; for (let o = 0; o < s; o++) { let n = i(e[o], e[o + 1]); if (t) { const e = Array.isArray(t) ? t[o] || Cl : t; n = Fl(e, n) } r.push(n) } return r }(t, r, i), a = o.length, l = t => { let n = 0; if (a > 1) for (; n < e.length - 2 && !(t < e[n + 1]); n++); const r = Ku(e[n], e[n + 1], t); return o[n](r) }; return n ? t => l(Ia(e[0], e[s - 1], t)) : l } function ad(e) { const t = [0]; return function (e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const i = Ku(0, t, r); e.push(Gu(n, 1, i)) } }(t, e.length - 1), t } function ld(e) { let { duration: t = 300, keyframes: n, times: r, ease: i = "easeInOut" } = e; const s = (e => Array.isArray(e) && "number" !== typeof e[0])(i) ? i.map(Wu) : Wu(i), o = { done: !1, value: n[0] }, a = function (e, t) { return e.map((e => e * t)) }(r && r.length === n.length ? r : ad(n), t), l = od(a, n, { ease: Array.isArray(s) ? s : (c = n, u = s, c.map((() => u || _u)).splice(0, c.length - 1)) }); var c, u; return { calculatedDuration: t, next: e => (o.value = l(e), o.done = e >= t, o) } } const cd = e => { const t = t => { let { timestamp: n } = t; return e(n) }; return { start: () => Tl.update(t, !0), stop: () => Al(t), now: () => kl.isProcessing ? kl.timestamp : mc.now() } }, ud = { decay: ku, inertia: ku, tween: ld, keyframes: ld, spring: Au }, dd = e => e / 100; class hd extends hu { constructor(e) { let { KeyframeResolver: t = Lc, ...n } = e; super(n), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; this.teardown(); const { onStop: e } = this.options; e && e() }; const { name: r, motionValue: i, keyframes: s } = this.options, o = (e, t) => this.onKeyframesResolved(e, t); r && i && i.owner ? this.resolver = i.owner.resolveKeyframes(s, o, r, i) : this.resolver = new t(s, o, r, i), this.resolver.scheduleResolve() } initPlayback(e) { const { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: s = 0 } = this.options, o = ud[t] || ld; let a, l; o !== ld && "number" !== typeof e[0] && (a = Fl(dd, sd(e[0], e[1])), e = [0, 100]); const c = o({ ...this.options, keyframes: e }); "mirror" === i && (l = o({ ...this.options, keyframes: [...e].reverse(), velocity: -s })), null === c.calculatedDuration && (c.calculatedDuration = function (e) { let t = 0, n = e.next(t); for (; !n.done && t < 2e4;)t += 50, n = e.next(t); return t >= 2e4 ? 1 / 0 : t }(c)); const { calculatedDuration: u } = c, d = u + r; return { generator: c, mirroredGenerator: l, mapPercentToKeyframes: a, calculatedDuration: u, resolvedDuration: d, totalDuration: d * (n + 1) - r } } onPostResolved() { const { autoplay: e = !0 } = this.options; this.play(), "paused" !== this.pendingPlayState && e ? this.state = this.pendingPlayState : this.pause() } tick(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const { resolved: n } = this; if (!n) { const { keyframes: e } = this.options; return { done: !0, value: e[e.length - 1] } } const { finalKeyframe: r, generator: i, mirroredGenerator: s, mapPercentToKeyframes: o, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n; if (null === this.startTime) return i.next(0); const { delay: d, repeat: h, repeatType: f, repeatDelay: p, onUpdate: m } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)), t ? this.currentTime = e : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; const g = this.currentTime - d * (this.speed >= 0 ? 1 : -1), v = this.speed >= 0 ? g < 0 : g > c; this.currentTime = Math.max(g, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = c); let y = this.currentTime, b = i; if (h) { const e = Math.min(this.currentTime, c) / u; let t = Math.floor(e), n = e % 1; !n && e >= 1 && (n = 1), 1 === n && t--, t = Math.min(t, h + 1); Boolean(t % 2) && ("reverse" === f ? (n = 1 - n, p && (n -= p / u)) : "mirror" === f && (b = s)), y = Ia(0, 1, n) * u } const w = v ? { done: !1, value: a[0] } : b.next(y); o && (w.value = o(w.value)); let { done: x } = w; v || null === l || (x = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const E = null === this.holdTime && ("finished" === this.state || "running" === this.state && x); return E && void 0 !== r && (w.value = hc(a, this.options, r)), m && m(w.value), E && this.finish(), w } get duration() { const { resolved: e } = this; return e ? ic(e.calculatedDuration) : 0 } get time() { return ic(this.currentTime) } set time(e) { e = rc(e), this.currentTime = e, null !== this.holdTime || 0 === this.speed ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { const t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = ic(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) return void (this.pendingPlayState = "running"); if (this.isStopped) return; const { driver: e = cd, onPlay: t } = this.options; this.driver || (this.driver = e((e => this.tick(e)))), t && t(); const n = this.driver.now(); null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime && "finished" !== this.state || (this.startTime = n), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; this._resolved ? (this.state = "paused", this.holdTime = null !== (e = this.currentTime) && void 0 !== e ? e : 0) : this.pendingPlayState = "paused" } complete() { "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: e } = this.options; e && e() } cancel() { null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } } const fd = e => Array.isArray(e) && "number" === typeof e[0]; function pd(e) { return Boolean(!e || "string" === typeof e && e in gd || fd(e) || Array.isArray(e) && e.every(pd)) } const md = e => { let [t, n, r, i] = e; return "cubic-bezier(".concat(t, ", ").concat(n, ", ").concat(r, ", ").concat(i, ")") }, gd = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: md([0, .65, .55, 1]), circOut: md([.55, 0, 1, .45]), backIn: md([.31, .01, .66, -.59]), backOut: md([.33, 1.53, .69, .99]) }; function vd(e) { return yd(e) || gd.easeOut } function yd(e) { return e ? fd(e) ? md(e) : Array.isArray(e) ? e.map(vd) : gd[e] : void 0 } const bd = function (e) { let t; return () => (void 0 === t && (t = e()), t) }((() => Object.hasOwnProperty.call(Element.prototype, "animate"))), wd = new Set(["opacity", "clipPath", "filter", "transform"]); class xd extends hu { constructor(e) { super(e); const { name: t, motionValue: n, keyframes: r } = this.options; this.resolver = new uu(r, ((e, t) => this.onKeyframesResolved(e, t)), t, n), this.resolver.scheduleResolve() } initPlayback(e, t) { var n; let { duration: r = 300, times: i, ease: s, type: o, motionValue: a, name: l } = this.options; if (!(null === (n = a.owner) || void 0 === n ? void 0 : n.current)) return !1; if (function (e) { return "spring" === e.type || "backgroundColor" === e.name || !pd(e.ease) }(this.options)) { const { onComplete: t, onUpdate: n, motionValue: a, ...l } = this.options, c = function (e, t) { const n = new hd({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: e[0] }; const i = []; let s = 0; for (; !r.done && s < 2e4;)r = n.sample(s), i.push(r.value), s += 10; return { times: void 0, keyframes: i, duration: s - 10, ease: "linear" } }(e, l); 1 === (e = c.keyframes).length && (e[1] = e[0]), r = c.duration, i = c.times, s = c.ease, o = "keyframes" } const c = function (e, t, n) { let { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: o = "loop", ease: a, times: l } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const c = { [t]: n }; l && (c.offset = l); const u = yd(a); return Array.isArray(u) && (c.easing = u), e.animate(c, { delay: r, duration: i, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: s + 1, direction: "reverse" === o ? "alternate" : "normal" }) }(a.owner.current, l, e, { ...this.options, duration: r, times: i, ease: s }); return c.startTime = mc.now(), this.pendingTimeline ? (c.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : c.onfinish = () => { const { onComplete: n } = this.options; a.set(hc(e, this.options, t)), n && n(), this.cancel(), this.resolveFinishedPromise() }, { animation: c, duration: r, times: i, type: o, ease: s, keyframes: e } } get duration() { const { resolved: e } = this; if (!e) return 0; const { duration: t } = e; return ic(t) } get time() { const { resolved: e } = this; if (!e) return 0; const { animation: t } = e; return ic(t.currentTime || 0) } set time(e) { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.currentTime = rc(e) } get speed() { const { resolved: e } = this; if (!e) return 1; const { animation: t } = e; return t.playbackRate } set speed(e) { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.playbackRate = e } get state() { const { resolved: e } = this; if (!e) return "idle"; const { animation: t } = e; return t.playState } attachTimeline(e) { if (this._resolved) { const { resolved: t } = this; if (!t) return Cl; const { animation: n } = t; n.timeline = e, n.onfinish = null } else this.pendingTimeline = e; return Cl } play() { if (this.isStopped) return; const { resolved: e } = this; if (!e) return; const { animation: t } = e; "finished" === t.playState && this.updateFinishedPromise(), t.play() } pause() { const { resolved: e } = this; if (!e) return; const { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; const { resolved: e } = this; if (!e) return; const { animation: t, keyframes: n, duration: r, type: i, ease: s, times: o } = e; if ("idle" !== t.playState && "finished" !== t.playState) { if (this.time) { const { motionValue: e, onUpdate: t, onComplete: a, ...l } = this.options, c = new hd({ ...l, keyframes: n, duration: r, type: i, ease: s, times: o, isGenerator: !0 }), u = rc(this.time); e.setWithVelocity(c.sample(u - 10).value, c.sample(u).value, 10) } this.cancel() } } complete() { const { resolved: e } = this; e && e.animation.finish() } cancel() { const { resolved: e } = this; e && e.animation.cancel() } static supports(e) { const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: s, type: o } = e; return bd() && n && wd.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && "mirror" !== i && 0 !== s && "inertia" !== o } } const Ed = function (e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = arguments.length > 4 ? arguments[4] : void 0, s = arguments.length > 5 ? arguments[5] : void 0; return o => { const a = cc(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: c = 0 } = r; c -= rc(l); let u = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -c, onUpdate: e => { t.set(e), a.onUpdate && a.onUpdate(e) }, onComplete: () => { o(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: s ? void 0 : i }; (function (e) { let { when: t, delay: n, delayChildren: r, staggerChildren: i, staggerDirection: s, repeat: o, repeatType: a, repeatDelay: l, from: c, elapsed: u, ...d } = e; return !!Object.keys(d).length })(a) || (u = { ...u, ...lc(e, u) }), u.duration && (u.duration = rc(u.duration)), u.repeatDelay && (u.repeatDelay = rc(u.repeatDelay)), void 0 !== u.from && (u.keyframes[0] = u.from); let d = !1; if ((!1 === u.type || 0 === u.duration && !u.repeatDelay) && (u.duration = 0, 0 === u.delay && (d = !0)), (uc || Wo) && (d = !0, u.duration = 0, u.delay = 0), d && !s && void 0 !== t.get()) { const e = hc(u.keyframes, a); if (void 0 !== e) return void Tl.update((() => { u.onUpdate(e), u.onComplete() })) } return !s && xd.supports(u) ? new xd(u) : new hd(u) } }; function Sd(e) { return Boolean(Ea(e) && e.add) } function Nd(e, t) { -1 === e.indexOf(t) && e.push(t) } function Cd(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class Td { constructor() { this.subscriptions = [] } add(e) { return Nd(this.subscriptions, e), () => Cd(this.subscriptions, e) } notify(e, t, n) { const r = this.subscriptions.length; if (r) if (1 === r) this.subscriptions[0](e, t, n); else for (let i = 0; i < r; i++) { const r = this.subscriptions[i]; r && r(e, t, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Ad = { current: void 0 }; class kd { constructor(e) { var t = this; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; var r; this.version = "11.1.9", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = function (e) { let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const r = mc.now(); t.updatedAt !== r && t.setPrevFrameValue(), t.prev = t.current, t.setCurrent(e), t.current !== t.prev && t.events.change && t.events.change.notify(t.current), n && t.events.renderRequest && t.events.renderRequest.notify(t.current) }, this.hasAnimated = !1, this.setCurrent(e), this.canTrackVelocity = (r = this.current, !isNaN(parseFloat(r))), this.owner = n.owner } setCurrent(e) { this.current = e, this.updatedAt = mc.now() } setPrevFrameValue() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current; this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new Td); const n = this.events[e].add(t); return "change" === e ? () => { n(), Tl.read((() => { this.events.change.getSize() || this.stop() })) } : n } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; t && this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e, t) } setWithVelocity(e, t, n) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n } jump(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return Ad.current && Ad.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { const e = mc.now(); if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0; const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30); return fu(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise((t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() })).then((() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() })) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function jd(e, t) { return new kd(e, t) } function Pd(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, jd(n)) } function Id(e, t) { let { protectedKeys: n, needsAnimating: r } = e; const i = n.hasOwnProperty(t) && !0 !== r[t]; return r[t] = !1, i } function Rd(e, t) { let { delay: n = 0, transitionOverride: r, type: i } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; var s; let { transition: o = e.getDefaultTransition(), transitionEnd: a, ...l } = t; const c = e.getValue("willChange"); r && (o = r); const u = [], d = i && e.animationState && e.animationState.getState()[i]; for (const h in l) { const t = e.getValue(h, null !== (s = e.latestValues[h]) && void 0 !== s ? s : null), r = l[h]; if (void 0 === r || d && Id(d, h)) continue; const i = { delay: n, elapsed: 0, ...cc(o || {}, h) }; let a = !1; if (window.HandoffAppearAnimations) { const t = e.getProps()[Ho]; if (t) { const e = window.HandoffAppearAnimations(t, h); null !== e && (i.elapsed = e, a = !0) } } t.start(Ed(h, t, r, e.shouldReduceMotion && wa.has(h) ? { type: !1 } : i, e, a)); const f = t.animation; f && (Sd(c) && (c.add(h), f.then((() => c.remove(h)))), u.push(f)) } return a && Promise.all(u).then((() => { Tl.update((() => { a && function (e, t) { const n = nc(e, t); let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {}; s = { ...s, ...r }; for (const o in s) Pd(e, o, xl(s[o])) }(e, a) })) })), u } function Od(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; var r; const i = nc(e, t, "exit" === n.type ? null === (r = e.presenceContext) || void 0 === r ? void 0 : r.custom : void 0); let { transition: s = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (s = n.transitionOverride); const o = i ? () => Promise.all(Rd(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? function () { let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const { delayChildren: i = 0, staggerChildren: o, staggerDirection: a } = s; return function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, s = arguments.length > 5 ? arguments[5] : void 0; const o = [], a = (e.variantChildren.size - 1) * r, l = 1 === i ? function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) * r } : function () { return a - (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) * r }; return Array.from(e.variantChildren).sort(Dd).forEach(((e, r) => { e.notify("AnimationStart", t), o.push(Od(e, t, { ...s, delay: n + l(r) }).then((() => e.notify("AnimationComplete", t)))) })), Promise.all(o) }(e, t, i + r, o, a, n) } : () => Promise.resolve(), { when: l } = s; if (l) { const [e, t] = "beforeChildren" === l ? [o, a] : [a, o]; return e().then((() => t())) } return Promise.all([o(), a(n.delay)]) } function Dd(e, t) { return e.sortNodePosition(t) } const _d = [...na].reverse(), Md = na.length; function Ld(e) { return t => Promise.all(t.map((t => { let { animation: n, options: r } = t; return function (e, t) { let n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (e.notify("AnimationStart", t), Array.isArray(t)) { const i = t.map((t => Od(e, t, r))); n = Promise.all(i) } else if ("string" === typeof t) n = Od(e, t, r); else { const i = "function" === typeof t ? nc(e, t, r.custom) : t; n = Promise.all(Rd(e, i, r)) } return n.then((() => { Tl.postRender((() => { e.notify("AnimationComplete", t) })) })) }(e, n, r) }))) } function Fd(e) { let t = Ld(e); const n = { animate: Bd(!0), whileInView: Bd(), whileHover: Bd(), whileTap: Bd(), whileDrag: Bd(), whileFocus: Bd(), exit: Bd() }; let r = !0; const i = t => (n, r) => { var i; const s = nc(e, r, "exit" === t ? null === (i = e.presenceContext) || void 0 === i ? void 0 : i.custom : void 0); if (s) { const { transition: e, transitionEnd: t, ...r } = s; n = { ...n, ...r, ...t } } return n }; function s(s) { const o = e.getProps(), a = e.getVariantContext(!0) || {}, l = [], c = new Set; let u = {}, d = 1 / 0; for (let t = 0; t < Md; t++) { const h = _d[t], f = n[h], p = void 0 !== o[h] ? o[h] : a[h], m = ea(p), g = h === s ? f.isActive : null; !1 === g && (d = t); let v = p === a[h] && p !== o[h] && m; if (v && r && e.manuallyAnimateOnMount && (v = !1), f.protectedKeys = { ...u }, !f.isActive && null === g || !p && !f.prevProp || ta(p) || "boolean" === typeof p) continue; let y = Ud(f.prevProp, p) || h === s && f.isActive && !v && m || t > d && m, b = !1; const w = Array.isArray(p) ? p : [p]; let x = w.reduce(i(h), {}); !1 === g && (x = {}); const { prevResolvedValues: E = {} } = f, S = { ...E, ...x }, N = t => { y = !0, c.has(t) && (b = !0, c.delete(t)), f.needsAnimating[t] = !0; const n = e.getValue(t); n && (n.liveStyle = !1) }; for (const e in S) { const t = x[e], n = E[e]; if (u.hasOwnProperty(e)) continue; let r = !1; r = bl(t) && bl(n) ? !tc(t, n) : t !== n, r ? void 0 !== t && null !== t ? N(e) : c.add(e) : void 0 !== t && c.has(e) ? N(e) : f.protectedKeys[e] = !0 } f.prevProp = p, f.prevResolvedValues = x, f.isActive && (u = { ...u, ...x }), r && e.blockInitialAnimation && (y = !1), !y || v && !b || l.push(...w.map((e => ({ animation: e, options: { type: h } })))) } if (c.size) { const t = {}; c.forEach((n => { const r = e.getBaseTarget(n), i = e.getValue(n); i && (i.liveStyle = !0), t[n] = null !== r && void 0 !== r ? r : null })), l.push({ animation: t }) } let h = Boolean(l.length); return !r || !1 !== o.initial && o.initial !== o.animate || e.manuallyAnimateOnMount || (h = !1), r = !1, h ? t(l) : Promise.resolve() } return { animateChanges: s, setActive: function (t, r) { var i; if (n[t].isActive === r) return Promise.resolve(); null === (i = e.variantChildren) || void 0 === i || i.forEach((e => { var n; return null === (n = e.animationState) || void 0 === n ? void 0 : n.setActive(t, r) })), n[t].isActive = r; const o = s(t); for (const e in n) n[e].protectedKeys = {}; return o }, setAnimateFunction: function (n) { t = n(e) }, getState: () => n } } function Ud(e, t) { return "string" === typeof t ? t !== e : !!Array.isArray(t) && !tc(t, e) } function Bd() { return { isActive: arguments.length > 0 && void 0 !== arguments[0] && arguments[0], protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } let Vd = 0; const zd = { animation: { Feature: class extends Hl { constructor(e) { super(e), e.animationState || (e.animationState = Fd(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); this.unmount(), ta(e) && (this.unmount = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { } } }, exit: { Feature: class extends Hl { constructor() { super(...arguments), this.id = Vd++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === n) return; const r = this.node.animationState.setActive("exit", !e); t && !e && r.then((() => t(this.id))) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } } }, qd = (e, t) => Math.abs(e - t); class Hd { constructor(e, t) { let { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!this.lastMoveEvent || !this.lastMoveEventInfo) return; const e = Gd(this.lastMoveEventInfo, this.history), t = null !== this.startEvent, n = function (e, t) { const n = qd(e.x, t.x), r = qd(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) }(e.offset, { x: 0, y: 0 }) >= 3; if (!t && !n) return; const { point: r } = e, { timestamp: i } = kl; this.history.push({ ...r, timestamp: i }); const { onStart: s, onMove: o } = this.handlers; t || (s && s(this.lastMoveEvent, e), this.startEvent = this.lastMoveEvent), o && o(this.lastMoveEvent, e) }, this.handlePointerMove = (e, t) => { this.lastMoveEvent = e, this.lastMoveEventInfo = Wd(t, this.transformPagePoint), Tl.update(this.updatePoint, !0) }, this.handlePointerUp = (e, t) => { this.end(); const { onEnd: n, onSessionEnd: r, resumeAnimation: i } = this.handlers; if (this.dragSnapToOrigin && i && i(), !this.lastMoveEvent || !this.lastMoveEventInfo) return; const s = Gd("pointercancel" === e.type ? this.lastMoveEventInfo : Wd(t, this.transformPagePoint), this.history); this.startEvent && n && n(e, s), r && r(e, s) }, !Ol(e)) return; this.dragSnapToOrigin = i, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || window; const s = Wd(Dl(e), this.transformPagePoint), { point: o } = s, { timestamp: a } = kl; this.history = [{ ...o, timestamp: a }]; const { onSessionStart: l } = t; l && l(e, Gd(s, this.history)), this.removeListeners = Fl(Ml(this.contextWindow, "pointermove", this.handlePointerMove), Ml(this.contextWindow, "pointerup", this.handlePointerUp), Ml(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), Al(this.updatePoint) } } function Wd(e, t) { return t ? { point: t(e.point) } : e } function Kd(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Gd(e, t) { let { point: n } = e; return { point: n, delta: Kd(n, Yd(t)), offset: Kd(n, Qd(t)), velocity: Jd(t, .1) } } function Qd(e) { return e[0] } function Yd(e) { return e[e.length - 1] } function Jd(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const i = Yd(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > rc(t)));)n--; if (!r) return { x: 0, y: 0 }; const s = ic(i.timestamp - r.timestamp); if (0 === s) return { x: 0, y: 0 }; const o = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function Xd(e) { return e.max - e.min } function Zd(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .01; return Math.abs(e - t) <= n } function $d(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5; e.origin = r, e.originPoint = Gu(t.min, t.max, e.origin), e.scale = Xd(n) / Xd(t), (Zd(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = Gu(n.min, n.max, e.origin) - e.originPoint, (Zd(e.translate) || isNaN(e.translate)) && (e.translate = 0) } function eh(e, t, n, r) { $d(e.x, t.x, n.x, r ? r.originX : void 0), $d(e.y, t.y, n.y, r ? r.originY : void 0) } function th(e, t, n) { e.min = n.min + t.min, e.max = e.min + Xd(t) } function nh(e, t, n) { e.min = t.min - n.min, e.max = e.min + Xd(t) } function rh(e, t, n) { nh(e.x, t.x, n.x), nh(e.y, t.y, n.y) } function ih(e, t, n) { return { min: void 0 !== t ? e.min + t : void 0, max: void 0 !== n ? e.max + n - (e.max - e.min) : void 0 } } function sh(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } const oh = .35; function ah(e, t, n) { return { min: lh(e, t), max: lh(e, n) } } function lh(e, t) { return "number" === typeof e ? e : e[t] || 0 } const ch = () => ({ x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } }), uh = () => ({ x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }); function dh(e) { return [e("x"), e("y")] } function hh(e) { let { top: t, left: n, right: r, bottom: i } = e; return { x: { min: n, max: r }, y: { min: t, max: i } } } function fh(e) { return void 0 === e || 1 === e } function ph(e) { let { scale: t, scaleX: n, scaleY: r } = e; return !fh(t) || !fh(n) || !fh(r) } function mh(e) { return ph(e) || gh(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function gh(e) { return vh(e.x) || vh(e.y) } function vh(e) { return e && "0%" !== e } function yh(e, t, n) { return n + t * (e - n) } function bh(e, t, n, r, i) { return void 0 !== i && (e = yh(e, i, r)), yh(e, n, r) + t } function wh(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0; e.min = bh(e.min, t, n, r, i), e.max = bh(e.max, t, n, r, i) } function xh(e, t) { let { x: n, y: r } = t; wh(e.x, n.translate, n.scale, n.originPoint), wh(e.y, r.translate, r.scale, r.originPoint) } function Eh(e) { return Number.isInteger(e) || e > 1.0000000000001 || e < .999999999999 ? e : 1 } function Sh(e, t) { e.min = e.min + t, e.max = e.max + t } function Nh(e, t, n) { let [r, i, s] = n; const o = void 0 !== t[s] ? t[s] : .5, a = Gu(e.min, e.max, o); wh(e, t[r], t[i], a, t.scale) } const Ch = ["x", "scaleX", "originX"], Th = ["y", "scaleY", "originY"]; function Ah(e, t) { Nh(e.x, t, Ch), Nh(e.y, t, Th) } function kh(e, t) { return hh(function (e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } }(e.getBoundingClientRect(), t)) } const jh = e => { let { current: t } = e; return t ? t.ownerDocument.defaultView : null }, Ph = new WeakMap; class Ih { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = uh(), this.visualElement = e } start(e) { let { snapToCursor: t = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const { presenceContext: n } = this.visualElement; if (n && !1 === n.isPresent) return; const { dragSnapToOrigin: r } = this.getProps(); this.panSession = new Hd(e, { onSessionStart: e => { const { dragSnapToOrigin: n } = this.getProps(); n ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(Dl(e, "page").point) }, onStart: (e, t) => { const { drag: n, dragPropagation: r, onDragStart: i } = this.getProps(); if (n && !r && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = zl(n), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), dh((e => { let t = this.getAxisMotionValue(e).get() || 0; if (za.test(t)) { const { projection: n } = this.visualElement; if (n && n.layout) { const r = n.layout.layoutBox[e]; if (r) { t = Xd(r) * (parseFloat(t) / 100) } } } this.originPoint[e] = t })), i && Tl.postRender((() => i(e, t))); const { animationState: s } = this.visualElement; s && s.setActive("whileDrag", !0) }, onMove: (e, t) => { const { dragPropagation: n, dragDirectionLock: r, onDirectionLock: i, onDrag: s } = this.getProps(); if (!n && !this.openGlobalLock) return; const { offset: o } = t; if (r && null === this.currentDirection) return this.currentDirection = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, n = null; Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"); return n }(o), void (null !== this.currentDirection && i && i(this.currentDirection)); this.updateAxis("x", t.point, o), this.updateAxis("y", t.point, o), this.visualElement.render(), s && s(e, t) }, onSessionEnd: (e, t) => this.stop(e, t), resumeAnimation: () => dh((e => { var t; return "paused" === this.getAnimationState(e) && (null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.play()) })) }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: r, contextWindow: jh(this.visualElement) }) } stop(e, t) { const n = this.isDragging; if (this.cancel(), !n) return; const { velocity: r } = t; this.startAnimation(r); const { onDragEnd: i } = this.getProps(); i && Tl.postRender((() => i(e, t))) } cancel() { this.isDragging = !1; const { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: n } = this.getProps(); !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, n) { const { drag: r } = this.getProps(); if (!n || !Rh(e, r, this.currentDirection)) return; const i = this.getAxisMotionValue(e); let s = this.originPoint[e] + n[e]; this.constraints && this.constraints[e] && (s = function (e, t, n) { let { min: r, max: i } = t; return void 0 !== r && e < r ? e = n ? Gu(r, e, n.min) : Math.max(e, r) : void 0 !== i && e > i && (e = n ? Gu(i, e, n.max) : Math.min(e, i)), e }(s, this.constraints[e], this.elastic[e])), i.set(s) } resolveConstraints() { var e; const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (e = this.visualElement.projection) || void 0 === e ? void 0 : e.layout, i = this.constraints; t && Zo(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!t || !r) && function (e, t) { let { top: n, left: r, bottom: i, right: s } = t; return { x: ih(e.x, r, s), y: ih(e.y, n, i) } }(r.layoutBox, t), this.elastic = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oh; return !1 === e ? e = 0 : !0 === e && (e = oh), { x: ah(e, "left", "right"), y: ah(e, "top", "bottom") } }(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && dh((e => { !1 !== this.constraints && this.getAxisMotionValue(e) && (this.constraints[e] = function (e, t) { const n = {}; return void 0 !== t.min && (n.min = t.min - e.min), void 0 !== t.max && (n.max = t.max - e.min), n }(r.layoutBox[e], this.constraints[e])) })) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !Zo(e)) return !1; const n = e.current; yc(null !== n, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); const { projection: r } = this.visualElement; if (!r || !r.layout) return !1; const i = function (e, t, n) { const r = kh(e, n), { scroll: i } = t; return i && (Sh(r.x, i.offset.x), Sh(r.y, i.offset.y)), r }(n, r.root, this.visualElement.getTransformPagePoint()); let s = function (e, t) { return { x: sh(e.x, t.x), y: sh(e.y, t.y) } }(r.layout.layoutBox, i); if (t) { const e = t(function (e) { let { x: t, y: n } = e; return { top: n.min, right: t.max, bottom: n.max, left: t.min } }(s)); this.hasMutatedConstraints = !!e, e && (s = hh(e)) } return s } startAnimation(e) { const { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: s, onDragTransitionEnd: o } = this.getProps(), a = this.constraints || {}, l = dh((o => { if (!Rh(o, t, this.currentDirection)) return; let l = a && a[o] || {}; s && (l = { min: 0, max: 0 }); const c = r ? 200 : 1e6, u = r ? 40 : 1e7, d = { type: "inertia", velocity: n ? e[o] : 0, bounceStiffness: c, bounceDamping: u, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...l }; return this.startAxisValueAnimation(o, d) })); return Promise.all(l).then(o) } startAxisValueAnimation(e, t) { const n = this.getAxisMotionValue(e); return n.start(Ed(e, n, 0, t, this.visualElement)) } stopAnimation() { dh((e => this.getAxisMotionValue(e).stop())) } pauseAnimation() { dh((e => { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.pause() })) } getAnimationState(e) { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.state } getAxisMotionValue(e) { const t = "_drag".concat(e.toUpperCase()), n = this.visualElement.getProps(), r = n[t]; return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0) } snapToCursor(e) { dh((t => { const { drag: n } = this.getProps(); if (!Rh(t, n, this.currentDirection)) return; const { projection: r } = this.visualElement, i = this.getAxisMotionValue(t); if (r && r.layout) { const { min: n, max: s } = r.layout.layoutBox[t]; i.set(e[t] - Gu(n, s, .5)) } })) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement; if (!Zo(t) || !n || !this.constraints) return; this.stopAnimation(); const r = { x: 0, y: 0 }; dh((e => { const t = this.getAxisMotionValue(e); if (t && !1 !== this.constraints) { const n = t.get(); r[e] = function (e, t) { let n = .5; const r = Xd(e), i = Xd(t); return i > r ? n = Ku(t.min, t.max - r, e.min) : r > i && (n = Ku(e.min, e.max - i, t.min)), Ia(0, 1, n) }({ min: n, max: n }, this.constraints[e]) } })); const { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), dh((t => { if (!Rh(t, e, null)) return; const n = this.getAxisMotionValue(t), { min: i, max: s } = this.constraints[t]; n.set(Gu(i, s, r[t])) })) } addListeners() { if (!this.visualElement.current) return; Ph.set(this.visualElement, this); const e = Ml(this.visualElement.current, "pointerdown", (e => { const { drag: t, dragListener: n = !0 } = this.getProps(); t && n && this.start(e) })), t = () => { const { dragConstraints: e } = this.getProps(); Zo(e) && (this.constraints = this.resolveRefConstraints()) }, { projection: n } = this.visualElement, r = n.addEventListener("measure", t); n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), t(); const i = Rl(window, "resize", (() => this.scalePositionWithinConstraints())), s = n.addEventListener("didUpdate", (e => { let { delta: t, hasLayoutChanged: n } = e; this.isDragging && n && (dh((e => { const n = this.getAxisMotionValue(e); n && (this.originPoint[e] += t[e].translate, n.set(n.get() + t[e].translate)) })), this.visualElement.render()) })); return () => { i(), e(), r(), s && s() } } getProps() { const e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: s = oh, dragMomentum: o = !0 } = e; return { ...e, drag: t, dragDirectionLock: n, dragPropagation: r, dragConstraints: i, dragElastic: s, dragMomentum: o } } } function Rh(e, t, n) { return (!0 === t || t === e) && (null === n || n === e) } const Oh = e => (t, n) => { e && Tl.postRender((() => e(t, n))) }; const Dh = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function _h(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const Mh = { correct: (e, t) => { if (!t.target) return e; if ("string" === typeof e) { if (!qa.test(e)) return e; e = parseFloat(e) } const n = _h(e, t.target.x), r = _h(e, t.target.y); return "".concat(n, "% ").concat(r, "%") } }, Lh = { correct: (e, t) => { let { treeScale: n, projectionDelta: r } = t; const i = e, s = tu.parse(e); if (s.length > 5) return i; const o = tu.createTransformer(e), a = "number" !== typeof s[0] ? 1 : 0, l = r.x.scale * n.x, c = r.y.scale * n.y; s[0 + a] /= l, s[1 + a] /= c; const u = Gu(l, c, .5); return "number" === typeof s[2 + a] && (s[2 + a] /= u), "number" === typeof s[3 + a] && (s[3 + a] /= u), o(s) } }; class Fh extends r.Component { componentDidMount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: i } = e; var s; s = Bh, Object.assign(ya, s), i && (t.group && t.group.add(i), n && n.register && r && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", (() => { this.safeToRemove() })), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), Dh.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props, s = n.projection; return s ? (s.isPresent = i, r || e.layoutDependency !== t || void 0 === t ? s.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? s.promote() : s.relegate() || Tl.postRender((() => { const e = s.getStack(); e && e.members.length || this.safeToRemove() }))), null) : null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), Jo.postRender((() => { !e.currentAnimation && e.isLead() && this.safeToRemove() }))) } componentWillUnmount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function Uh(e) { const [t, n] = function () { const e = (0, r.useContext)(Uo); if (null === e) return [!0, null]; const { isPresent: t, onExitComplete: n, register: i } = e, s = (0, r.useId)(); return (0, r.useEffect)((() => i(s)), []), !t && n ? [!1, () => n && n(s)] : [!0] }(), i = (0, r.useContext)(ua); return (0, Ve.jsx)(Fh, { ...e, layoutGroup: i, switchLayoutGroup: (0, r.useContext)(da), isPresent: t, safeToRemove: n }) } const Bh = { borderRadius: { ...Mh, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Mh, borderTopRightRadius: Mh, borderBottomLeftRadius: Mh, borderBottomRightRadius: Mh, boxShadow: Lh }, Vh = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], zh = Vh.length, qh = e => "string" === typeof e ? parseFloat(e) : e, Hh = e => "number" === typeof e || qa.test(e); function Wh(e, t) { return void 0 !== e[t] ? e[t] : e.borderRadius } const Kh = Qh(0, .5, Uu), Gh = Qh(.5, .95, Cl); function Qh(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(Ku(e, t, r)) } function Yh(e, t) { e.min = t.min, e.max = t.max } function Jh(e, t) { Yh(e.x, t.x), Yh(e.y, t.y) } function Xh(e, t, n, r, i) { return e = yh(e -= t, 1 / n, r), void 0 !== i && (e = yh(e, 1 / i, r)), e } function Zh(e, t, n, r, i) { let [s, o, a] = n; !function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5, i = arguments.length > 4 ? arguments[4] : void 0, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : e, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : e; za.test(t) && (t = parseFloat(t), t = Gu(o.min, o.max, t / 100) - o.min); if ("number" !== typeof t) return; let a = Gu(s.min, s.max, r); e === s && (a -= t), e.min = Xh(e.min, t, n, a, i), e.max = Xh(e.max, t, n, a, i) }(e, t[s], t[o], t[a], t.scale, r, i) } const $h = ["x", "scaleX", "originX"], ef = ["y", "scaleY", "originY"]; function tf(e, t, n, r) { Zh(e.x, t, $h, n ? n.x : void 0, r ? r.x : void 0), Zh(e.y, t, ef, n ? n.y : void 0, r ? r.y : void 0) } function nf(e) { return 0 === e.translate && 1 === e.scale } function rf(e) { return nf(e.x) && nf(e.y) } function sf(e, t) { return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max) } function of(e) { return Xd(e.x) / Xd(e.y) } class af { constructor() { this.members = [] } add(e) { Nd(this.members, e), e.scheduleRender() } remove(e) { if (Cd(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const e = this.members[this.members.length - 1]; e && this.promote(e) } } relegate(e) { const t = this.members.findIndex((t => e === t)); if (0 === t) return !1; let n; for (let r = t; r >= 0; r--) { const e = this.members[r]; if (!1 !== e.isPresent) { n = e; break } } return !!n && (this.promote(n), !0) } promote(e, t) { const n = this.lead; if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) { n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: r } = e.options; !1 === r && n.hide() } } exitAnimationComplete() { this.members.forEach((e => { const { options: t, resumingFrom: n } = e; t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() })) } scheduleRender() { this.members.forEach((e => { e.instance && e.scheduleRender(!1) })) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function lf(e, t, n) { let r = ""; const i = e.x.translate / t.x, s = e.y.translate / t.y, o = (null === n || void 0 === n ? void 0 : n.z) || 0; if ((i || s || o) && (r = "translate3d(".concat(i, "px, ").concat(s, "px, ").concat(o, "px) ")), 1 === t.x && 1 === t.y || (r += "scale(".concat(1 / t.x, ", ").concat(1 / t.y, ") ")), n) { const { transformPerspective: e, rotate: t, rotateX: i, rotateY: s, skewX: o, skewY: a } = n; e && (r = "perspective(".concat(e, "px) ").concat(r)), t && (r += "rotate(".concat(t, "deg) ")), i && (r += "rotateX(".concat(i, "deg) ")), s && (r += "rotateY(".concat(s, "deg) ")), o && (r += "skewX(".concat(o, "deg) ")), a && (r += "skewY(".concat(a, "deg) ")) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return 1 === a && 1 === l || (r += "scale(".concat(a, ", ").concat(l, ")")), r || "none" } const cf = (e, t) => e.depth - t.depth; class uf { constructor() { this.children = [], this.isDirty = !1 } add(e) { Nd(this.children, e), this.isDirty = !0 } remove(e) { Cd(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(cf), this.isDirty = !1, this.children.forEach(e) } } const df = ["", "X", "Y", "Z"], hf = { visibility: "hidden" }; let ff = 0; const pf = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function mf(e, t, n, r) { const { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function gf(e) { let { attachResizeListener: t, defaultParent: n, measureScroll: r, checkIsScrollRoot: i, resetTransform: s } = e; return class { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null === n || void 0 === n ? void 0 : n(); this.id = ff++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { var e; this.projectionUpdateScheduled = !1, pf.totalNodes = pf.resolvedTargetDeltas = pf.recalculatedProjection = 0, this.nodes.forEach(bf), this.nodes.forEach(Tf), this.nodes.forEach(Af), this.nodes.forEach(wf), e = pf, window.MotionDebug && window.MotionDebug.record(e) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = e, this.root = t ? t.root || t : this, this.path = t ? [...t.path, t] : [], this.parent = t, this.depth = t ? t.depth + 1 : 0; for (let n = 0; n < this.path.length; n++)this.path[n].shouldResetTransform = !0; this.root === this && (this.nodes = new uf) } addEventListener(e, t) { return this.eventHandlers.has(e) || this.eventHandlers.set(e, new Td), this.eventHandlers.get(e).add(t) } notifyListeners(e) { const t = this.eventHandlers.get(e); for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; t && t.notify(...r) } hasListeners(e) { return this.eventHandlers.has(e) } mount(e) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.root.hasTreeAnimated; if (this.instance) return; var r; this.isSVG = (r = e) instanceof SVGElement && "svg" !== r.tagName, this.instance = e; const { layoutId: i, layout: s, visualElement: o } = this.options; if (o && !o.current && o.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), n && (s || i) && (this.isLayoutDirty = !0), t) { let n; const r = () => this.root.updateBlockedByResize = !1; t(e, (() => { this.root.updateBlockedByResize = !0, n && n(), n = function (e, t) { const n = mc.now(), r = i => { let { timestamp: s } = i; const o = s - n; o >= t && (Al(r), e(o - t)) }; return Tl.read(r, !0), () => Al(r) }(r, 250), Dh.hasAnimatedSinceResize && (Dh.hasAnimatedSinceResize = !1, this.nodes.forEach(Cf)) })) } i && this.root.registerSharedNode(i, this), !1 !== this.options.animate && o && (i || s) && this.addEventListener("didUpdate", (e => { let { delta: t, hasLayoutChanged: n, hasRelativeTargetChanged: r, layout: i } = e; if (this.isTreeAnimationBlocked()) return this.target = void 0, void (this.relativeTarget = void 0); const s = this.options.transition || o.getDefaultTransition() || Of, { onLayoutAnimationStart: a, onLayoutAnimationComplete: l } = o.getProps(), c = !this.targetLayout || !sf(this.targetLayout, i) || r, u = !n && r; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || n && (c || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, u); const e = { ...cc(s, "layout"), onPlay: a, onComplete: l }; (o.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e) } else n || Cf(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = i })) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const e = this.getStack(); e && e.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Al(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(kf), this.animationId++) } getTransformTemplate() { const { visualElement: e } = this.options; return e && e.getProps().transformTemplate } willUpdate() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) return void (this.options.onExitComplete && this.options.onExitComplete()); if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let i = 0; i < this.path.length; i++) { const e = this.path[i]; e.shouldResetTransform = !0, e.updateScroll("snapshot"), e.options.layoutRoot && e.willUpdate(!1) } const { layoutId: t, layout: n } = this.options; if (void 0 === t && !n) return; const r = this.getTransformTemplate(); this.prevTransformTemplateValue = r ? r(this.latestValues, "") : void 0, this.updateSnapshot(), e && this.notifyListeners("willUpdate") } update() { this.updateScheduled = !1; if (this.isUpdateBlocked()) return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach(Ef); this.isUpdating || this.nodes.forEach(Sf), this.isUpdating = !1, window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(), this.nodes.forEach(Nf), this.nodes.forEach(vf), this.nodes.forEach(yf), this.clearAllSnapshots(); const e = mc.now(); kl.delta = Ia(0, 1e3 / 60, e - kl.timestamp), kl.timestamp = e, kl.isProcessing = !0, jl.update.process(kl), jl.preRender.process(kl), jl.render.process(kl), kl.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Jo.read((() => this.update()))) } clearAllSnapshots() { this.nodes.forEach(xf), this.sharedNodes.forEach(jf) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Tl.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Tl.postRender((() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() })) } updateSnapshot() { !this.snapshot && this.instance && (this.snapshot = this.measure()) } updateLayout() { if (!this.instance) return; if (this.updateScroll(), (!this.options.alwaysMeasureLayout || !this.isLead()) && !this.isLayoutDirty) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let n = 0; n < this.path.length; n++) { this.path[n].updateScroll() } const e = this.layout; this.layout = this.measure(!1), this.layoutCorrected = uh(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: t } = this.options; t && t.notify("LayoutMeasure", this.layout.layoutBox, e ? e.layoutBox : void 0) } updateScroll() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "measure", t = Boolean(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === e && (t = !1), t && (this.scroll = { animationId: this.root.animationId, phase: e, isRoot: i(this.instance), offset: r(this.instance) }) } resetTransform() { if (!s) return; const e = this.isLayoutDirty || this.shouldResetTransform, t = this.projectionDelta && !rf(this.projectionDelta), n = this.getTransformTemplate(), r = n ? n(this.latestValues, "") : void 0, i = r !== this.prevTransformTemplateValue; e && (t || mh(this.latestValues) || i) && (s(this.instance, r), this.shouldResetTransform = !1, this.scheduleRender()) } measure() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const t = this.measurePageBox(); let n = this.removeElementScroll(t); var r; return e && (n = this.removeTransform(n)), Mf((r = n).x), Mf(r.y), { animationId: this.root.animationId, measuredBox: t, layoutBox: n, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: e } = this.options; if (!e) return uh(); const t = e.measureViewportBox(), { scroll: n } = this.root; return n && (Sh(t.x, n.offset.x), Sh(t.y, n.offset.y)), t } removeElementScroll(e) { const t = uh(); Jh(t, e); for (let n = 0; n < this.path.length; n++) { const r = this.path[n], { scroll: i, options: s } = r; if (r !== this.root && i && s.layoutScroll) { if (i.isRoot) { Jh(t, e); const { scroll: n } = this.root; n && (Sh(t.x, -n.offset.x), Sh(t.y, -n.offset.y)) } Sh(t.x, i.offset.x), Sh(t.y, i.offset.y) } } return t } applyTransform(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = uh(); Jh(n, e); for (let r = 0; r < this.path.length; r++) { const e = this.path[r]; !t && e.options.layoutScroll && e.scroll && e !== e.root && Ah(n, { x: -e.scroll.offset.x, y: -e.scroll.offset.y }), mh(e.latestValues) && Ah(n, e.latestValues) } return mh(this.latestValues) && Ah(n, this.latestValues), n } removeTransform(e) { const t = uh(); Jh(t, e); for (let n = 0; n < this.path.length; n++) { const e = this.path[n]; if (!e.instance) continue; if (!mh(e.latestValues)) continue; ph(e.latestValues) && e.updateSnapshot(); const r = uh(); Jh(r, e.measurePageBox()), tf(t, e.latestValues, e.snapshot ? e.snapshot.layoutBox : void 0, r) } return mh(this.latestValues) && tf(t, this.latestValues), t } setTargetDelta(e) { this.targetDelta = e, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(e) { this.options = { ...this.options, ...e, crossfade: void 0 === e.crossfade || e.crossfade } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== kl.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; var t; const n = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = n.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = n.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = n.isSharedProjectionDirty); const r = Boolean(this.resumingFrom) || this !== n; if (!(e || r && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty) || this.attemptToResolveRelativeTarget)) return; const { layout: i, layoutId: s } = this.options; if (this.layout && (i || s)) { if (this.resolvedRelativeTargetAt = kl.timestamp, !this.targetDelta && !this.relativeTarget) { const e = this.getClosestProjectingParent(); e && e.layout && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = uh(), this.relativeTargetOrigin = uh(), rh(this.relativeTargetOrigin, this.layout.layoutBox, e.layout.layoutBox), Jh(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (this.relativeTarget || this.targetDelta) { var o, a, l; if (this.target || (this.target = uh(), this.targetWithTransforms = uh()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), o = this.target, a = this.relativeTarget, l = this.relativeParent.target, th(o.x, a.x, l.x), th(o.y, a.y, l.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : Jh(this.target, this.layout.layoutBox), xh(this.target, this.targetDelta)) : Jh(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const e = this.getClosestProjectingParent(); e && Boolean(e.resumingFrom) === Boolean(this.resumingFrom) && !e.options.layoutScroll && e.target && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = uh(), this.relativeTargetOrigin = uh(), rh(this.relativeTargetOrigin, this.target, e.target), Jh(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } pf.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (this.parent && !ph(this.parent.latestValues) && !gh(this.parent.latestValues)) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var e; const t = this.getLead(), n = Boolean(this.resumingFrom) || this !== t; let r = !0; if ((this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty)) && (r = !1), n && (this.isSharedProjectionDirty || this.isTransformDirty) && (r = !1), this.resolvedRelativeTargetAt === kl.timestamp && (r = !1), r) return; const { layout: i, layoutId: s } = this.options; if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !i && !s) return; Jh(this.layoutCorrected, this.layout.layoutBox); const o = this.treeScale.x, a = this.treeScale.y; !function (e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const i = n.length; if (!i) return; let s, o; t.x = t.y = 1; for (let a = 0; a < i; a++) { s = n[a], o = s.projectionDelta; const i = s.instance; i && i.style && "contents" === i.style.display || (r && s.options.layoutScroll && s.scroll && s !== s.root && Ah(e, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), o && (t.x *= o.x.scale, t.y *= o.y.scale, xh(e, o)), r && mh(s.latestValues) && Ah(e, s.latestValues)) } t.x = Eh(t.x), t.y = Eh(t.y) }(this.layoutCorrected, this.treeScale, this.path, n), !t.layout || t.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (t.target = t.layout.layoutBox, t.targetWithTransforms = uh()); const { target: l } = t; if (!l) return void (this.projectionTransform && (this.projectionDelta = ch(), this.projectionTransform = "none", this.scheduleRender())); this.projectionDelta || (this.projectionDelta = ch(), this.projectionDeltaWithTransform = ch()); const c = this.projectionTransform; eh(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.projectionTransform = lf(this.projectionDelta, this.treeScale), this.projectionTransform === c && this.treeScale.x === o && this.treeScale.y === a || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l)), pf.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; if (this.options.scheduleRender && this.options.scheduleRender(), e) { const e = this.getStack(); e && e.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = this.snapshot, r = n ? n.latestValues : {}, i = { ...this.latestValues }, s = ch(); this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !t; const o = uh(), a = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0), l = this.getStack(), c = !l || l.members.length <= 1, u = Boolean(a && !c && !0 === this.options.crossfade && !this.path.some(Rf)); let d; this.animationProgress = 0, this.mixTargetDelta = t => { const n = t / 1e3; Pf(s.x, e.x, n), Pf(s.y, e.y, n), this.setTargetDelta(s), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (rh(o, this.layout.layoutBox, this.relativeParent.layout.layoutBox), function (e, t, n, r) { If(e.x, t.x, n.x, r), If(e.y, t.y, n.y, r) }(this.relativeTarget, this.relativeTargetOrigin, o, n), d && function (e, t) { return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max }(this.relativeTarget, d) && (this.isProjectionDirty = !1), d || (d = uh()), Jh(d, this.relativeTarget)), a && (this.animationValues = i, function (e, t, n, r, i, s) { i ? (e.opacity = Gu(0, void 0 !== n.opacity ? n.opacity : 1, Kh(r)), e.opacityExit = Gu(void 0 !== t.opacity ? t.opacity : 1, 0, Gh(r))) : s && (e.opacity = Gu(void 0 !== t.opacity ? t.opacity : 1, void 0 !== n.opacity ? n.opacity : 1, r)); for (let o = 0; o < zh; o++) { const i = "border".concat(Vh[o], "Radius"); let s = Wh(t, i), a = Wh(n, i); void 0 === s && void 0 === a || (s || (s = 0), a || (a = 0), 0 === s || 0 === a || Hh(s) === Hh(a) ? (e[i] = Math.max(Gu(qh(s), qh(a), r), 0), (za.test(a) || za.test(s)) && (e[i] += "%")) : e[i] = a) } (t.rotate || n.rotate) && (e.rotate = Gu(t.rotate || 0, n.rotate || 0, r)) }(i, r, this.latestValues, n, u, c)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(e) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Al(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Tl.update((() => { Dh.hasAnimatedSinceResize = !0, this.currentAnimation = function (e, t, n) { const r = Ea(e) ? e : jd(e); return r.start(Ed("", r, t, n)), r.animation }(0, 1e3, { ...e, onUpdate: t => { this.mixTargetDelta(t), e.onUpdate && e.onUpdate(t) }, onComplete: () => { e.onComplete && e.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 })) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const e = this.getStack(); e && e.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const e = this.getLead(); let { targetWithTransforms: t, target: n, layout: r, latestValues: i } = e; if (t && n && r) { if (this !== e && this.layout && r && Lf(this.options.animationType, this.layout.layoutBox, r.layoutBox)) { n = this.target || uh(); const t = Xd(this.layout.layoutBox.x); n.x.min = e.target.x.min, n.x.max = n.x.min + t; const r = Xd(this.layout.layoutBox.y); n.y.min = e.target.y.min, n.y.max = n.y.min + r } Jh(t, n), Ah(t, i), eh(this.projectionDeltaWithTransform, this.layoutCorrected, t, i) } } registerSharedNode(e, t) { this.sharedNodes.has(e) || this.sharedNodes.set(e, new af); this.sharedNodes.get(e).add(t); const n = t.options.initialPromotionConfig; t.promote({ transition: n ? n.transition : void 0, preserveFollowOpacity: n && n.shouldPreserveFollowOpacity ? n.shouldPreserveFollowOpacity(t) : void 0 }) } isLead() { const e = this.getStack(); return !e || e.lead === this } getLead() { var e; const { layoutId: t } = this.options; return t && (null === (e = this.getStack()) || void 0 === e ? void 0 : e.lead) || this } getPrevLead() { var e; const { layoutId: t } = this.options; return t ? null === (e = this.getStack()) || void 0 === e ? void 0 : e.prevLead : void 0 } getStack() { const { layoutId: e } = this.options; if (e) return this.root.sharedNodes.get(e) } promote() { let { needsReset: e, transition: t, preserveFollowOpacity: n } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const r = this.getStack(); r && r.promote(this, n), e && (this.projectionDelta = void 0, this.needsReset = !0), t && this.setOptions({ transition: t }) } relegate() { const e = this.getStack(); return !!e && e.relegate(this) } resetSkewAndRotation() { const { visualElement: e } = this.options; if (!e) return; let t = !1; const { latestValues: n } = e; if ((n.z || n.rotate || n.rotateX || n.rotateY || n.rotateZ || n.skewX || n.skewY) && (t = !0), !t) return; const r = {}; n.z && mf("z", e, r, this.animationValues); for (let i = 0; i < df.length; i++)mf("rotate".concat(df[i]), e, r, this.animationValues), mf("skew".concat(df[i]), e, r, this.animationValues); e.render(); for (const i in r) e.setStaticValue(i, r[i]), this.animationValues && (this.animationValues[i] = r[i]); e.scheduleRender() } getProjectionStyles(e) { var t, n; if (!this.instance || this.isSVG) return; if (!this.isVisible) return hf; const r = { visibility: "" }, i = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, r.opacity = "", r.pointerEvents = El(null === e || void 0 === e ? void 0 : e.pointerEvents) || "", r.transform = i ? i(this.latestValues, "") : "none", r; const s = this.getLead(); if (!this.projectionDelta || !this.layout || !s.target) { const t = {}; return this.options.layoutId && (t.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, t.pointerEvents = El(null === e || void 0 === e ? void 0 : e.pointerEvents) || ""), this.hasProjected && !mh(this.latestValues) && (t.transform = i ? i({}, "") : "none", this.hasProjected = !1), t } const o = s.animationValues || s.latestValues; this.applyTransformsToTarget(), r.transform = lf(this.projectionDeltaWithTransform, this.treeScale, o), i && (r.transform = i(o, r.transform)); const { x: a, y: l } = this.projectionDelta; r.transformOrigin = "".concat(100 * a.origin, "% ").concat(100 * l.origin, "% 0"), s.animationValues ? r.opacity = s === this ? null !== (n = null !== (t = o.opacity) && void 0 !== t ? t : this.latestValues.opacity) && void 0 !== n ? n : 1 : this.preserveOpacity ? this.latestValues.opacity : o.opacityExit : r.opacity = s === this ? void 0 !== o.opacity ? o.opacity : "" : void 0 !== o.opacityExit ? o.opacityExit : 0; for (const c in ya) { if (void 0 === o[c]) continue; const { correct: e, applyTo: t } = ya[c], n = "none" === r.transform ? o[c] : e(o[c], s); if (t) { const e = t.length; for (let i = 0; i < e; i++)r[t[i]] = n } else r[c] = n } return this.options.layoutId && (r.pointerEvents = s === this ? El(null === e || void 0 === e ? void 0 : e.pointerEvents) || "" : "none"), r } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach((e => { var t; return null === (t = e.currentAnimation) || void 0 === t ? void 0 : t.stop() })), this.root.nodes.forEach(Ef), this.root.sharedNodes.clear() } } } function vf(e) { e.updateLayout() } function yf(e) { var t; const n = (null === (t = e.resumeFrom) || void 0 === t ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { const { layoutBox: t, measuredBox: r } = e.layout, { animationType: i } = e.options, s = n.source !== e.layout.source; "size" === i ? dh((e => { const r = s ? n.measuredBox[e] : n.layoutBox[e], i = Xd(r); r.min = t[e].min, r.max = r.min + i })) : Lf(i, n.layoutBox, t) && dh((r => { const i = s ? n.measuredBox[r] : n.layoutBox[r], o = Xd(t[r]); i.max = i.min + o, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[r].max = e.relativeTarget[r].min + o) })); const o = ch(); eh(o, t, n.layoutBox); const a = ch(); s ? eh(a, e.applyTransform(r, !0), n.measuredBox) : eh(a, t, n.layoutBox); const l = !rf(o); let c = !1; if (!e.resumeFrom) { const r = e.getClosestProjectingParent(); if (r && !r.resumeFrom) { const { snapshot: i, layout: s } = r; if (i && s) { const o = uh(); rh(o, n.layoutBox, i.layoutBox); const a = uh(); rh(a, t, s.layoutBox), sf(o, a) || (c = !0), r.options.layoutRoot && (e.relativeTarget = a, e.relativeTargetOrigin = o, e.relativeParent = r) } } } e.notifyListeners("didUpdate", { layout: t, snapshot: n, delta: a, layoutDelta: o, hasLayoutChanged: l, hasRelativeTargetChanged: c }) } else if (e.isLead()) { const { onExitComplete: t } = e.options; t && t() } e.options.transition = void 0 } function bf(e) { pf.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = Boolean(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function wf(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function xf(e) { e.clearSnapshot() } function Ef(e) { e.clearMeasurements() } function Sf(e) { e.isLayoutDirty = !1 } function Nf(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function Cf(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function Tf(e) { e.resolveTargetDelta() } function Af(e) { e.calcProjection() } function kf(e) { e.resetSkewAndRotation() } function jf(e) { e.removeLeadSnapshot() } function Pf(e, t, n) { e.translate = Gu(t.translate, 0, n), e.scale = Gu(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function If(e, t, n, r) { e.min = Gu(t.min, n.min, r), e.max = Gu(t.max, n.max, r) } function Rf(e) { return e.animationValues && void 0 !== e.animationValues.opacityExit } const Of = { duration: .45, ease: [.4, 0, .1, 1] }, Df = e => "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), _f = Df("applewebkit/") && !Df("chrome/") ? Math.round : Cl; function Mf(e) { e.min = _f(e.min), e.max = _f(e.max) } function Lf(e, t, n) { return "position" === e || "preserve-aspect" === e && !Zd(of(t), of(n), .2) } const Ff = gf({ attachResizeListener: (e, t) => Rl(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Uf = { current: void 0 }, Bf = gf({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Uf.current) { const e = new Ff({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Uf.current = e } return Uf.current }, resetTransform: (e, t) => { e.style.transform = void 0 !== t ? t : "none" }, checkIsScrollRoot: e => Boolean("fixed" === window.getComputedStyle(e).position) }), Vf = { pan: { Feature: class extends Hl { constructor() { super(...arguments), this.removePointerDownListener = Cl } onPointerDown(e) { this.session = new Hd(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: jh(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Oh(e), onStart: Oh(t), onMove: n, onEnd: (e, t) => { delete this.session, r && Tl.postRender((() => r(e, t))) } } } mount() { this.removePointerDownListener = Ml(this.node.current, "pointerdown", (e => this.onPointerDown(e))) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } }, drag: { Feature: class extends Hl { constructor(e) { super(e), this.removeGroupControls = Cl, this.removeListeners = Cl, this.controls = new Ih(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Cl } unmount() { this.removeGroupControls(), this.removeListeners() } }, ProjectionNode: Bf, MeasureLayout: Uh } }, zf = { current: null }, qf = { current: !1 }; const Hf = new WeakMap, Wf = [...Pc, Hc, tu], Kf = Object.keys(ca), Gf = Kf.length, Qf = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], Yf = ra.length; function Jf(e) { if (e) return !1 !== e.options.allowProjection ? e.projection : Jf(e.parent) } class Xf { scrapeMotionValuesFromProps(e, t, n) { return {} } constructor(e) { let { parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o } = e, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.resolveKeyframes = (e, t, n, r) => new this.KeyframeResolver(e, t, n, r, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Lc, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => Tl.render(this.render, !1, !0); const { latestValues: l, renderState: c } = o; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = Boolean(s), this.isControllingVariants = ia(n), this.isVariantNode = sa(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(t && t.current); const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this); for (const h in d) { const e = d[h]; void 0 !== l[h] && Ea(e) && (e.set(l[h], !1), Sd(u) && u.add(h)) } } mount(e) { this.current = e, Hf.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach(((e, t) => this.bindToMotionValue(t, e))), qf.current || function () { if (qf.current = !0, Bo) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => zf.current = e.matches; e.addListener(t), t() } else zf.current = !1 }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || zf.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { var e; Hf.delete(this.current), this.projection && this.projection.unmount(), Al(this.notifyUpdate), Al(this.render), this.valueSubscriptions.forEach((e => e())), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const t in this.events) this.events[t].clear(); for (const t in this.features) null === (e = this.features[t]) || void 0 === e || e.unmount(); this.current = null } bindToMotionValue(e, t) { const n = wa.has(e), r = t.on("change", (t => { this.latestValues[e] = t, this.props.onUpdate && Tl.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) })), i = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, (() => { r(), i(), t.owner && t.stop() })) } sortNodePosition(e) { return this.current && this.sortInstanceNodePosition && this.type === e.type ? this.sortInstanceNodePosition(this.current, e.current) : 0 } loadFeatures(e, t, n, r) { let i, s, { children: o, ...a } = e; for (let l = 0; l < Gf; l++) { const e = Kf[l], { isEnabled: t, Feature: n, ProjectionNode: r, MeasureLayout: o } = ca[e]; r && (i = r), t(a) && (!this.features[e] && n && (this.features[e] = new n(this)), o && (s = o)) } if (("html" === this.type || "svg" === this.type) && !this.projection && i) { this.projection = new i(this.latestValues, Jf(this.parent)); const { layoutId: e, layout: t, drag: n, dragConstraints: s, layoutScroll: o, layoutRoot: l } = a; this.projection.setOptions({ layoutId: e, layout: t, alwaysMeasureLayout: Boolean(n) || s && Zo(s), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: "string" === typeof t ? t : "both", initialPromotionConfig: r, layoutScroll: o, layoutRoot: l }) } return s } updateFeatures() { for (const e in this.features) { const t = this.features[e]; t.isMounted ? t.update() : (t.mount(), t.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : uh() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let n = 0; n < Qf.length; n++) { const t = Qf[n]; this.propEventSubscriptions[t] && (this.propEventSubscriptions[t](), delete this.propEventSubscriptions[t]); const r = e["on" + t]; r && (this.propEventSubscriptions[t] = this.on(t, r)) } this.prevMotionValues = function (e, t, n) { const { willChange: r } = t; for (const i in t) { const s = t[i], o = n[i]; if (Ea(s)) e.addValue(i, s), Sd(r) && r.add(i); else if (Ea(o)) e.addValue(i, jd(s, { owner: e })), Sd(r) && r.remove(i); else if (o !== s) if (e.hasValue(i)) { const t = e.getValue(i); !0 === t.liveStyle ? t.jump(s) : t.hasAnimated || t.set(s) } else { const t = e.getStaticValue(i); e.addValue(i, jd(void 0 !== t ? t : s, { owner: e })) } } for (const i in n) void 0 === t[i] && e.removeValue(i); return t }(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext() { if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const e = this.parent && this.parent.getVariantContext() || {}; return void 0 !== this.props.initial && (e.initial = this.props.initial), e } const e = {}; for (let t = 0; t < Yf; t++) { const n = ra[t], r = this.props[n]; (ea(r) || !1 === r) && (e[n] = r) } return e } addVariantChild(e) { const t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { const n = this.values.get(e); t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); const t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let n = this.values.get(e); return void 0 === n && void 0 !== t && (n = jd(null === t ? void 0 : t, { owner: this }), this.addValue(e, n)), n } readValue(e, t) { var n; let r = void 0 === this.latestValues[e] && this.current ? null !== (n = this.getBaseTargetFromProps(this.props, e)) && void 0 !== n ? n : this.readValueFromInstance(this.current, e, this.options) : this.latestValues[e]; return void 0 !== r && null !== r && ("string" === typeof r && (bc(r) || gc(r)) ? r = parseFloat(r) : !(e => Wf.find(jc(e)))(r) && tu.test(t) && (r = lu(e, t)), this.setBaseTarget(e, Ea(r) ? r.get() : r)), Ea(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; const { initial: n } = this.props; let r; if ("string" === typeof n || "object" === typeof n) { const i = vl(this.props, n, null === (t = this.presenceContext) || void 0 === t ? void 0 : t.custom); i && (r = i[e]) } if (n && void 0 !== r) return r; const i = this.getBaseTargetFromProps(this.props, e); return void 0 === i || Ea(i) ? void 0 !== this.initialValues[e] && void 0 === r ? void 0 : this.baseTarget[e] : i } on(e, t) { return this.events[e] || (this.events[e] = new Td), this.events[e].add(t) } notify(e) { if (this.events[e]) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; this.events[e].notify(...n) } } } class Zf extends Xf { constructor() { super(...arguments), this.KeyframeResolver = uu } sortInstanceNodePosition(e, t) { return 2 & e.compareDocumentPosition(t) ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, t) { let { vars: n, style: r } = t; delete n[e], delete r[e] } } class $f extends Zf { constructor() { super(...arguments), this.type = "html" } readValueFromInstance(e, t) { if (wa.has(t)) { const e = au(t); return e && e.default || 0 } { const r = (n = e, window.getComputedStyle(n)), i = (Ta(t) ? r.getPropertyValue(t) : r[t]) || 0; return "string" === typeof i ? i.trim() : i } var n } measureInstanceViewportBox(e, t) { let { transformPagePoint: n } = t; return kh(e, n) } build(e, t, n, r) { Ya(e, t, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, t, n) { return ml(e, t, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Ea(e) && (this.childSubscription = e.on("change", (e => { this.current && (this.current.textContent = "".concat(e)) }))) } renderInstance(e, t, n, r) { hl(e, t, n, r) } } class ep extends Zf { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1 } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (wa.has(t)) { const e = au(t); return e && e.default || 0 } return t = fl.has(t) ? t : qo(t), e.getAttribute(t) } measureInstanceViewportBox() { return uh() } scrapeMotionValuesFromProps(e, t, n) { return gl(e, t, n) } build(e, t, n, r) { al(e, t, n, this.isSVGTag, r.transformTemplate) } renderInstance(e, t, n, r) { pl(e, t, 0, r) } mount(e) { this.isSVGTag = cl(e.tagName), super.mount(e) } } const tp = (e, t) => va(e) ? new ep(t, { enableHardwareAcceleration: !1 }) : new $f(t, { allowProjection: e !== r.Fragment, enableHardwareAcceleration: !0 }), np = { ...zd, ...ec, ...Vf, ...{ layout: { ProjectionNode: Bf, MeasureLayout: Uh } } }, rp = ma(((e, t) => function (e, t, n, r) { let { forwardMotionProps: i = !1 } = t; return { ...va(e) ? Pl : Il, preloadedFeatures: n, useRender: dl(i), createVisualElement: r, Component: e } }(e, t, np, tp))); function ip() { return (0, Ve.jsxs)("div", { className: "about-back", children: [(0, Ve.jsxs)("section", { className: "about-page", children: [(0, Ve.jsx)("div", { "data-aos": "fade-down-left", "data-aos-duration": "2000", children: (0, Ve.jsx)("h1", { className: "hp", children: "About Us" }) }), (0, Ve.jsx)("div", { "data-aos": "fade-down-left", "data-aos-duration": "2500", children: (0, Ve.jsx)("p", { className: "hp2", children: "All For One Tech is a Developing platform..." }) }), (0, Ve.jsxs)("div", { className: "about-info", children: [(0, Ve.jsx)("div", { class: "about-img", children: (0, Ve.jsx)("div", { "data-aos": "zoom-in-right", "data-aos-easing": "linear", "data-aos-duration": "1500", children: (0, Ve.jsx)("img", { className: "image555", src: Io, alt: "" }) }) }), (0, Ve.jsx)("div", { className: "paragraph", children: (0, Ve.jsx)(rp.p, { className: "text-in-firstpage", initial: { opacity: 0, y: 100, x: 100 }, animate: { opacity: 1, y: 0, x: 0 }, transition: { duration: 1.5 }, children: " AFOT takes pride in its commitment to innovation, consistently pushing technological boundaries to deliver top-tier products and services to its valuable clients. Get in touch with us today to explore how AFOT can  assist you in real time goals. We're eagerly awaiting the opportunity to hear from you and help you unlock  your business's full potential with our cutting-edge software and hardware solutions. As a prominent company  in software and hardware specialization, we are excellent in crafting advanced solutions across various  platforms  and languages. Whether you're in need of bespoke software development, AI-driven applications, or advanced hardware solutions, AFOT has the expertise and dedication to meet your needs. Our team of skilled professionals is dedicated to designing innovative, tailored solutions that address your unique requirements  and challenges." }) })] })] }), (0, Ve.jsx)("div", { "data-aos": "zoom-out-right", children: (0, Ve.jsx)("h1", { className: "head", children: "Meet Our Team" }) }), (0, Ve.jsxs)("div", { className: "cards", children: [(0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card ", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: Ro, class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "mukesh k" }), (0, Ve.jsxs)("p", { class: "card-text", children: ["ROLE: hardware developer ", (0, Ve.jsxs)("ul", { children: [(0, Ve.jsx)("li", { children: "react js " }), " ", (0, Ve.jsx)("li", { children: "IOT " }), " "] }), " "] }), (0, Ve.jsx)(Ce, { className: "about-button btn btn-primary", to: "/about/cardone", children: "known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: Oo, class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "kishore RBt" }), (0, Ve.jsxs)("p", { class: "card-text", children: ["Role: backend developer ", (0, Ve.jsxs)("ul", { children: [" ", (0, Ve.jsx)("li", { children: "express js" }), " ", (0, Ve.jsx)("li", { children: "php" })] }), "  "] }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: Do, class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "johit raj ss" }), (0, Ve.jsxs)("p", { class: "card-text", children: ["Role: python backend developer ", (0, Ve.jsxs)("ul", { children: [(0, Ve.jsx)("li", { children: "AI/ML " }), (0, Ve.jsx)("li", { children: "D JANGO" })] })] }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: _o, class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "krishann R" }), (0, Ve.jsxs)("p", { class: "card-text", children: ["Role: App  developer  ", (0, Ve.jsxs)("ul", { children: [" ", (0, Ve.jsx)("li", { children: "React Native " }), " ", (0, Ve.jsx)("li", { children: "shift " })] })] }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: Mo, class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "gowtham p" }), (0, Ve.jsxs)("p", { class: "card-text", children: ["Role: backend developer ", (0, Ve.jsxs)("ul", { children: [" ", (0, Ve.jsx)("li", { children: "sql/nonsql database" })] })] }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: "...", class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "Card title" }), (0, Ve.jsx)("p", { class: "card-text", children: "Some quick example text to build on the card title and make up the bulk of the card's content." }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: "...", class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "Card title" }), (0, Ve.jsx)("p", { class: "card-text", children: "Some quick example text to build on the card title and make up the bulk of the card's content." }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: "...", class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "Card title" }), (0, Ve.jsx)("p", { class: "card-text", children: "Some quick example text to build on the card title and make up the bulk of the card's content." }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) }), (0, Ve.jsx)("div", { "data-aos": "flip-left", "data-aos-easing": "ease-out-cubic", "data-aos-duration": "2000", children: (0, Ve.jsxs)("div", { class: "card", style: { width: "18em" }, children: [(0, Ve.jsx)("img", { src: "...", class: "card-img-top", alt: "..." }), (0, Ve.jsxs)("div", { class: "card-body", children: [(0, Ve.jsx)("h5", { class: "card-title", children: "Card title" }), (0, Ve.jsx)("p", { class: "card-text", children: "Some quick example text to build on the card title and make up the bulk of the card's content." }), (0, Ve.jsx)("a", { href: "#", class: "btn btn-primary", children: "Known More" })] })] }) })] })] }) } n.p; const sp = n.p + "static/media/logo.ba84e0030f3dc466eecb.png", op = n.p + "static/media/react-removebg-preview.5d14f2a5d078088221a3.png", ap = n.p + "static/media/python-removebg-preview.f28e30d40b4014842217.png", lp = n.p + "static/media/php-removebg-preview.f6b34b61cf9d3f804729.png", cp = n.p + "static/media/mysql-removebg-preview.d94f3b119c5fe2f69a56.png", up = n.p + "static/media/iot-removebg-preview.debfc7c0c98994530180.png", dp = n.p + "static/media/node-removebg-preview.c72be7faac5351061081.png", hp = n.p + "static/media/linux-removebg-preview.94b18c8eafbc49acac9b.png", fp = n.p + "static/media/js.3dfb665e058d08c99f28.png", pp = n.p + "static/media/machine-removebg-preview.f35c95117177116d1fdf.png", mp = n.p + "static/media/html-removebg-preview.04977af14596deb4e9cc.png", gp = n.p + "static/media/flutter.c77cfdce6c37cd7f8eb9.png", vp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAADjklEQVR4nO2b6UsVURjGz7/QP6Hfp8JpsfzghxYKK6QVkxaJFDErtMAoKyWVLNd2Kr1X+xZREFK2fAgJTNshLcO8UWqLiJnL+z4xd+6lskXv3HHe0fGBBy5y7+F5f845c87MOUpNQKRrMaRrOaRr10nXOkjXBknX4DIPhrLdIF3LJV2LnUht/xXpWgLpWiPpGrugQCs2sidYKXwW6ZrfBQXYZaOWWRMtPpZ0rd0Foe12+7jdgsziP7gg7GT54z8hkHnZT8f//N+uhD+7A02vPj+e/X8b7eEx/7w7hG4X8Jgbfx344EEbc5sYFZo1waPOUaGpIzzq6yo0f4ZH3aFcurBxyoPKBSFEraQDSFtJB5C2kg4gbSUdYPoAiI8DJS0DpawHp6eB92SB8/aBDx8EHysAHy8Gl5WCK8vA1RXg01XgM9Wmjc+nKsFVZeDyE+DSEnBRIfjoIfCB/eC9u4JtUsoG0MoloAVzXQQgbQvQ0gwQwTEND4GbHgRhiwLgrAxgZARi+j4I2p4qBwBvXkNc7W1CANatgVtEG5KdB8AF+XCL+Gi+AIB6X+RJh4Ymo35w7WUBAPfuRB60rhacu8f2sYNvNTgPAM+fWgIQ/P38OeBDeUCgyx4Cj5oFALzrtA4g7Pg4cHEh0NMTHYC2VwIAPvVGDyDshPngipNA31drAAJdAgD6++0DEHbiIvCFs8DAQGQN9/QIAPg2YD+AsJcmAs8iGGO+fBYAMDA5AHhnGvC4NbKGRQD09dkLYGsK+GETLKlXogt0d9sDYNNa8P27iEqBgACAtx3RAUhOAjfctGcZHcWCSFkG8KTVGoCkZeBrV4HRUdimFoGJEN9tjDzo+0DwYYbd4tsCU2Gu98MtYp/EYqioAG6RsTR3HAClboRbZNxJnAcwb7alBZHtetcZzOI8AF0DZ+wAhofliicCZ2dazk+2PBbfutmcwTkJwriFvnwBzkp30YuRBXNBq5abQLIzzRcahUfApcXgqnLw2VPgi+fBNRfB/prgI7Wgr/jBdT7zbzWXzO+cO23+5kSJ2YbR1u5M0LZU0OoVoIVx9mTWZ16NYebdINnVBaaolXQAaSvpANJWM5uk9JltcjekL0PpjZI5LggiulU2Zgofiop+s7Ty+nZ5Dx+YWKw8fGTG91vxhjx/aEp5/dhcWJ4+ODmmO/hcENr5o7O/yhgpPXl4Wo3RFDw+b2Q1Jznj6Af5+dDrRrVuDQAAAABJRU5ErkJggg==", yp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nL2b51cUabf2+3nOp/P8Eeeo48wYyN1Ad5NzlCAgWSTnjAQVjJhQkoAIiII6ZgTMacyOo2Mk59zEJufurutdd1V1Qzue9z0f3vXUWteqJlXX/t1773vvXQ2Hs+o4za/kcHaBfl0ouPDPLL1rip+V6Fb8q5hfKSzmV0ad0a3ML9GtqC7VrXhRpnv+/Vndc/XlOue6zuuUD5/XKR+v0Dk7e0GnbOmCdpnkonap7JJ2qew37RLqMq0z1BXtM9RV7WLqKq8Y13jFuM47Tcl1g1aR7CYj6U1ekeQmr2ixilc0U8UrGq/iFQ1V8Yo6q3hF9VW8ovdVvKLnVbyiW1W8ovwqXlFkFa9IUMUt/Jf8vqu5BZwabsE/yWsfm8ecWu4pzt+Oh9qFnNOCSvp1qeAcp0Bw8T/kPyviX7Ao4l8oK+Jf6C3mX0Cl3nVc0r+BC8IruCC4hAuCi7jIr8RF3fO4qHsOF3XKcUnnLC5pl+E37VJc1i7BFe0zuEq0YjBu0CqibjJCFRG3ELeIeIWo5q6ohohXiFpeEW7zinCHdxp3tYtxT/sM7muX4IFOGZ7onsdDnXLc4hWRa/Tc4hWW3eIWmsvtqOGe+o97Wvn069vcfM473dwVAMWCCvp8RlDByRVc/gdtuOCCTqHg4vMS4RWc17+JMsEllPArUMY/JznLP7dcrlsuPa97VlqhWyar1C2TXdAplV3SKaF+01Fe5Ws8IvnqMgZXEXELKWJsNbeAiKphVcs9pdDtHyqfnGWrJCWq5Z5aruWektRyC3CXdxpPdMtpSNXcguc13AJtYlMt99Q/7rAQ7mrlMcafEZxXnA8IbzGrLrgQXyS4iHL96ygWVMhK+OclpfxzsrP8cqqcf5Y6zz+LCn4ZdUG3lLqoW4JLumfwm+4ZXNYpxlWdYlzTOY3r2qdxQ7sIZHVv8gpRxWNWlxhcw6qWewq3Wd3h5tO6S6RFlId7/ztRROT372rlU3e5+dQdbr7sDjdfQgA91i7Fbea94ohtdzTzOHdZCPe1cjkcR8N62u3zhJfYla88dM7gJooFlTgjOC8pFZyjzgrkhpdRFfxSXOCX4CL/DC7xz+CybjGu6J7GVd3TuKZbhBs6hbipU4gqnQLc0i5AtfYp1PAY1fK+M1YrX2HIfVq5eLBKD2nl/D+1+m/ua+VSRKvASAjUZzql5D0PEhvvaeX94w43n9Oivp+Nc8EFOuZPCyrjzhvcIKsuLRGck5UJylEuOEudE5RRFYJSVApKcFFADC/GZf5pXOEX4Rq/ENf5hbihW4CbuqdwS/cUqnXyUaOTj1qdPNzWzsMdVnd5ubjHy8V9LqMVQ3PwiNVjWtm0nmj+7/R4lR5pMtd5qJVDEbHvIbuvlSd9oV1CYMcyq5/H5LliQQWdIc8IzmsXCytRIqxAqeCc7KygHMTw84JSSmG4oBiXBadxRVCEa4JCXBcU4Cb/FKoE+agW5KNGmI/bwnzc0cvHXWEe7gnycF+Qiwf8HDzQzcFD3Rw80smm9Vg7G094rLg5eEorG7+zeiYXLxvPFTqJ59yTeKZ1As80V/S7QifxlNUTWtnUY1o0FNkj1qseaOXy6OSvlftPTq7gNyYHCM8/rzC4jDJhuaRceBbnhKVUhbAEF4RncElYjMvCIlwRFuKasADXhadwU5CPKmE+avSJ4bmo0T6Jao1jqN58GDUbD6F2w0Hc3ngIdzcfwn2VTDxQycRDlUw8ItqcicebM/FkUyaebMzEU6INh/H010z8TvRLJn7/+RB+X38Qv687gKdr9tMir5/9cggvVI7gpeZxvOKewEvNLLzQOM4qC881GT2jxYB5qnmSYqBkS17zioiXPCM2P9LMZkKgVFhufk7/AsqEZ2XlwjLqvLCEqhSeoS4Ki/Eba/hVueHCfFTp5aHGIA/V/JOoUj2MWt5xPLYuxLvwK6g7dB8tBc/RXvYGXRf+RO/Vv9B/8zMGqr9AVPMVotpvtAa/V803DFZ/w+Ctrxi8+QWD1z9j4PJH9Ff8id4zb9Cd9xztB+6jPuwK3psX4LXKYbxYtw+vNh/GG+5xvNY8htcax/CK1UsFlOMECPWM1gnqd80TspdaeQSKmWIbLBOeLbtseBnn9EolFXpnqAt6xdQlvdO4rFeIq3oFuKZ3Cjf08lCll4tq/VzU6GfjlsZhPLDMx7ejDzHytgPLU/P4dx3S2SVMfehBd9YTfDTLx+uf9uEP9SP4Q/Mo3qofwVuNo3ijcRSvaSmAUC9oZUn+4hUQ7yilja/QO/Ovcr3SngsG5ajUOyO7qHea+k2/CFf0C3BN/xRu6Ofhpn4ubunnoNYwBzWC46jVPYpvxx5ifmhK6cYoigIllUG2LIVsSfL/XZRERr/H6kMyOY++/Gd4r3EY7zYewJ9aR/BO/TDeESCsVoAco15pHJP9oXmSAOl5oZH1L06F/hlhhX4JKvWLcVG/iPpNv5C6on8K1wzyccMgF1UGOag2OInbRidRKziKBxbZGHzRorgBmdxgifTf5gEEBHlPcpYfM5968dUsF+9/3Ye/NA/jg1om3qtn4k/1w7QIlD/Uj1Bv1Y9QBMYbDTpkBJxK/eLIG8bnccmgUHLZoIC6apCP6wZ5uGmYg1uGJ1FjeAJ3jLJwR+8IHlmexER9v8JwstqUbOUmKBmFpbFpzDT3Y+pzJybetWD8RQPET79B/OgLxA8+Q3yf6BPE9xiNE90l+kxr4t4XTNz/iomHdZh82oDpV62Yed+Jubp+LA9NgVoFmrwffQ/s9xb7xlFvkYuPG/bik0YmPqodwl9E6ofwQV0BhHqnfljyTSuHhEsE56JBUX6N6XlcMTy1fM0wDzcMc1FlmI1qoxOoJYYbHcM946O4r3cIw6+ZlServdrwmVYRuoru41tQId5b7cd74z14b7ALH/RS8IGfjL90k/BROwmfeIn4xE3EZ61EfCHSTMRXjUR8U0/EN7UkWnWqO1Gnmow6lRTUqaSiXnUX6tXT0aCxFw3ah9DmVAjRwduY/dC1AoJAWGYgzDeI8I2biS8q+/BF/SA+qx3AJ7WDtORAPqhnLjdr5RAYeZzLhqeqq01KcM0wV3rDKIe6ZXQSNUZZuG18DHeNj+KB2VHc1U5HU94D1viVVSdv3Jl/G3+Y7MYbXjzeCZPwwTAZfxml4JNxCj4bJ+OrcTK+GSejzigZ9USGyWgwTEajQTIa9ZPRpMeoWZiCZkEKmvkpaNFNRYt2Kpp5aWjm7kKz5i40qe9Gk9oeNG7ajfp1KWjcsAf9SdcgZZMvuSc5hNGKt/i6Ng11GgfwTXU/vqrtxxe1A7Q+qx2kPqkdlDZpZhHPqOJcNcp7UWNahJtG2dJbxieoGuPjuGNyFPdMjuCBaSYeGu3HC6csLIlnFEbLvaAx+Sxe82Lw3iwFHy1T8ck8GZ/NduKLaRK+miaiziQR9SYJaDBOQKNxApqM4tFkGI9mw3i0GMSjVT8erXrxaBMmMBIkoo2fhDbdJLTp7ESrdjJaeSlo5aailbsbzZtT0LguEU2/pKBZLQMN/7UTnc4FkIzPKt0bCYkOxwLU/7wLDer7UK+6D3Wq++QwqC9qB6TNGkeJVzzj3DDOeX/bNB/VJlmyWpNjuGN6BPeI4WaH8MTyEB7qpqK18N7fXL8rtwpvtSPx0SYVnyyS8Nk8EV/NE/DNPB51ZnFoMItDo1ksmkxj0GwagxaTGLSaxKDNOBrtRtFoN4xGh2EMOgxi0KEfiw69OLQL49EuSEA7P1EZAvGGTQnocjyBocwaDMRfQrNGhgJCb1jlyi7E5gNx5Vs0rElGs/peNKlmoFF1LxpU98phSFvUMwmMd5wqkxP1d82yUWt6VHbX9DDumx3CQ7MDeGK+H79b7MUz092Y/MrEmzzTzzR244NZAj5ZJeKzVQK+WsahzjIW9ZYxaLCMRpNFFJototBiEYk280i0m0egwywCnaaMukwi0WUShU7jaHQaxaCTBiGHEId2QTza+Qlo0yUekYwWlTiIkipBLUsUcT/7phUt2vtpCI3rUjB1v46BwIbBUt84WrgH0LR5D5pVM9Cskk6DYGHI2tQOEhh1nBrTY533zLNw1yxTdt/8IB6Z78cTYrhlBp6ZpuJP76OQLiyxLsZcvCf/Ov7SD8U3u3jUWceg3joKjdaRaLKOQItVOFqtwtFuFYYOy1B0WoaiyyIE3Rah6LYMR7dlBLpMw9FpFIZO/VB06IWhQz8CHQYERhw6DONXeUMi2nQS0G6QhuXBcYWB8lUePn4XjT/tROPPaegNrVzZGdhaodu7BI3rU9GsxngBgcAoQ9auuh+NqhkdnNtmR4YeWBzBA4uD1COLfXhKDLfag5c2e/DCMB6NGecUF2a8QIKm4IP4ahGGersoNNpGoNk2HC22YWizDUG7bQg6bYLRZROEbptA9FgHoscmBD3WIegy9EOnwBfd5qHosY9Fr1sqerftQrddIu0N7dwgtHNDmJAwiEe7XgLauDHods6kjZYbJ1/lyZvv0fhTIprV9qBVkAnJKJunWEBDmXfQ8F9JaNbYh6ZVHtCkmk61qe4lMEScexaHxh9ZHsQjy33UU6t0PLPejZfWaXhjn4ZX+pHoPlOt5P6LohHUO8WgwS4MTVvC0GIfgjb7YHTYB6HTPhDd9gHosfNHr1z2Qeg29UW36XYMxh7G1NUHWKhrg3RiGrLFJVrSqVksNnVj6uZziOJPoUMvCm3cMHQYJjAhoZ+Epe5hhXHyxRg6WIXG9Qlo0UpH0+bdmP2jnbnXJSZUxJVv0PDfO9GssZcOgyYVOYAMqlWV9gox54Hl/pknVvvw1Dqdem6zCy9tUvHGNhnvHJLx1jAUoquP2YsuM7H3tRmNW0LQ4hCMNscgtDsEoNPBH90OO9Dr4Ic+h+3o20K0A31b/NFj4o7B6L2Y//AN/9tjoa4DothTaNMKpT2hjReF/nCS7ZkVJsfU3Y9o5aWiRTMVLdzdaPplJyZvfVQCMHXnKx0eJE/QeYD1gGaVDKqFATLNeWydsfi7zR48t02jXtqm4I3dTryzT8QHxwT8aRqMkdpnSgBm/vyMFns/tDsHoNN5B7qdt6PX2Rd9zj7od5JrOw2i19IdEyWXFCvGZGkJncxIPqG/pvsHKfM98jP2d8kxcfExOgSRaNeLpSF0Wu+BaGc5+gLy0aqZgFatnTSEVt4u2hPGL71l7nWRATD9tBFNv+5SGK8QC6BZJWOe87vt7uXndml4ZZdMvbFPwrst8XjvEIuPTjH4aBWIsYevmIsuswBev0P7Fk90uW5Hj4sP+ly8MODiSat/qxf6nb3R7+yDPhs3TN+8ozCGNpJNov+3Q/578kQ28/gDOoRR6DCIQzs/Fq1qEWjViGa3SVInJKNVZxea1sVBfO6FkgfMvm5D0yZ2F1ilJpUMij0vcZ7bpUpf2SfjzZZE6p1DPD44xuCjUxS+bI3EV1t/TDx7qwzg2Ut0bXFFn7s3+rd5YMDNHSI3dwy4emDAhXztjT5rJ0yeu7hSobGirzO/gNknryHOOYvhtCwMp2Rh9Fgppmuf0XlB4Snkb9i8M3njOdp5ocwOYZCAdr1EplbQSUKb9k608dPQuC4aY8VPlADMfehC0+Z0OgEqAVBNZwCopi9zXm7ZKXvjkIh3jnHUB6dofHSOxJetYahzDUW9w3ZMvf6TuSk5gCdP0evoCJGXO0QebhC5u0G0bRsjd0/0b3HGSMrulRUlhrCrOffqHUSB8egxc0eP8Tb0mHmh29Qb3Qae6NL3Rp9bPKarnyr/LQtuaHcZ2rRCaAjygqlNDkGQiqafojBa8EAJwPznHnbF5QCYM0mC7FnKeeOYIHvnFIsPztHUx60R+OISijrXYDRuC0STszem/1AGMPv4IQacbTHk44ZBTxcMerpi0MOVhbENA1u3YrGOLUqIK7MGTN+oRq+VC/psPdDvvAN9Tv7oc/BH75YA9G4JQq99MLrN/dEp9II476LSfIEcSz1D6DQjNUI0OvRXqka6WCJ9xM+RGM1nKlZKDuBbH50AFQBUFBBoAM2q6TLOO+dY2YetUfjoEk59cQ1B3bYgNLr7o8XDD62u7pj9UxnA3ON7GHSxwpCvC4a8t2LQi8gFg95uGHCyh/jA3lU3z7jw3MtX6LNxwsBWb/S7+NKJss/Rl9kx7P3Qa7cDvbb+6LUNQo9dCDoFnpj87S4LkWm7yTGSWYk2rSCmYJIXS3wSEslo/iUSo3ns37AV40J9P5rVVwA0yQGoMCHQrJIu47x3iaI+uobji1sIVeceiEaPHWjx3I42bx90uLti7sN3AB7dwaCrBYb9tmLI1wlDPs4Y8nbGkK8rRM42mHt4n/l9CXMTspkZDIWEYcDJlc4PikS5GsKW1RAC0WNFaokwLPcOKl1r7m0dOgRhdPmsKJ1J2ay/E80bIjCad1sZQEM/mjVWckATbXzGKgAZMs5Ht3Dqy7YQ1HkEUI2efmj28kWbtxc6fT3Q7emE+b/esRdlyuG5x7cxtM0Mw/5OGN7uSIsG4U3OLlju6VK+6YcPMWBvB5GHJ5soPTGwCkL/agj2LAT7YHTpeWK87AZ7LcaTpJMz6LZPoktnun/Qj0U7gWCQhJaN4RjNq1UG0NiPFk2yC8h3AlINpq9OghTns3sw9c0jAA1eflSztw/afDzRuX0bena4os/HHgsf/1ACMP+4FkMeJhgJcMTwji0Y9iNyxJC3HUYit0O2sNKfk2Mi9wQGHGwx6OnBJErFjsFum07ef4dAKkpTHwzGHlKaAZJrDoQcQYcgBJ3GqzpJw0S0bAr7MQCtPWhW280YrwgBNgeoZFCcb54BVIO3H5p9fKi27R7o9HNDj78L+gOcIPKzxuKnt8oAntRg2NMII0FbMBJghxF/e4z4O2DYyxpjaZGKlZff8NieZIhctmDQa9WO8T0E4g2OPgoIffb+6LHajn6POMjmF9lrseVvyil08APRaRqNTtJSEwhGCWjdHIrRvBplAE39dJXYrLYLzWrpihBQeIBKOsWp9/ajmny90ernQXXuIMZvRX+gIwaD7TEcYI7Fz2+UATytxoi3IUZD7DESaIuRAFuMBNpj2McS4j2RoKSrAEilGNudgEE3ewx5u9I7Br1bfAdh4HsIpKy29kW/exRdN6wGMLyrAB38AHSZRaHTKAodBIJRPFpVQjCWX/03AKRKbFZPQ7P6ntVeIN8FKE7Tdm+q1c8DHf5uVHegM/qCHCAKscNImA1Gg4yx9Pn13wH46mMs1BajwdYYDSK/Z4sRP0uMJW4HtcSuGMWGQNYBDLoyuwa9Y5Ctk2ybxBt+6Am+6HP0Q6+VFwbDdys8Sl42D8YeR6ceARCJTuNIGkKncRxaVYMxduoHALTT0KJBRDxhj9wL5LsAxWnZ4UG1B7iiO9CZ6gt2gCjUFsNhVhiLsMBYiCGWPr9SArDwezVG/YQYC7fGWIgVRomCbTAaaIXRMEdIR5Qz9+ytyxh0McOwH9k2nf8OYdsPcsJWP/SYukKcW6bwJHpHmV9An/tOdBkHocssHF0mEQwEk1i0qQX9DwDYhkmTeIIiF6wkwbYAN6oryBm9IVuogTBbDIdbYizSDOPRphCHGWDpy3cAnt3C6A4BxJFWGAuzwFioJcZCrTAWaoMRPxMs/vlcCYBE1IfhQLJlOii2zf+bJ9C1wlZfumBa+NKgdK3FhnZ0WwShmwxYzMOYwQoBYBqDNvVAjBV8D6APbTopaNEiUvKClTqgM9hZ1hPqgIFwW2oowhKjUWYYjzHGeIwJxOF6WPryQhnAi1sYC9CFOMoC4ghzjIWbMyDCrTHiq4fp0iNszJIqkB2hXTuPIRcjDPuvqh2UIKzKCe6+6DV3gPhEgSKRyrfBifIb6NLzQo91GD1U6TILo72gyywGbRoBEBd+B6CxF226ZKiajFYagMILKLYqlHG6Qx1k/eG2GIy0pEaizSCONcJEnCEm4owwHinA0udnSgAWX1ZDHKSD8RhziCNNIY4wo0GIw4k3mGMs0g7SoT4FBHn8TubsZyD4ObJF1FYMeZO8QJKjG0Rkm3T3RJ+VPUaSdkE2N688hZ6ZxYBPAnrMd9DTJcYLQmkv6DKPRpuGP8SnvwNQ34M2XdIyJ9OT5RbNNLQQAGp72CSYIeP0RthJRVFWGIkxo8RxRpiI18dEvAEmEgwxEaWDpU9PlQG8qcF4qDbGY00xHm2C8SiTFRCRlhjdIcTM2dVewI6qZVJMVxRi2McWg65mGPK0w6CXIwY9nCByc8SAgx0GHB0xfuIkZLNzf1v9yYob6DZ2R69dEHqsg9BtGUzPGWkvsIhCu+YOiEtqlXqBhbpuum1u5REI8jAgXkAA0LlAyhmIspIMx5pjLM6ImkjUx2SiHqMkfUxEc7H01wMlAEvv7mI8XBsTcSRMjDAebUyDENMgCARzjAUaYvFPpjVlhhwrT5GWWxowVZqLsaRQDAe5YzjAAyPRIZjIPYmFj8xEZ8V4Nvbrm1bKZbsAZs5oJc8FZNhKAGzHeDkzf6DY4c385w6mWdJmALRqMV7QrL6bousClYxlzmCs+dJovDHGE/WpyZ0CTMmVrIfJGA0s/VmrDODjI0xEaTMeQkIl1nAFRBTxCDOIw0wgjrbGcutX1o0JBOXHaaS3kE1OQDoxrtg6FdvdKuOX+wcg2h6BXhsvpnskc0abACUv6LaMRDvXDxMXHygBmHvfgjadeMYLyPMFbgoTBhq7qBYmGS5xhuNN5seTDDCZzKemknXBiI+pVCEmY1Sw9Poau5IMgOW6F5iM1cFkoj4mEthwiTPEeKwRkzyjiEeYQRxqBHGMrWIbVYAgHvGDyZDc6NWF1FJTMwb9w9Fnuw39zn70rFHeL/TYsF5gGYJuq3B06OzA5HU2XOXzy1d1aOPFMk+bdORhkEoDaGUKo3nOaJLBzFSKENOpOtR0qg4U2iXAVMwGLD6vVAIgaX6HyURdTCYJmVChIehjIs5A2RsIhDBjjIUYYfZKAWTTE8oG0yvN7BTfP/OXLSxg+vp1iNw80e/ghgHSQsurRLp9/s4LrMLQKfDH9G12y5bPLx9/Qhs3Gu0COQBFMqRaNUiPsGeaI04Wimd26WBmF4+a3sWDXDN7+JiK/RmL90+xAJiLSkVttHdM7dTF1E6hMogfQYg0o+uG8SQ3zN4oxXJHk5LLK4BIlulOcqbqGkaiIzBgb48B120YcPNSFEh0+7zaC+hcEIxu8vDFOAhzb74qAZiqeo1W9XC06yUph4FWGtXGABBzJtJ0RfPpxGAtamaPFhRK18Z04q9YuJKmvKUtzmEm0xZTSVxMpTD5QtkbvoMQZUrXDGMhJhjdLsRosCXEKb6YPLkLU8XHMFWchYmT++ikSLZGkZMVRK4OGCQjt9VVonyGsMoLeuReQIojm0gsD4yw+YUJo7GiWrSqBNPPFVYnwxatVKqdtMnqu0WcqT28jqV9WphN15TNpmtCoQwtzKRtxlyeiyIu5Uls/lIKpuI3YTqNJEviCXxMJgkwmSj8IQR6m4wkdQOpGC0xGmCGEV9jDHsZYdjDBEMe5hjyssGQjyOGtpPpkqtygaQok9khimKAEoAe22B0GflBFJEJeSDJQ0qUeBptmuFo109UzA/ZMJB1kjZZfXcHZyZD85vkgCZm96rLZveqY0UamM1Qx+w+LciG2tgkxriW5NtjTCduwvRuPp0vplLYxPk/QlipFcZIwUR6DdJMhdhhlLTVgQ4Y3sEOV3ycMEhGbZ4uivZZyQvYXLAyPAlBl9ALU9ce/GB4koZ2fjTa9eQPWxVhIOvi7iHJ8Btndp/aH7JMdcztV5PO7VcFIzVGBEzqOiy/Kl/J4vIJb2kQphN+xfQewQ8gfJ8TmC2SrhPkpTPdRFmzLbUdM1zZzvYLdNPElsnbfuAFDowX9Dkwg5OBHamQzbFts/wJ9tOPaNcho/Q4ZmpED1CZMXorL0Xaw0snAN5x5g6oPMMRYqyKdO6gCjV3UAW0DpCzGubSf8F8kdOqMGA7M3EfZo9YYDpxAwMhja+AIM8J8t2B3iJJKETJvcCcCYVgK7qdpmcK/vbMdEnuBXSv8F2zRLfM7JMn5wD0WHjRE+XFBrmHrozRB5MK0M4LRofRagAkDHZSrbxkaS8BoJn2jDN/aHMVslQxf2iTdP7QJmr+0CasaDPmM9Uwt2ctJB8ur3iBHMJoF+YKPDCd8DOmk1QxlaKNqRQCQg9TyQaY3GmEyURjTCSYYCLOFOOx5hiPtoA4irTb1hgLt8FoqB1Gg+0xEuTAjNn8nZnWebsrBn22YdDbHSJPT4jcvTDgSgB4oc/WHT0mLhD5J2Cxnvnc0uoPS839UYdOPTI2YydG7ASZzQM0gAHtDAKgijOfuTEXOSpYOLxxeeHwBjDaiHmiTHLejPkDv2L+uC5k4h7WC1YgkLyw9PY3zBX40J4wlaSByehNmIjYiInwzRgPU8V4qAbEwVoQB3ExFqCNMX9djPrxMeorxIiPPoa9DDDsYYShbcYYcjXF4FYziJwsIHKwxIC9FfptrNFvY4f+LS4YcPHBUFQypi7fohskhfHypml2Hn0+6QwAExYAGZ4KlfLA8ojuPrId5nIWjmyIQM4mLBz9VbJw9Fdq4eiv5DUWjhCxQI5sxvy+tVgocQa1KH/TFQiKAmakC8tfH2Hp5SUsPj6LhbtFmK/Ow/yNk5i7moW5y1mYvZSF2YtZmLlwAjOVJzFTkY3p8zmYPpeL6fI8TJefwlR5IabOFWOq8iymL13A9PVrmKmpxdyLV1ju6laqJFevPDmG0vLQKdiBLnMyMotkRmY0AEUeoNq0d0pEOhlkOwznLB77hb947BcsHv+ZiKJ17GeQ7y0QyWEc3Yz5vf+FxTJXyKaG2O2GkFcuX/9dB/3UadVnlsjwdHh3Hjr1tjOfQjFhhyU0gBh5HqDadBMpUhW2MfUAn7N4fP1/Lmat76ayf8Zi1nrZYkRYzvkAAAZNSURBVNZP1GLWevIai8eJWBgExDHiCf+NhRx9SOrvKd8QgSFZpktmZS0rIP1Y0h+/Jn0B/Sh9+e9a1VSRY+FzA0RBu9Bl4EMPS7pWT4vkk2PmIQrVxk+UdZMPfvGSu1u0Uv+T/rzw0ol1JShaj6WT6yRLJ9dRrLB04qcVEMd+xsJR4hWbMH9wPeb3rsNi5Q5I6u6BmlOu8/8dB5kPzr//jNGDueix8kW3mS96bJUHJfKhKQuAYgFIhgV7SB4oUXxafCl7rRny12E5Z41sOWcNtZy9ltZS9loogZBDOLoRC4c3Yy5jDebSf8JcliEWfovG0tMiLH+6DUnza0g6PkLaW0/3DtKhLkhHeiEd7YN0dICViNUgcx5hNSyCZHAAkoE+SHq7sdzRhqXGBix+/oz5l68wfaMK4hN5GAyMRq+NB3rMtqHXnrTJQWx3GLwCgAxNGQBUh14s1S6Ue0AKWrV3GjPGn1zHnHPW/I6idVjKXitZzlmLJQIiZw2W/waBDYfDGzB/WAXzh1Qxt3cjZtN+wszONZhJ2YDpNHVMp3ExnaaLqVQ9TKWQdtsYkztNMZFkjokEC4zHWUEcawNxtC3GIu0xFrGFniqPhjhhJMgZwwFbme3QhxREWyFy24oBRyf0WdvTnz/o2+LB1AOO/itlsbw7pOeF7NSYBhBNsTuBZFAvjSTCh8TmTkH8PzjLOWvof5lZyl7LI4ZLiPHZa2U0BOIFjEesQDj+M5McjxAAG+laYe6gKuYOaGB2Pxeze7mY2cNluspUbUwl62AySReTCQJMxAkxEauP8WgDiCONIA43wViYKcZCzDEaZImRACuM+Ntg2M8Ow75bmN7Ay5kdnpInS+4QuXtjwM0H/VvlfYG8LGYmRUqjMpMIqtMoimISYaysU498CDNB2q6bpE5sbtNNpG3nLGevof+BaDlnbQxO/8QCWKOAQMJCHg4rocB6QeYmpnLcr4rZfeqYzdBkusndPEynyUtk0jHKu0UyPGHHaKQ0Js8fwiwxGsI8ZBkJJI/byPPG1WN0FsDf+oK/A+hZAUDRAIzpp0cyAmDEMIXsBOHE1nZBAvNPU8vZa4jhnKXsNfS/zS3nrNlPINCekLNWwuYCBgJJjnIvOMp6QSZJipsxd4AAUMNshgYLgISAtnJ5nKCnXBqTBontDegHLEplMQFAymLlvmDA7X9ujNj5ANVtEUKtAIiUdBnGYMR4J9kK99LGC+P+2aEXx2nnJpPYX8uAyFlDwoB9vTaaGM7khDUyJi/QZwKA2SaP/UItHNlA0dUiCQPSO8gBpGsqANCN0moAdJe4CkDEagBsc8T2BSsAtq4C4P49AKrXfgfFAqBYALIuszBJl0mEbMQsnmyF0g79GHrlOw1iOO3CeNrOdn4iR2G8AkLOWsYTstdwl3LWPkX+WqD4J5Azmwski1nrlxeP/SJdOPKrdP7wRun8oc2yuQMqsrl9atTsXg1qJl2TmtnNpabTtMmYjZpK5lOTSUJqMkGPmog3oCZiDanxaGNK0SKHWVBjIVbUaJA1NRJoS43421PDfluoIV9HasjHmRr02koNerhSom3bqAE3d2rAxVPW7+wt63f0kfY5bJf22u+Q9tr6L/dYB0rIhGjAKhzj1rHoJw9QjSMfdhhG0zHfaRDzz3Yh/Q+kCgj0gfz1dCjIISznMDmB+Xqt6VL22pKlnDXdJCegcD1Q+CuQuwE4uRE4vgmyoyqQZKpi8YA6FvZpYC5DC7N7uJjZteIBU4oOkW2RGQ+gxBFmlKI9DrLGKOsBI2xnOOzjjGEvFwx5umHY3R3D2zwx4uaNURdfjG31w5hzAMadgjHtFIbxLeHMiMwipLvLLKykyzSc2eo4HE6HQcx/tAsS6NfterGcLmMGBGf1sZy9lmyHcsP/uczmBXIs5az5z+Xstfylk+vCF7PW5y4e+6Vq4civz+YPb3w3f2jzt7kDKh1z+9QGZ/dqiGfSNWdmdnPnp9O0l6ZTdSRTyXzpZJJAOpmgJ5uIN5BNxBrKfuABstEga9lIoK1sxN9eOuy3RTrk6ygZ8nFeGvTaOj/o4Tot2rZNPODmLhpw8ezsd/au63f0edfnsP1Zr/2Oql5b/9wem8CIHqtgfrdFiOLf5zuNI//RaRhNZ/tOq2A6BFYf/wdsA4RfKwfcHwAAAABJRU5ErkJggg==", bp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAMhUlEQVR4nN1bX4hcVxmfbLTS2tamze450yiobVOjLz6JDyq04IM++FTbGhGjj3Ztk2xyzmxMtlhwo9UGhYLQpkh9EQIN2iBiBSmhz1v7BwR9kzYQCTbnm53dnZl7z5Hfd86598zszO7M7J1N9MLZOztz7rnn+//nfF+tNuElGqs1qQ1/lopqQtMeqczenjnKzAhtDgptDkttlqWmi1LTilTmilDUEppyHopaUpsrAr/xHHNWavNtqehBqWgmXVNq2is17RHKvxt3oZq1Xb2kBsABeG32CF0CLpTZKzQ9JDWdE4reEpra8kddV3/aufoZ6+SptpONlpO66aSmMJr+u1NtnoO5eEYo6khl3hZYS5uHsXaKCKHMnpIAZpcBV8TAFoBrkkKTkprekYtrAYiOB05RJjV1pDZdqSmXylihyAodhiIrtcHnXGrqSkUdwc80eQ1ea3HdCWXelYrfIVNEYF9+D4b3OJVLKCwe2E7TjNDX4+dZqQnsfa2+FIAGcMowEB5IAGcsqB3vQ0Y6x2IdqUwmlQFSLCNjyeH3a0KZs0LRLPYwd8LwnqbCDULz4hFYxniJFJoXmq4y4MzWpis0gA4AJEBNOAJCAhKVwdpdvIsRocxVoWk+7kcqcEPkULNzREgAHJSNVKzkGMtC0yGp6TIDvrgGinfA2p6Vi43vBPBBiPDrsegYvKvDooY9aLosNR0K+5yBkiwIpiYUCek1ewF8/F4oc0Qos8YKDRRXLLegRpDlyoAeOHrFCUg3Xb8XWhfafC8hXkCCGR8JslfLF2YI2phf1mjh5d2BFNqd0fe+IBaeKOeS/XqOVSUnb3uJRqlJZVQsjRY+X2BtrFkOC6rvMuCbEJEoVXBDhj0KTRci1YUqkRB9h60RoEqZx73utf8lBh6aPVFMNxj4QdwAq9Hxe6VLCRK8v7CdUhSlti9lPlIetrkazd5LQVUCUddk722QPbBI9uPJwP8HGv63eqMAGFYh3UtpMQokmAsJYQvFOPCSkBPIPlO8YJtzzFIJ5SsC3m82AHCggc/k9i0Y99GnjPvID4378Lwft8z7/2970rg7jhp313Hj9p/08xME9qzr/RBiJIigEwCTd5uHiIKITk7w7qBRg1LJonZPkFAJ1UHR2ZPkbn3S2Dll7BefbWbf/+1advrV9exnf97If/7aRr78p43s1B/Wsx/8bi179MVW9uXnVrMHliiv93LPACSwbsgAAyxXICjDtslbFEVgUXhTh6Siddb2wczJ6oFnat93hvIzr65nb/4ryzqZtc65LUc3s5bWbf6NX7fsnceMAxKHcZiEsmYHjdbguwQRCDAGLphbAOt7Wzm36N1bqegyU195U1c15eua3O1Hjf3uy2vZex/kWQCOr9w6182d62SWRzezLsstf8/oCde3XmrxGkDkVmIGE8lcoM3lSOzo48yp66VmjC6uVDQf3Mxo56vQ9oX+qDcIsmyf+eN6NwIegNx04ff+Kw/fP3a+ZW8/OpQDwjuDwwRnCR6jMuw2iwCriA6S0EFDKjML/xouZsn6piLqG1Z2tz1l3MIrHniAAsDj5wB2Qufei38MbPDYeeYAIGD4e70ewD33MJmrUpnZ1DTWgtYPGDFnPfXZt69K7tlhgvmCBv/SL1Yh6zmzuwe+IPMwwCdGQAIDm0YP29nI8QJ6IPrMiLGFpmvBzc05/KzO5LGsgvV//7dOFti+AH4AoD2ISdjfBREYDwE+TmGFKBRdi/kECdgL06BIhVjbx95VUV+Tg8nat0AOZm6j66kfiZ6yfMoJuHfzzbiJHx5/aWQEFC57oQs0qeAZ7i1sv1T0bkhmZFUAnlIAnhycGdh3NmW5Hcj28f9I5Wj6VjfY9GE43Ftt6x55ocWO0SgISEbms1T0DnIHtdIPoIeRcuK0VIXUTzX/nceMvfhmYP+g+LYCHnri+dfb2deeX80++0wzu3+J7P1L5OL9wGLhSY4uihAF3DmHYR5KY4DC5Z1GMgP2H+bq7feyLCq/rWS/3bX5Iy+0sg89cd1+7Lhx95wgt/+EwbDhXgA/BhI88NFFVuTDZk5dK/MWWAPhZMXszy+Gu/vJ02SvEjs9TOV+c5fIvP3lXzeyvU9ct5845RG3KeIrZXvs/SBlx7BqzljPwCV8ECGkz95OJb63+08ad98SsQs7iub/6q9Ws7uOe+CH+PsTjTID3QQHtKWig0DAYc7BAzPRcah4gHUht1BiQ+AvvoTC+8yPKd9/ogC80j2FFHwWzh0OwxQs+0wPH0JMAwEst1Be0OBbcADfgCQgC0ibBjH8eYTPFwhFy7D/F33gU/j+/9cICEjwAZKiixCBFT6ugr88pRRXQEAUAbeVCABJQBaemcZ+fFaZcsAsNK0AAVc4Zt4B+2+ljeEDzJ407oHtEcB3zMFcPINn+7kpuU+sIFkPeLf4ffgALdaKE2I7tcfRRqcDgCAI+tTp0RGAuXgGzw5Yk61KTKdNZAqZ2LAEpgUd4MPeHRxqYBNwSYOn1jNATQD0+Z80XXNjewRgDubimQc2r8fW5L4zA5Oio48kTK4F2Z9YBJDd2efDXPefloUZYyr2DwAWgdwKAbg3B69hr6/BWXLu9X90s3ASNaEIFImSHJ6gF4FJEdDw7PqV51bh4W0CbBig4/4Wp+DPK292sjuOFemwCTjAO0NSUStRgrRjBLS7HgAgwg4Zo3DAkGGRI8SUZ1/byG6ZN4gyJxcBr/jfR1LAm0EuThifC1IEhA2OQsmxL58Q8R+RIr/1SeNwWNJ3LjDK8MkRmEFFK8gHekfIV2+4mxkB8f7151ezJCU+vg7QiSMkgissuIRl/MV2GwGtts0/90wzR4iMTNMERCvPD7VZhgj4YMiHwpUgYAo6wIbssfvnv/MM54VzO3GCOCSOwZDiUrQQDo/PUruEgJhFcn/5eze7p4wT7CTp+WD12kIZDodnpPYJEQ4Tb04zWGSQzr/RhgKc3AIkCREZjsmAhDIlNgEXwGX99Blyj77Yco+fb3HKOg5kb7/5YssdeXnNrbW35wDMwVw8g2fDOhZrf+c3LfuFnzbt3QuG5X9M38V7jyEURh1jLTkaf4jr8MrjpJEXjr743El/fH1738B3MFnglFFjAczFM33rWRym3n1i4hgg5AQNJ0WFoiQpiupOFCFyXnD8tHjcDDyz/hGztwefHh0BmItn8GxYh70+LpDojQHG4lSGzcNYpsVlqAfAYYE/GKEus1aFFV8j5gMKBISESCXvZsBD0SXbfz4kTQ5GZKyfUSRR7RnO0/O+Ysf/ZQTEyNHXCihzDbAGmPfw8XhZOREORzWfD1RVF3BDEVDAgPMAfzi6HKkv4vF4UVSoaBalr6wkfOHydrW9NzUCioJK+P5e8V0VOh6P+5KAWlLzH4sGfIFEiA2qOCq7QQgoCiRQ6RL023xPHZSiWk0uhpIRRbX6YlEoxSUyyJ5WIQo3DgEc+sZS2rJEJlTDiUZzcJGUUHRIVFgkdQMQUFSPxiKpopg6lgBurhSjeFAa2eNIOC/gmv+dcMIuI6CIE4Q2vkxO+zK5KOYDK0ZlwRpcMOlLycKpsT87nLxQcrcQ0EOoMuT1hZIKTR4exqFdJaLkgqQ83pfKom4osQj2JkRA1PgJ8HRhUPn8lpfoQ8Ls8et46NIgJIwqEtNEQFq0HWKZeO53KXaTFc7eKP1EMmk8iqJwb+MDLBKKpjlkLhTjKH7C9BAQKj6CwoOvH4C/sP94s7/6tTY3cs+AKrss4gKBfc7VT/uGCe7u6mU/u4sI6OE+bt4oGiZoc8NE0gAy8iUSToiFlGGxI0KRb5lRhCap4mRpWMtMpQhgGS9sPLfZBcDXorYPhIvFn9X0DQnd2zQliqYpFFdxL0GsLdzUTFEBAnrkHIENJ3FD05QY0jQV4pzajq65YB4D4D3NklLTE2XbHOKH2DbXW9OzAwSUQHsF53sIQ9ucRNtcqP9Nulbj3qruH6Sexkmp0sZJ09c4yT1+nZhpDiUydpsSGb4FBPAzsgTaV6/ExknlGydlCGzq6HMK3Bl9malcIukjDIolaZ01EokG0dc6W280QU3U+XVo3XZjkVh/H0D4LscczMUzeDZtnUWBI9pzRYjny2xWVNhTbJ1NrxhMRN0Q8wnhf26e5oZnlN9pas8udt2DZ93IF+biGTyLjLVvnkZDdip+qG6NfUA7UHS1Ca97ub2u6C30SjJpq+WNKTNzYJEO3r1gDt+/RMu0bi8651aste/jkAcUD6MVvlvBHMzFM3g27Vv0a6LKm5Ee/y+jugmu/wLDUIkqi9EJzAAAAABJRU5ErkJggg==", wp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAWY0lEQVR4nNVbW4wb13mevd95v5PLvcky1KIpUBR9igE7bYK+Fa3RPKgv9kPzEgNpbC13l8OZ4XB425WiuEGbh7wV7ZOBGs2SnPtwpdVKsl3EgGyjKFoUKFrYggAXCNBKzpKcc4r/nDMktd6bFFuODzCY4WKXy+/7//Of///+nxz3lGv16h63WmvT57rDrdXaI6t1Z2z4d1auOqOrNfviStW+vFK1qytV5+3lmv3+UtX5ZLliP1yqWG62artLFethtmJ9sli23l+sWG8vVuzaYtn6i0XFfD6pWKPD75ksmWOpkjESEw36Wja4eMnknulaqzvD4EfW6u0+8Iv19thqzX5ppW5fX63Z91Zq9uHqtQO89uZ7ePX6Hby8s4+X63t4qergbNXGS1UbZysOztb2cHb7Js5evY2Xrr+Ls9v7OKOYnUzZ+iCtmNdTJfNbGcUcGyYiIRsj8JwqmVyiRAn5UteF7Ta3tu2wZ4cbBr5aayfWau3cas35cHXnBr7w1+/i1au38EqtjVdqdm+5ZneWqk53uUIsjrJVCy1VbJStWGixzO4V282UrW5GsToZxexlyjbO1G/ixWt3cbrSxinF+iipmLlUyUh4/zchm2PxIgWfKBpcXP6SiFgDwNvU6mvbzui40H+Ortbb1bVa+9MLb76L167dwqs1B63UnM5y1emt1Gy0XLPRUtVByxUbM/B4qQKWt/Bimd0rNs6ULZRRLLA8SpctlIa7YvVSJbObKlkoXbuJ0zu3cbJkfJqQzVqyZEbJhyj/EwAnWyUGW4IR8sUArw+AX6DPfauvbTuvrdbbD5578z28tnMDr9Tt7moNQDtouQok2JiBxww8PgU8ZuBxumzhNNwVC6VKJlgepRQTnntJ2egmyw5O7dzBCdl8EJeN17zPEysaY1FJ9565aJE+P/W6QAD3XX7kwnabsHyh7lxa23b2nwOL79wEi3dW6rbLLI8ZeLA8/jXAYwYeM/AoKRs4KZsoWTLchGx2EoqDk/XbOC4b+zHZuMSAj0aLNDYAAVHJ+DUsX/fcvE3ekIF/ZW3beXThx3fxWq0NFndX6o7n9mB5zCz/RYEnzww8uD9KyCZcOFE03XjR7CZq+zhe1D+LScar3ueMSjolQTK4CPOK81t+exi80z+GLmy3rz8HwHduUPB1B9z+WYIHt8cJ2UCJoonisoljsgHguzHZwvHqPo4V9eve541IOvnsYUnjwqJ2TvB1h0R79kzeIFVpcxfq7bcu/uQ9vFpv99ZqbZeBR0Nu/6zAg+UxA4/iRR3FigaOSoYbKxq9eP02jkj6W7/7xgeUBJGRIOpcqHAOEtY88MztUzUbwDcu/uSfAXxnrdZGvyHgwfI4JhkoKhmMBB1FJL0TqxESGtzf/IxgCYt0O5zpBWtDAW9oO7x1Anh8TMCDow4x8N45/2WCB8vjAXgDR0UDRUS9E60d4IioveXh8EgICdopSU697e1/Fu3b15nbHweeHXWOd9RBktNdqlidbNXqUfA2HkpyvkzwYHEKXtJxWNJQRNQ6keoBDgkaiQkhQRuNsG0QFNSTrb/GzvkL9farz71519vzp4F3we1XfnQXr/z4XXItX7uNsxXbpeBtsDx6BuDxALyOw6KOQoLWC5dv4pCov8JIINgCR2PBWh88DXoX6m045z9j0d493u0p+OXtGyQGLFWst7JV6/Wlqp3LViwjW7+Js1UHs/QWwKNnAB73wZO75oYkEwcF/VGooJE8IVjQRh8jYW2bFjbg+ly+f+7v98/5z4PHffD1GxDwfrlUtf7wqEdlK9arYHni+s8WPLg9gCckBAW9G1Ju4KCg7cPn+m3eIeD9vMr5CzokPAw0K2wgvSUZ3uPgj0Z72PPuytVbYPnL8HfLFXt8qWqNZyvWeLZMS9hM2SpDdQeFDcvtnxV4HBI1FBR0FCpoOCio3WD5Jg4WNJI2BwoqweovsFgAJe1QYfOApbfuUJJz9Khzl7dv4qWq9R+Zqj0Bf7tUsfonR4YRsKiY2Yxifpap2JgVNs8KPFgehwpAgoYDguoGJRMHCtoDP6+SAipQUOnnJWIGs/5qvV2Dwobm9v309rhzvrd87QDqeaJELFcsLlu1uaWKDeC5tEIFirRiTaXL1n9nantgefcZg8fBggrgUaCg4UBB7QTK+3CvEuvz6hhkiACeMLFaJ/X8p6yqc89Ib10QNpYq9r2sYo0kywDe4jIVm3mASd4zUzajacX8ZbriAGD0FYAHq6NAQUV+XnMDoon9vPapj9eInuDjtRHwALr36+0c1POspD0rt6dJTq2NF8vWN4m7l62ptGKOZsrmKFieecD3Mtu3AHCPlbTPGjxYHEAjP5BQ0Lp+ZR/782rO8wIO1sX63thqzfmIiRm9c6a3PZCtFivWv2QqduroKZBWrN9PK9b/ECWnZLlfIXjsh3tBwz5e7fklG/vyrQ/n8gw8rNWa/S2QsYYsj84AT443QsLOLfCCjzOKuZ5WrBczZfOP0opZTSvW/6Wreww8CX7oKXN7xDI8xJIcxMCjJwSPfHkV+fgW8gkGvH6J8xYImKDhMRnrPGLGcHrbWaw4eHHngEpakPTsHOA03fPdPvhSX8zoJWSzl5CNXqJo9uKy2YvJRi9e1KGa8yyPopLejUiGG5VMHCmaGPJ8Br4bEjSXnvMEPDoHeEzA51vIx6sdn7KPF/IqLZupdO3cAwGTaXhPUtWhxdoeXgQFt34DL27fwpn6LZyu3iD3FHF/AA2uz+61fXpV93GCXDfJFVfaAB7FinovWjRxrHaAo8oNcPtOWNIeRUT9MFy0MOT3YdkBy/cIeIGAR0PR/jjw4PbkeSHf6i2INp7fat3zb7VGudWa8zxYnqm3noB5FniwNFqstiHJ+bd02dQzZbOdVkw7VTLtlGK2U4qpp0rmf6bKDoB3kyULJ0rmrxKysRcvGnZcNp24bDjxot6OFQ0jKhkfxMALKgDaOIyKxt9FJP27YUn7nYikLYdF/VJI0P44LOqlkKD9e6i8T2JAsKC6ATjrabQ/CzxayKtoIa/h+bx6OJdXL3IrVecy6PZMuj6vgAnqbTcLcnXZ+gF4Ukox+8pRVKalZ1I2a+lr78CePwQhMyEbn8RFY7q/9ziOi2/Z5HdjReNP4jvvAPhbEdH4Le6UFRD0qVBBkyG5gf0fKGguWJ9F+5PAg9vjha0Wms+rvXnRxnNbrcvcctWpQtOC6fbonGIG5PZd0OszZfOH8KEyZWv89366xyUkB7o14/CzhGzWU9fegYB3mAACisb9hGzOMnK4rPgLEC5JNI5K+isRyei3eCKiPhaRyDUSlrQRqOfDoj4WErTxARHqXwaLNmbnvHfUnQYeLI/m863OfGkfz202q+ABb0PHhtXz51VyQLcnBKQVixCQVsxxyAChS5MsUQKSJbOeugoEGIeg4MaL5v1Y0Zgjli8aI9DEiEpUwY1IxjciohFmz2Mz+RYXEjUuVbSonCXo3MQPae4eFLSRQMErbdWfBZSb4PZdf0FDLNqfBB7P51uw/7vzUhvPbbbe5qBXR9pVg47NeWQsKGy6mat3Icj9FdkCJZNavWRxiSEPSAIBRZMQEJON+zFZn/UaGH1rD6m2oOFB3R4S9fGQoI8HBW00yIqWoKBBOUutX1DJlvPz2pK/oD70C/rgqDsdPJrbbLpzBRPPbTXf50ijEnp15wfvFTaEgLRCCQAPoJY1+wTEgYCdd8Dyh3HiAfr9uGQQArzujQce5OswEzCPLr+gjgB4SoIK4LkFXoVU1iPhbX/pJrh918efCh7cHiyP5ngNz242P4Yy9iFtVJL09twdm3SJeYBiUQ9QLAI6Jg0ISBQpATHZOIwrNiQ596OMgBhrWIB7H9HsxsKC/udhUVdCglYKCvp3PCI8EqCMJRevkv/j59U3IMX15VvdBR6i/MngZzdbYHk0u6Ximc3mQ461qPETCpgkyUlfvYOTbAsk2RaIFy3o03neUE/s3AXLH8ZLNpzz96NFSkB0qH8XEvrgI2FBux0p7+Nw7TYOV29jKmbQpCVU0EYCgkYEjQivc758i8QBX771pz7RxAu86rKj7jTwcEczmy08u9F0uWzVcmmLmnRpz6veQmFDCEiVDBYDKGjoycVknT7LBiEgJhmHsZINGR4EQeoBjABQafuytaD9Q2T7HUhyDoOC3gkVtENIcoLKHig63yZewIIfeMACT+PAQl590cdr1Opwzp8OHiyP6L3lggc8hP48S2+fpFfXJZ1amXmA7HmADpf3XE9s3wXLEwLAAyJsC3g9uzCzfljQ02FRe8hkLHdIzOiEyrfgqPtbGvy0MZCziOUZAT5e/eYC2ff9c/408Hh2AzxAxdOwBWAygwwnPJl0DYVNFzq0SeYBHgHEAyTmDZJRj2/fBcsTAiKwBURKQIQREGKBLyTq32YCJuT2aCi97QXkPUhySADw8SoX4GksWMh7HtB6gVnfO+dPAw+WRzNbGp7ZaHwMdfz7MJnB1FuvP3+WgImSsskIeDwGgGWjRUpAVNIJAVFJP4zKNpS0/SDoeUBIoIlQSND+LFR0oKpzGXgvve0F5DZ4wK3+qcCOwnnI5cldJQQwy6OzwE9vNt0Z3sDTueb7HMzkEOGSTmacV7eHqo4QkJCpB3iRH6J7jBEQK1IPiDACIpJ+PyxpzAP0IwToLwMBNLd/rLAhBPgL2oAA/nECFrZaL1DwqnfOnwQe3B4s350WHDy10XybW6zYVZjJYWMp6Ala1N3k9h0cL1IC4gPQYPm+B8TAA0TjMCLbIGbcD0s0EQozArygFixoL5O0VlDdI4VNzy+34WwfIoDGgPktte8BDDxYHp0BHk3nmp1p6Sae3mhUYQtcZgNJTyJdowRMagABLAjGWQyACY0IiwGEgPpdqOMPI7IFKs79sMAIYOe/J1EHCiolgBQ2JLf3qrqev9iGJKdPgC9PCZhjHjAHHgDgt1rkiDsFPLg9mso1e9O8iac2Gpe5jGJepNNYfekanbM/301uk+kMRgDzANGAdJYSIBr1WP0OWL5PQOgoAQIjQBgQcKSq6/mLDvbxrc8RMIgBrRcAPL28I+5E8Gh6o4Wncs3DyVzzIgdzeJmydQ+msdhA0nmkaxhO6Ca2b8NAAiEgxo4+4gGMgIio16P1O9ClJWJGCDxApASEjvGAgGSD27tHqrqer+hAkjMggG2BuU3mAZsDAmiScyx4AA1u35vKm3gy17w39XqTpt5pxboOlV2qZHaGBpJOEzBRTDa6ifoBHHGMAOoBYUmF/c2eNUJAWKBqDvGAIwR4yqyfZwQUVJdVdbSk5VuUgKEtsJB/nIBZRkA/yTkePJreaKCpXKMzJd7AU+vN/iQJVHIvMfXWA4/OMZlBCIhKjAC27yNkHMXzAK0eqd0B5abvAUG2BaC8fcwD+gRo7pGStueTHidg/pgYMLtFQdMk51jLA3g0mWugqU0NT+YaA1F0UTHHYAgR5vDYKNpZ6i2KSUY3DgR4W4AREAICBOYBjICwqB2GihYkOfdDBUpAkBHgH/TpXiaSNa+6j5e0am9BcuCI+5wHzA55AFifpbfoGPB4KtcA0Mz9Gx+Orf+cyuIwckruipmjqa3RZec8OkO69ggggki0qI+DW4OI4REQ8jwACJAsSHLuBwWVEgAd2gKUtJQAH88IyAMBRL31StrPETC/1eJmN5vcDCNghhHALI+OAU8tv97sTgptPLG+Sxojk7nGGKg3bN7WSMAEJmh3bA4PsWh/XNMCdPturH4Ayc0b1PX16bCgjYdEDYQMovuFRG0HqrqgoBMCggX1fqCg+vxbOig6Ez5eG/fzKuki+Xn1u37RArd3j5S0HgEHs1ut8bnN5tjsZmt8ZqM1PrPZmmQe8OKRc/448O7khooncrufTq7vktbYxPruCBcTiYRFrADjp2wCs8Pm8NAJHRui28fqt+H197gTVkjUpHDtLlj+V0HJgiTn45N+15dvfccnWseVtD2Qr+a3Wnsn/e3MZusbEPlnNpreUTfs9uT1ZK7RAetPru+S5ujE+u7Y5HqDvkGSTV0nS0YUxk9BviJDiIOAd8xAku5GS23wACssaQIceWFBq4YEvRoS9XpI1ISgoN8JyW2wfC8oEvX2fwO8etXPq2V/Qa36eK3q59WaL9+SFvLqP/oK+kC6HpS07jyvQ4b3X7ObzercVrMC95mNZnV2o1mb2WgVpzebf0/Ab/Sj/QD8OgHvTm6qAP7B5JUGaY9PrDdoexzUWWZ94gVx2XyNjJ8Wze5QwEOf69XRTo0bKe/hKOT7tTv9K0yuu5iBH9LtdRysHOBg5TYOeFf5APsrB9gn79Fanli+X9j009s5IKF0i1yz8uCagUtsDyU5zWHw4P7g9t3JgoMnrjS+z8ATrBPgAQmFbAEAznHKzwkZMHvLxk+7rF2FPjeNBW0qeC1qvTCIF4LWCYtaJyRqHSZmdMDyA/B93b7jL2gd0qLKw9XqLPBqZwHkrEE9P1zSIpbhubObrc7MZrMzuwH3Vmd6s9mZ2Wh0pnONLnV7Ap6Afgw8bwN4MiKT5Rvc+JVdCIDc9JVdugUS7BsXQyPnl+JF/RGMn7IJTM/tv6gu7Wm6/VlixkkZnmf5YfDuZK4F4B+Nr++SIamJK7sE44QH3luJotkfOSd3yXiFzt4avceGEL8+4NHk+m5vIm/j8fUGGZObuLI7cP2jKy6Dlkcnq2HknJKhX2ezt53HhxC/FuA7E4U9AE9S3okrjdHx9V1i+Yn1I9b3Vox9wSBapDodLBg8JrO3IunSDg8hfg3A7/ZHZcdZ1D/W+sPLU2u9efs/+MG/AgkNNnvbGRpCRGwU7asGj06wfGNhq/Fk4Pvfshh0bWi5+NM3obB5i83e9sgEJlVvPQHzNwG8S/Y8s7xvow+eBb0GN3aFnnJnrog0+KqJN28PKyTo18nsLVVvu3QIkUjX6Jz9+S8KvJfe4v5RB9GeBLzdfpk7vk4jPuz98fNY/ygJ3ny917iAFRK1V8jsLe3YdJmGN9yifjbgaXrrDp3zj7xoP5zpQcAD6z/VitDKrk8CjJwTEgraJZi9JeOnZAJT7RxRcs7TpX0S8J6Y4bm9S3J7SG9phrc/vt64NIj2DPyVxpNb/ugK8wNPIPP2bOQcVrCgfT9QUB8EYQIThhALWpcIGIOBJC+3f1rw6IiY0SMl7YaKWWHzYOJKo/+1OTjnPcAQ8M6958+zQMHxvnMDI+erPB2x9/NaFMZPYQKTDCESUYNOY5GBJFrYDKe3p+n2aKikZbl9owcyFrE8iBlQz9OStjbBCpvVAqS3LNjBfn9alz9r0d68RwJ57nsDjJ/CBCYMIZI5vNI+hmksNpDUI2MpW60uGU6g0jViAiZiMhbt2EDTItfsEOka1Nu8iYmGR2WsjyZyuzmvnvcKG8jt6TMkOV8S+OEFAwpedyZQ0Eb8/ICIOV4d8/GtlxbyrR/Nb6n3YBoLBpJgJoeMpcBkBgwnkP68J2OpmPTqoF0lOJg0LXgLM8vfm1pvXAcNb9STsQb1PNnrUNicmN19WSvI0y8dwAqLhJCR/uwtW/58a3Q+r16EaSwYSIKZnLmt5i9mN1sfw3AC9OehRQ1dWmhUQq8O2lXQsYGmxWSu8fzU69S1vTW53hibyO2OTK036etcg5t64+mt/v+6fRXuhWvaLgAAAABJRU5ErkJggg==", xp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAOGUlEQVR4nNVbSYxcRxlue65cI1mIJRDiYFI1Y0AECItIOBDgAkJiMRwcDhBI4ASWEELcbLGZRSAQREgk8VI19jiJ7RCyKkMkZ1Em8ZJA4uCp6tnc9tgzXmbG08sU+v6q/3W918u87ul2kpJa/aan+736/r3+pVDockllC1Ibf60N/l4nlRlIfUfb9VLbjVKZLVKZ7UKZEanNmFRmWmqzIJSpCW1q4XpaKjNG31F2h9T2m1KZG4Qy6zPPHZAaz7LJPsSwv75qS2pbECqAV3adUDYBLpQZkMrcIrXdKbU5KrVdHry/5DY/dMENPTjrBg/MOLlv0snhopPa+heu903S//AdfBe/EcqUhTbHpMK97K1SR8/RZkBqs84/s86Mvi5BnI65Xue4VGaDUHab0Oa43D/lNh+ed4MHThM4oW2VwChTkeC4MitSp18Cn0EilKkIbfHdKn6Le+BeuKfQ9oTUdpvUdkOd4HZA6CAN2hT4ug/gLYlbeOh6ubfI19dAvKU2s0OH5mjDQtsVoWxZalOV2gLYCr2D2yq8N3/F3yGiCG2qQtsKrnFvPEMqMyu13SG0ucYTfxwMWN8XaZC6SCLvr4kIda5re5dUtjR0eI5EWGhwz1QZQApUd68UQaSXpAqeRc/UpiS1uSthEtmHuoTeGBi2Nq5rviF0PaHyJqHN6NCh8ySaUoPbtibq3I0J0ItXcj9Il1cjW8azsQeh7KhUZhPtU5n1UnnbAHVlqe0CvEl+DPD8udR2q1BmEcZKkmjaGm2MdLinoFu8SC0CMciDVPxezJLU5vb6PtlAmkSC84NXEeeVTdwQLDs9bN8EHljhTXmuXA3wjRIRXhXsifamzM46Di+x5Crz2gWR8u8evByewLWGNSYd157rfRD1LgjhpYHUQpsqeQxltcgw0MctxRwE0P6HIojQjXAtyhwk8GTZ+6bnvZCGFbhQIoK2BzlAYhVeVQpk4uY8+CARnvPerfXCsveTEOQxsFdPBKPrjA1ECHFMU85Lz+1E9IW2O4PYlzMW/o0G254IJAmGJWEneweOZZrGCaIu+uTnhTK3B0tfZat7tcALZXJ9thoRpDJVYBDabA2qwNgyoq8D+MTPm01C2yVYVu9q+g8+Bjg0bN3mYesGtX/hGp/l+W249m5SmRphUGYRmGKMSXwgcbChlynIvYnRGPWUs5Us+CYP6xl4gPzAXuOuvW/cveu+U+763ePufbvH3TvvPeXeu2ucvseEiJ/NhLoxfBYTAS4yxAmj3qgXKUASfG4QbPiCeCC09NGV9/PtfPxgD4iA3w+G62t3jbuPjRTdj46cdf949YI7ZC67B8cvu7++Mu/ueKrkhrQlQsSSgXcQ6rrd4+5D+1L7iaPHCkWtylLYLIOaS7YFbCGlP9iUKLyF+DThPj8A1Aa31kIEBo/7bNpr3I6xc660WHGt1mvzy+4HT58hsBv3GPfu+7yEfPGhKbfn5EX3lX9Nu+v3eALFeyc19iF7KTlABTdfCPG+Nw7a7qBDhjLlVnp/wx7jPntw0j0+ueA+cWCCNgKx7JQICXhliJOPTCwkQKsrK65SW3HV8MJ1bWUl+f9fXp53nz885X7+/Kx7uHiZPnu2tEREjMCD8/HpsxwOUDuCLUBihdzDuug8P+tPdTac2dPcx0ZB9Z89N0sPfeb0kvvgsCfK5g6IEH8Pv33IehAMdCV6YfE1CMOrXKtfzy9X3acfmHBvv+dUs2cwjholYrSdBdaAeV3iGqSy23DWxpE2c5ytW2dtSfweGL+UPPyFs0vu5gNF0k0QIa9xhNRA53/67GwCPg24LvpZYsTScHJ+2X354Wm6HxgDdQBRU5JAwRExtEIYldnGUlAIlBgQypygZAYyMW04B92HuGEtV/1GzMUy6R8sN4NbjRC4D773vwvlROwZYKsVE4GJdtjCUHqGwGCyJwjAM/u31ZCwOR6n8QpCm1u94aNYuqXVZyP4/BlPAHACm2BibB87596/15CUQFqGWog9S9LWJ06nONwOfDNCxJIwOr1INoDtQBPi+2M0pJsMorklPgNQyIskQ4j6Wro9uJx/BsMDAxVzD+u50pL71uMzBJB9N7srvg/+hm//xYvnk/t0QoCYaFiQAjynDXhvC7wa+BBZ+RC5IDRiZHPUi0Zr8eeNQ8x//dL5Br0FN2JCwKrf/iSpVOKuWDw/vM9SsPO3V+aT+3SyYjsA98f3zuWSlSE1kMocpaOy1PYGHCFD9rat+OMBMDBwQUuVWgMn2FLHnDxx7or7w7E59/VHZwg4VASS8ba7X3e/fLGRkJ0S4IdPnyECwxvlML5exYFV2WWh7UZIwBbk4DOHnpauC/r7nl3j7p5XL6TcUQMhmoCaulxxT0wuUJQHHz5yyhsvdn3dEGDbkbO0n3ZnhYwhRBKlGuoOW6D/21GICInNtgceisW1peAHOs7eIBb92KDxRtuJeCfAs8/A+v5oiSQqNrhtMZAtsGVgFspuhwSMhCNjkuNr57oQb0PvfvLMWfelh6cpDmjFxWwgQ3YiRHZZv98pAfiZX31kmgxzbGRXJ4JPpAptRkCAMZSkwrF31SMvLO1Ls1doA/NXqm5moR67rwakWXSXvc4Dnr97qVxzn7p/gvaUG7z3BDWP2Y7BCE6HEHFV8BwK43TWjCNXY8X6DwPb1WEMRABmZaZwHF4IVjGX/sPlwKJjYSPNYvd+E4Btinr9YkcGMEUAFGSVWcAJ0Bc2cmZ8QHEYQJzVW3mBfoKPJQB5A8QTXZxGGWutIwJwLABf/sn7J5y9WE6IEBvBfhEjvu/cFX8C7ET/mxNA5VOBrCrA8n7u0KR7fb7csMl+LAbP4o8TaSfur8EQEmazgDjAG8EO6nqcm0P2BRz43bE5V7xUdleq/bMH2fviIMUE6CIj5Y2gtlMgALlBqSzaVToiArzCXf8+477zVIlOgny07TUB+F58+DpyeqnhzN8JeBR0/dHfjiEp4AOhkATN++IEJSxxM071EnzW+H37yTVx3ydJfdZ7BMkQCoUzpa9cxhBcQCAyu1SljbF+9pIIcfID66C5nOQbuuA+5zx8KKwpFLbhMEStKB3bAXDiu0+Vkg3DI2TPA90SJBH98A5Cf+aBCfJC3Wajg7GvH4aEshuJ+94qdlTxjYnwvdESJSfjzXcb68e/ie8De4PAp5MEbIP+Q8o91mWhzEakxOsJkTb5wFYEiImAdPnekxfJRzcDkgt45jds+H5/bI6SqN2k4NP67xMiwCx06EHklBglRlpkhPMQAS4R8cFHR4ruG4/N0Nm/k/N+zO04w7TrNZ/1YavfLffTVeN6J0lBoLHRV044fdxAgGYPxYZgjDgdDt2EiN58YMLd/Z95t9Aka5QHPHMdC4kXxBtseNfA/dCP2CQpKjQ1G/q0uLYpNUBqOS6HIRkCoOA2riH6yBNyquzPL8+7801UIA/wONLD+tVL58ni9wA8M9GLvzLHkyZPES6E9oURND8FS5mSAoD/yP6iu+3wJBVCPj5SpCLEHaMl99ujc+7pmUWKBHnFKbGsBDQrdMTA7aUyJVRx0Fmj2LPec0o8FEasL4xoMwAvwP22GwQ6MFEaoybmNBFAACQ1wZXpkARpxt24jpd1gdmghmp/0T2QaIXq3LTfV5ryFFjy6n5cGhPal8YECqS+Vp6Ux6g4SsYwcRtpFbhu17i77dCk+/t/L7gzi3VR58XcjIubcRosLmbwOrdUdfe+dsF94fAUcR3VYrb2PehBSBdHkQeMi6NxF5XU9hqhLZXH+ZgcdVvQDTkpiswQavk/PnKWcgNIjXWS1kIZHJVd1AYRTcLFcaW5F/qe3rul8rhQtoTeZsIaJL8QdVqzLaAGCehL+HFDlXgw6ubgogfsw9cenSFAfzoxR/EAwlZUflGz233yovvj8Tn6PzJKN40UyWXi9zCoPQYeiz6uqUFCKHNnwBgaJGzopw3tIoNqPN0iw0TIGMRsPw/X+RnQO+49Re4QhIELwzs4jM/xf3yPmyvYhfZA11tx3x98lG+RkcN+1gHgB6MOEQbuG4i02SSVXaSW2NAL3K5ixNcMiJuauJWFJYb/ly5d9xR0GjwZPmr0WhQ63STFrUHJYiJEBnGr773trE1uNUB9AtwEPO2Z2uTQ4J1y+c2aJQW1yiTiwe1yPkTGYekt1CiZVH/83inkRdzP+Bq4zysZh4laZblJWlK36FugVdaH8wF83CobWoFWa50XgQjcL4ypC6ksNUvDl2aI8OZrlmbw2iTN0nXwOVrmBfXTJmMnQRWKIEi9XT7dQvcGt8snTdKIXqldXmir5f60YfcDIDna5evdo9w7XB+YgE3ggYlMDvFNNDAROj9SXq2DgYn04EQyJZYamZHaj8z4VlovDc0OUP0CL2KuBz9Pblv5pmi/z7rOdwyeF3mEZELTYDI0iRMQWPDQlE+kpKrL/RuaAqERm6CZMwxNIXDDnsKek6EpsvhrHaET0dBRGKSKxubMnUKb+tgc1MKn1VKGaY3A/bsftqzSrBKPzSlb4v7fsNeBaOgj34hM3hUmRf01qBxujgOU1GY7hhmTwUkMPIbByaQ1LXiPVTLPydQHJzDD4GQZv0sNTmK+OBxsyFMlBruLKbFuRmfDg2Jp2CCV2SZVi9FZn2/kMbsAzuuzj9p84wIZNMQcyExlRmelNn50NrS6hudiVtlf9xN865lCkxqeDtPdGJ7+DYanRcPw9Oncw9OeEDSAvVMqumc0PG0h7omh63pAstDlGkxNlZJkrIs3GD7PjM/bEaHsC1KbKYGReT9tioHpBXwmtR2T2o5IbaFSW6RuMT5PBrk+zju4BvD/B/oyZ/r2OS6gAAAAAElFTkSuQmCC"; function Ep() { const [e, t] = (0, r.useState)(!1); return (0, Ve.jsxs)(Ve.Fragment, { children: [(0, Ve.jsxs)("div", { className: "page1", children: [(0, Ve.jsxs)("div", { className: "row page-height", children: [(0, Ve.jsx)("div", { className: " title  col-lg-7  col-md-6 col-12 col-sm-7", children: (0, Ve.jsxs)("div", { "data-aos": "fade-right", "data-aos-duration": "900", "data-aos-easing": "ease-in-sine", children: [(0, Ve.jsx)("h1", { className: "afot", children: "ALL FOR ONE TECH" }), (0, Ve.jsx)("p", { className: "p1", children: "We offer copyright solutions and acquisition services for  your projects, provide freelance support, and assist with project development and hackathon endeavors,Let us be your trusted ally in achieving your goals" })] }) }), (0, Ve.jsx)("div", { className: " pic col col-lg-5  col-12   col-md-6 col-sm-5 ", children: (0, Ve.jsx)("div", { "data-aos": "fade-left", "data-aos-duration": "900", "data-aos-easing": "ease-in-sine", children: (0, Ve.jsx)("img", { className: "roo img-fluid me-auto", src: sp, alt: "" }) }) })] }), (0, Ve.jsxs)("div", { className: "scroll-down ", children: [(0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {})] })] }), (0, Ve.jsxs)("div", { className: "page2", children: [(0, Ve.jsx)("div", { "data-aos": "flip-right", "data-aos-easing": "linear", "data-aos-duration": "800", className: "seee1", children: (0, Ve.jsx)("button", { onClick: () => t(!e), children: e ? "Seeless" : "Seemore" }) }), (0, Ve.jsx)("div", { "data-aos": "fade-right", "data-aos-easing": "linear", "data-aos-duration": "500", children: (0, Ve.jsx)("div", { className: "head5", children: (0, Ve.jsx)("h6", { children: "OUR SERVICES" }) }) }), (0, Ve.jsx)("div", { className: "ver", children: (0, Ve.jsx)("div", { className: "hei", children: (0, Ve.jsx)("div", { "data-aos": "fade-up", children: (0, Ve.jsx)("ul", { className: e ? "vertical" : "horizontal", children: ["Project", "Paper Work", "Hackathon", "Modification", "Hardware Bases", "Managements", "Company Projects"].map(((e, t) => (0, Ve.jsx)(Ce, { className: "link", to: "/".concat(e.toLowerCase()), children: (0, Ve.jsx)("li", { children: e }) }, t))) }) }) }) })] }), (0, Ve.jsxs)("div", { className: "page4", children: [(0, Ve.jsx)("div", { "data-aos": "fade-up-right", "data-aos-easing": "linear", children: (0, Ve.jsx)("div", { className: "working", children: " THE TECHNOLOGY WE ARE CURRENTLY UTILIZING" }) }), (0, Ve.jsx)("div", { "data-aos": "fade-up", "data-aos-easing": "linear", "data-aos-duration": "500", children: (0, Ve.jsxs)("div", { className: " working-technology container", children: [(0, Ve.jsxs)("div", { className: "row row-work", children: [(0, Ve.jsxs)("div", { className: "box col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1", children: [" ", (0, Ve.jsx)("img", { src: op, alt: "" }), (0, Ve.jsx)("h1", { children: "react js" })] }), (0, Ve.jsxs)("div", { className: "box col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1", children: [(0, Ve.jsx)("img", { src: ap, alt: "" }), (0, Ve.jsx)("h1", { children: "python" })] }), (0, Ve.jsxs)("div", { className: "box col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1", children: [(0, Ve.jsx)("img", { src: lp, alt: "" }), (0, Ve.jsx)("h1", { children: "pHP" })] }), (0, Ve.jsxs)("div", { className: "box col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1", children: [(0, Ve.jsx)("img", { src: cp, alt: "" }), (0, Ve.jsx)("h1", { children: "mysql" })] })] }), (0, Ve.jsxs)("header", { className: "row row-work", children: [(0, Ve.jsxs)("div", { className: "col-1 col-sm-1 col-md-1 box col-lg-1 col-xl-1 ", children: [(0, Ve.jsx)("img", { src: up, alt: "" }), (0, Ve.jsx)("h1", { children: "IOT" })] }), (0, Ve.jsxs)("div", { className: " col-1 col-sm-1 col-md-1 box col-lg-1 col-xl-1", children: [(0, Ve.jsx)("img", { src: dp, alt: "" }), (0, Ve.jsx)("h1", { children: "node js" })] }), (0, Ve.jsxs)("div", { className: "col-1 col-sm-1 col-md-1 box col-lg-1 col-xl-1", children: [(0, Ve.jsx)("img", { src: hp, alt: "" }), (0, Ve.jsx)("h1", { children: "linux" })] }), (0, Ve.jsxs)("div", { className: " col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1 box", children: [(0, Ve.jsx)("img", { className: "javapic", src: fp, alt: "" }), (0, Ve.jsx)("h1", { className: "java", children: "javascript" })] })] }), (0, Ve.jsxs)("head", { className: "row row-work", children: [(0, Ve.jsxs)("div", { className: " col-1 col-sm-1 col-md-1col-lg-1 col-xl-1 box ", children: [(0, Ve.jsx)("img", { className: "machine-pic", src: pp, alt: "" }), (0, Ve.jsxs)("h1", { className: "machine", children: ["machine ", (0, Ve.jsx)("br", {}), "learning"] })] }), (0, Ve.jsxs)("div", { className: " col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1 box", children: [(0, Ve.jsx)("img", { src: mp, alt: "" }), (0, Ve.jsx)("h1", { children: "html" })] }), (0, Ve.jsxs)("div", { className: " col-1 col-sm-1 col-md-1 col-lg-1 col-xl-1 box", children: [(0, Ve.jsx)("img", { className: "flutterpic", src: gp, alt: "" }), (0, Ve.jsx)("h1", { className: "flutter", children: "flutter" })] })] })] }) })] }), (0, Ve.jsxs)("div", { className: "page5", children: [(0, Ve.jsx)("div", { "data-aos": "zoom-in-up", "data-aos-easing": "linear", "data-aos-duration": "900", children: (0, Ve.jsx)("div", { className: "firs row", children: (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-10 col-md-1   img-last ", children: (0, Ve.jsx)("img", { src: Eo, alt: "" }) }) }) }), (0, Ve.jsx)("div", { "data-aos": "fade-left", "data-aos-duration": "1500", children: (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-12 col-md-12 col-sm-12 p-last", children: (0, Ve.jsxs)("p", { children: ["your final impact statement goes here. ", (0, Ve.jsx)("br", {}), "make it memorable!"] }) }) }), (0, Ve.jsxs)("div", { className: "last row", children: [(0, Ve.jsxs)("div", { "data-aos": "zoom-in-down", "data-aos-duration": "1700", className: "col-lg-4 col-6 col-sm-4 col-md-4  last-d", children: [(0, Ve.jsx)("h1", { children: "connect with us" }), (0, Ve.jsx)("h4", { children: "instagram" }), (0, Ve.jsx)("h4", { children: "twitter" }), (0, Ve.jsx)("h4", { children: "facebook" }), (0, Ve.jsx)("h4", { children: "linkedin" })] }), (0, Ve.jsxs)("div", { "data-aos": "zoom-in-down", "data-aos-duration": "1900", className: "col-lg-3 col-6 col-sm-3 col-md-3 last-d", children: [(0, Ve.jsx)("h1", { children: "company" }), (0, Ve.jsxs)("ul", { children: [(0, Ve.jsx)(Ce, { className: "last-link", to: "/about", children: (0, Ve.jsx)("li", { children: "about us" }) }), (0, Ve.jsx)(Ce, { className: "last-link", to: "contact", children: (0, Ve.jsx)("li", { children: "contact us" }) }), (0, Ve.jsxs)(Ce, { className: "last-link", to: "term", children: [" ", (0, Ve.jsx)("li", { children: "terms & condition" })] }), (0, Ve.jsx)("li", { children: "legal" })] })] }), (0, Ve.jsxs)("div", { "data-aos": "zoom-in-down", "data-aos-duration": "2100", className: "col-lg-4 col-sm-4 col-12 col-md-4  last-d", children: [(0, Ve.jsx)("h1", { children: "contact" }), (0, Ve.jsx)("h5", { children: "allforonetech.in@gmail.com.com" }), (0, Ve.jsx)("h4", { children: "9025486458" })] })] }), (0, Ve.jsx)("div", { "data-aos": "fade-up", "data-aos-anchor-placement": "top-bottom", "data-aos-duration": "1500", className: " last-img", children: (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-1 col-md-1 col-2", children: (0, Ve.jsx)("a", { href: "https://www.youtube.com/@ALLFORONETECH", children: (0, Ve.jsx)("img", { className: "icons", src: vp, alt: "" }) }) }), (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-1 col-md-1 col-2", children: (0, Ve.jsx)("a", { href: "", children: (0, Ve.jsx)("img", { className: "icons", src: yp, alt: "" }) }) }), (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-1 col-md-1 col-2 ", children: (0, Ve.jsx)("a", { href: "", children: (0, Ve.jsx)("img", { className: "icons", src: wp, alt: "" }) }) }), (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-1 col-md-1 col-2", children: (0, Ve.jsx)("a", { href: "", children: (0, Ve.jsx)("img", { className: "icons", src: bp, alt: "" }) }) }), (0, Ve.jsx)("div", { className: "col-lg-1 col-xl-1 col-sm-1 col-md-1 col-2 twitter ", children: (0, Ve.jsx)("a", { href: "", children: (0, Ve.jsx)("img", { className: "icons", src: xp, alt: "" }) }) })] }) })] })] }) } function Sp(e, t) { return function () { return e.apply(t, arguments) } } const { toString: Np } = Object.prototype, { getPrototypeOf: Cp } = Object, Tp = (Ap = Object.create(null), e => { const t = Np.call(e); return Ap[t] || (Ap[t] = t.slice(8, -1).toLowerCase()) }); var Ap; const kp = e => (e = e.toLowerCase(), t => Tp(t) === e), jp = e => t => typeof t === e, { isArray: Pp } = Array, Ip = jp("undefined"); const Rp = kp("ArrayBuffer"); const Op = jp("string"), Dp = jp("function"), _p = jp("number"), Mp = e => null !== e && "object" === typeof e, Lp = e => { if ("object" !== Tp(e)) return !1; const t = Cp(e); return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }, Fp = kp("Date"), Up = kp("File"), Bp = kp("Blob"), Vp = kp("FileList"), zp = kp("URLSearchParams"), [qp, Hp, Wp, Kp] = ["ReadableStream", "Request", "Response", "Headers"].map(kp); function Gp(e, t) { let n, r, { allOwnKeys: i = !1 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (null !== e && "undefined" !== typeof e) if ("object" !== typeof e && (e = [e]), Pp(e)) for (n = 0, r = e.length; n < r; n++)t.call(null, e[n], n, e); else { const r = i ? Object.getOwnPropertyNames(e) : Object.keys(e), s = r.length; let o; for (n = 0; n < s; n++)o = r[n], t.call(null, e[o], o, e) } } function Qp(e, t) { t = t.toLowerCase(); const n = Object.keys(e); let r, i = n.length; for (; i-- > 0;)if (r = n[i], t === r.toLowerCase()) return r; return null } const Yp = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global, Jp = e => !Ip(e) && e !== Yp; const Xp = (Zp = "undefined" !== typeof Uint8Array && Cp(Uint8Array), e => Zp && e instanceof Zp); var Zp; const $p = kp("HTMLFormElement"), em = (e => { let { hasOwnProperty: t } = e; return (e, n) => t.call(e, n) })(Object.prototype), tm = kp("RegExp"), nm = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; Gp(n, ((n, i) => { let s; !1 !== (s = t(n, i, e)) && (r[i] = s || n) })), Object.defineProperties(e, r) }, rm = "abcdefghijklmnopqrstuvwxyz", im = "0123456789", sm = { DIGIT: im, ALPHA: rm, ALPHA_DIGIT: rm + rm.toUpperCase() + im }; const om = kp("AsyncFunction"), am = { isArray: Pp, isArrayBuffer: Rp, isBuffer: function (e) { return null !== e && !Ip(e) && null !== e.constructor && !Ip(e.constructor) && Dp(e.constructor.isBuffer) && e.constructor.isBuffer(e) }, isFormData: e => { let t; return e && ("function" === typeof FormData && e instanceof FormData || Dp(e.append) && ("formdata" === (t = Tp(e)) || "object" === t && Dp(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && Rp(e.buffer), t }, isString: Op, isNumber: _p, isBoolean: e => !0 === e || !1 === e, isObject: Mp, isPlainObject: Lp, isReadableStream: qp, isRequest: Hp, isResponse: Wp, isHeaders: Kp, isUndefined: Ip, isDate: Fp, isFile: Up, isBlob: Bp, isRegExp: tm, isFunction: Dp, isStream: e => Mp(e) && Dp(e.pipe), isURLSearchParams: zp, isTypedArray: Xp, isFileList: Vp, forEach: Gp, merge: function e() { const { caseless: t } = Jp(this) && this || {}, n = {}, r = (r, i) => { const s = t && Qp(n, i) || i; Lp(n[s]) && Lp(r) ? n[s] = e(n[s], r) : Lp(r) ? n[s] = e({}, r) : Pp(r) ? n[s] = r.slice() : n[s] = r }; for (let i = 0, s = arguments.length; i < s; i++)arguments[i] && Gp(arguments[i], r); return n }, extend: function (e, t, n) { let { allOwnKeys: r } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return Gp(t, ((t, r) => { n && Dp(t) ? e[r] = Sp(t, n) : e[r] = t }), { allOwnKeys: r }), e }, trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let i, s, o; const a = {}; if (t = t || {}, null == e) return t; do { for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0;)o = i[s], r && !r(o, e, t) || a[o] || (t[o] = e[o], a[o] = !0); e = !1 !== n && Cp(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: Tp, kindOfTest: kp, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (Pp(e)) return e; let t = e.length; if (!_p(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[Symbol.iterator]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: $p, hasOwnProperty: em, hasOwnProp: em, reduceDescriptors: nm, freezeMethods: e => { nm(e, ((t, n) => { if (Dp(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; Dp(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) })) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach((e => { n[e] = !0 })) }; return Pp(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (e, t, n) { return t.toUpperCase() + n })), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: Qp, global: Yp, isContextDefined: Jp, ALPHABET: sm, generateString: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : sm.ALPHA_DIGIT, n = ""; const { length: r } = t; for (; e--;)n += t[Math.random() * r | 0]; return n }, isSpecCompliantForm: function (e) { return !!(e && Dp(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (Mp(e)) { if (t.indexOf(e) >= 0) return; if (!("toJSON" in e)) { t[r] = e; const i = Pp(e) ? [] : {}; return Gp(e, ((e, t) => { const s = n(e, r + 1); !Ip(s) && (i[t] = s) })), t[r] = void 0, i } } return e }; return n(e, 0) }, isAsyncFn: om, isThenable: e => e && (Mp(e) || Dp(e)) && Dp(e.then) && Dp(e.catch) }; function lm(e, t, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i) } am.inherits(lm, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: am.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const cm = lm.prototype, um = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => { um[e] = { value: e } })), Object.defineProperties(lm, um), Object.defineProperty(cm, "isAxiosError", { value: !0 }), lm.from = (e, t, n, r, i, s) => { const o = Object.create(cm); return am.toFlatObject(e, o, (function (e) { return e !== Error.prototype }), (e => "isAxiosError" !== e)), lm.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o }; const dm = lm; function hm(e) { return am.isPlainObject(e) || am.isArray(e) } function fm(e) { return am.endsWith(e, "[]") ? e.slice(0, -2) : e } function pm(e, t, n) { return e ? e.concat(t).map((function (e, t) { return e = fm(e), !n && t ? "[" + e + "]" : e })).join(n ? "." : "") : t } const mm = am.toFlatObject(am, {}, null, (function (e) { return /^is[A-Z]/.test(e) })); const gm = function (e, t, n) { if (!am.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = am.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (e, t) { return !am.isUndefined(t[e]) }))).metaTokens, i = n.visitor || c, s = n.dots, o = n.indexes, a = (n.Blob || "undefined" !== typeof Blob && Blob) && am.isSpecCompliantForm(t); if (!am.isFunction(i)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (am.isDate(e)) return e.toISOString(); if (!a && am.isBlob(e)) throw new dm("Blob is not supported. Use a Buffer instead."); return am.isArrayBuffer(e) || am.isTypedArray(e) ? a && "function" === typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, n, i) { let a = e; if (e && !i && "object" === typeof e) if (am.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (am.isArray(e) && function (e) { return am.isArray(e) && !e.some(hm) }(e) || (am.isFileList(e) || am.endsWith(n, "[]")) && (a = am.toArray(e))) return n = fm(n), a.forEach((function (e, r) { !am.isUndefined(e) && null !== e && t.append(!0 === o ? pm([n], r, s) : null === o ? n : n + "[]", l(e)) })), !1; return !!hm(e) || (t.append(pm(i, n, s), l(e)), !1) } const u = [], d = Object.assign(mm, { defaultVisitor: c, convertValue: l, isVisitable: hm }); if (!am.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!am.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), am.forEach(n, (function (n, s) { !0 === (!(am.isUndefined(n) || null === n) && i.call(t, n, am.isString(s) ? s.trim() : s, r, d)) && e(n, r ? r.concat(s) : [s]) })), u.pop() } }(e), t }; function vm(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function (e) { return t[e] })) } function ym(e, t) { this._pairs = [], e && gm(e, this, t) } const bm = ym.prototype; bm.append = function (e, t) { this._pairs.push([e, t]) }, bm.toString = function (e) { const t = e ? function (t) { return e.call(this, t, vm) } : vm; return this._pairs.map((function (e) { return t(e[0]) + "=" + t(e[1]) }), "").join("&") }; const wm = ym; function xm(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Em(e, t, n) { if (!t) return e; const r = n && n.encode || xm, i = n && n.serialize; let s; if (s = i ? i(t, n) : am.isURLSearchParams(t) ? t.toString() : new wm(t, n).toString(r), s) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + s } return e } const Sm = class { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { am.forEach(this.handlers, (function (t) { null !== t && e(t) })) } }, Nm = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Cm = { isBrowser: !0, classes: { URLSearchParams: "undefined" !== typeof URLSearchParams ? URLSearchParams : wm, FormData: "undefined" !== typeof FormData ? FormData : null, Blob: "undefined" !== typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Tm = "undefined" !== typeof window && "undefined" !== typeof document, Am = (e => Tm && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)("undefined" !== typeof navigator && navigator.product), km = "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts, jm = Tm && window.location.href || "http://localhost", Pm = { ...e, ...Cm }; const Im = function (e) { function t(e, n, r, i) { let s = e[i++]; if ("__proto__" === s) return !0; const o = Number.isFinite(+s), a = i >= e.length; if (s = !s && am.isArray(r) ? r.length : s, a) return am.hasOwnProp(r, s) ? r[s] = [r[s], n] : r[s] = n, !o; r[s] && am.isObject(r[s]) || (r[s] = []); return t(e, n, r[s], i) && am.isArray(r[s]) && (r[s] = function (e) { const t = {}, n = Object.keys(e); let r; const i = n.length; let s; for (r = 0; r < i; r++)s = n[r], t[s] = e[s]; return t }(r[s])), !o } if (am.isFormData(e) && am.isFunction(e.entries)) { const n = {}; return am.forEachEntry(e, ((e, r) => { t(function (e) { return am.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0])) }(e), r, n, 0) })), n } return null }; const Rm = { transitional: Nm, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, i = am.isObject(e); i && am.isHTMLForm(e) && (e = new FormData(e)); if (am.isFormData(e)) return r ? JSON.stringify(Im(e)) : e; if (am.isArrayBuffer(e) || am.isBuffer(e) || am.isStream(e) || am.isFile(e) || am.isBlob(e) || am.isReadableStream(e)) return e; if (am.isArrayBufferView(e)) return e.buffer; if (am.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let s; if (i) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return gm(e, new Pm.classes.URLSearchParams, Object.assign({ visitor: function (e, t, n, r) { return Pm.isNode && am.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) } }, t)) }(e, this.formSerializer).toString(); if ((s = am.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return gm(s ? { "files[]": e } : e, t && new t, this.formSerializer) } } return i || r ? (t.setContentType("application/json", !1), function (e, t, n) { if (am.isString(e)) try { return (t || JSON.parse)(e), am.trim(e) } catch (sI) { if ("SyntaxError" !== sI.name) throw sI } return (n || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || Rm.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (am.isResponse(e) || am.isReadableStream(e)) return e; if (e && am.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e) } catch (sI) { if (n) { if ("SyntaxError" === sI.name) throw dm.from(sI, dm.ERR_BAD_RESPONSE, this, null, this.response); throw sI } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Pm.classes.FormData, Blob: Pm.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; am.forEach(["delete", "get", "head", "post", "put", "patch"], (e => { Rm.headers[e] = {} })); const Om = Rm, Dm = am.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), _m = Symbol("internals"); function Mm(e) { return e && String(e).trim().toLowerCase() } function Lm(e) { return !1 === e || null == e ? e : am.isArray(e) ? e.map(Lm) : String(e) } function Fm(e, t, n, r, i) { return am.isFunction(r) ? r.call(this, t, n) : (i && (t = n), am.isString(t) ? am.isString(r) ? -1 !== t.indexOf(r) : am.isRegExp(r) ? r.test(t) : void 0 : void 0) } class Um { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function i(e, t, n) { const i = Mm(t); if (!i) throw new Error("header name must be a non-empty string"); const s = am.findKey(r, i); (!s || void 0 === r[s] || !0 === n || void 0 === n && !1 !== r[s]) && (r[s || t] = Lm(e)) } const s = (e, t) => am.forEach(e, ((e, n) => i(e, n, t))); if (am.isPlainObject(e) || e instanceof this.constructor) s(e, t); else if (am.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) s((e => { const t = {}; let n, r, i; return e && e.split("\n").forEach((function (e) { i = e.indexOf(":"), n = e.substring(0, i).trim().toLowerCase(), r = e.substring(i + 1).trim(), !n || t[n] && Dm[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) })), t })(e), t); else if (am.isHeaders(e)) for (const [o, a] of e.entries()) i(a, o, n); else null != e && i(t, e, n); return this } get(e, t) { if (e = Mm(e)) { const n = am.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (am.isFunction(t)) return t.call(this, e, n); if (am.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = Mm(e)) { const n = am.findKey(this, e); return !(!n || void 0 === this[n] || t && !Fm(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function i(e) { if (e = Mm(e)) { const i = am.findKey(n, e); !i || t && !Fm(0, n[i], i, t) || (delete n[i], r = !0) } } return am.isArray(e) ? e.forEach(i) : i(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const i = t[n]; e && !Fm(0, this[i], i, e, !0) || (delete this[i], r = !0) } return r } normalize(e) { const t = this, n = {}; return am.forEach(this, ((r, i) => { const s = am.findKey(n, i); if (s) return t[s] = Lm(r), void delete t[i]; const o = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, n) => t.toUpperCase() + n)) }(i) : String(i).trim(); o !== i && delete t[i], t[o] = Lm(r), n[o] = !0 })), this } concat() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.constructor.concat(this, ...t) } toJSON(e) { const t = Object.create(null); return am.forEach(this, ((n, r) => { null != n && !1 !== n && (t[r] = e && am.isArray(n) ? n.join(", ") : n) })), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((e => { let [t, n] = e; return t + ": " + n })).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e) { const t = new this(e); for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return r.forEach((e => t.set(e))), t } static accessor(e) { const t = (this[_m] = this[_m] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = Mm(e); t[r] || (!function (e, t) { const n = am.toCamelCase(" " + t);["get", "set", "has"].forEach((r => { Object.defineProperty(e, r + n, { value: function (e, n, i) { return this[r].call(this, t, e, n, i) }, configurable: !0 }) })) }(n, e), t[r] = !0) } return am.isArray(e) ? e.forEach(r) : r(e), this } } Um.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), am.reduceDescriptors(Um.prototype, ((e, t) => { let { value: n } = e, r = t[0].toUpperCase() + t.slice(1); return { get: () => n, set(e) { this[r] = e } } })), am.freezeMethods(Um); const Bm = Um; function Vm(e, t) { const n = this || Om, r = t || n, i = Bm.from(r.headers); let s = r.data; return am.forEach(e, (function (e) { s = e.call(n, s, i.normalize(), t ? t.status : void 0) })), i.normalize(), s } function zm(e) { return !(!e || !e.__CANCEL__) } function qm(e, t, n) { dm.call(this, null == e ? "canceled" : e, dm.ERR_CANCELED, t, n), this.name = "CanceledError" } am.inherits(qm, dm, { __CANCEL__: !0 }); const Hm = qm; function Wm(e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new dm("Request failed with status code " + n.status, [dm.ERR_BAD_REQUEST, dm.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) } const Km = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let i, s = 0, o = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = r[o]; i || (i = l), n[s] = a, r[s] = l; let u = o, d = 0; for (; u !== s;)d += n[u++], u %= e; if (s = (s + 1) % e, s === o && (o = (o + 1) % e), l - i < t) return; const h = c && l - c; return h ? Math.round(1e3 * d / h) : void 0 } }; const Gm = function (e, t) { let n = 0; const r = 1e3 / t; let i = null; return function () { const t = !0 === this, s = Date.now(); if (t || s - n > r) return i && (clearTimeout(i), i = null), n = s, e.apply(null, arguments); i || (i = setTimeout((() => (i = null, n = Date.now(), e.apply(null, arguments))), r - (s - n))) } }, Qm = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, r = 0; const i = Km(50, 250); return Gm((n => { const s = n.loaded, o = n.lengthComputable ? n.total : void 0, a = s - r, l = i(a); r = s; const c = { loaded: s, total: o, progress: o ? s / o : void 0, bytes: a, rate: l || void 0, estimated: l && o && s <= o ? (o - s) / l : void 0, event: n, lengthComputable: null != o }; c[t ? "download" : "upload"] = !0, e(c) }), n) }, Ym = Pm.hasStandardBrowserEnv ? function () { const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a"); let n; function r(n) { let r = n; return e && (t.setAttribute("href", r), r = t.href), t.setAttribute("href", r), { href: t.href, protocol: t.protocol ? t.protocol.replace(/:$/, "") : "", host: t.host, search: t.search ? t.search.replace(/^\?/, "") : "", hash: t.hash ? t.hash.replace(/^#/, "") : "", hostname: t.hostname, port: t.port, pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname } } return n = r(window.location.href), function (e) { const t = am.isString(e) ? r(e) : e; return t.protocol === n.protocol && t.host === n.host } }() : function () { return !0 }, Jm = Pm.hasStandardBrowserEnv ? { write(e, t, n, r, i, s) { const o = [e + "=" + encodeURIComponent(t)]; am.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), am.isString(r) && o.push("path=" + r), am.isString(i) && o.push("domain=" + i), !0 === s && o.push("secure"), document.cookie = o.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read: () => null, remove() { } }; function Xm(e, t) { return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const Zm = e => e instanceof Bm ? { ...e } : e; function $m(e, t) { t = t || {}; const n = {}; function r(e, t, n) { return am.isPlainObject(e) && am.isPlainObject(t) ? am.merge.call({ caseless: n }, e, t) : am.isPlainObject(t) ? am.merge({}, t) : am.isArray(t) ? t.slice() : t } function i(e, t, n) { return am.isUndefined(t) ? am.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n) } function s(e, t) { if (!am.isUndefined(t)) return r(void 0, t) } function o(e, t) { return am.isUndefined(t) ? am.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, i, s) { return s in t ? r(n, i) : s in e ? r(void 0, n) : void 0 } const l = { url: s, method: s, data: s, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (e, t) => i(Zm(e), Zm(t), !0) }; return am.forEach(Object.keys(Object.assign({}, e, t)), (function (r) { const s = l[r] || i, o = s(e[r], t[r], r); am.isUndefined(o) && s !== a || (n[r] = o) })), n } const eg = e => { const t = $m({}, e); let n, { data: r, withXSRFToken: i, xsrfHeaderName: s, xsrfCookieName: o, headers: a, auth: l } = t; if (t.headers = a = Bm.from(a), t.url = Em(Xm(t.baseURL, t.url), e.params, e.paramsSerializer), l && a.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))), am.isFormData(r)) if (Pm.hasStandardBrowserEnv || Pm.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0); else if (!1 !== (n = a.getContentType())) { const [e, ...t] = n ? n.split(";").map((e => e.trim())).filter(Boolean) : []; a.setContentType([e || "multipart/form-data", ...t].join("; ")) } if (Pm.hasStandardBrowserEnv && (i && am.isFunction(i) && (i = i(t)), i || !1 !== i && Ym(t.url))) { const e = s && o && Jm.read(o); e && a.set(s, e) } return t }, tg = "undefined" !== typeof XMLHttpRequest && function (e) { return new Promise((function (t, n) { const r = eg(e); let i = r.data; const s = Bm.from(r.headers).normalize(); let o, { responseType: a } = r; function l() { r.cancelToken && r.cancelToken.unsubscribe(o), r.signal && r.signal.removeEventListener("abort", o) } let c = new XMLHttpRequest; function u() { if (!c) return; const r = Bm.from("getAllResponseHeaders" in c && c.getAllResponseHeaders()); Wm((function (e) { t(e), l() }), (function (e) { n(e), l() }), { data: a && "text" !== a && "json" !== a ? c.response : c.responseText, status: c.status, statusText: c.statusText, headers: r, config: e, request: c }), c = null } c.open(r.method.toUpperCase(), r.url, !0), c.timeout = r.timeout, "onloadend" in c ? c.onloadend = u : c.onreadystatechange = function () { c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf("file:")) && setTimeout(u) }, c.onabort = function () { c && (n(new dm("Request aborted", dm.ECONNABORTED, r, c)), c = null) }, c.onerror = function () { n(new dm("Network Error", dm.ERR_NETWORK, r, c)), c = null }, c.ontimeout = function () { let e = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const t = r.transitional || Nm; r.timeoutErrorMessage && (e = r.timeoutErrorMessage), n(new dm(e, t.clarifyTimeoutError ? dm.ETIMEDOUT : dm.ECONNABORTED, r, c)), c = null }, void 0 === i && s.setContentType(null), "setRequestHeader" in c && am.forEach(s.toJSON(), (function (e, t) { c.setRequestHeader(t, e) })), am.isUndefined(r.withCredentials) || (c.withCredentials = !!r.withCredentials), a && "json" !== a && (c.responseType = r.responseType), "function" === typeof r.onDownloadProgress && c.addEventListener("progress", Qm(r.onDownloadProgress, !0)), "function" === typeof r.onUploadProgress && c.upload && c.upload.addEventListener("progress", Qm(r.onUploadProgress)), (r.cancelToken || r.signal) && (o = t => { c && (n(!t || t.type ? new Hm(null, e, c) : t), c.abort(), c = null) }, r.cancelToken && r.cancelToken.subscribe(o), r.signal && (r.signal.aborted ? o() : r.signal.addEventListener("abort", o))); const d = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(r.url); d && -1 === Pm.protocols.indexOf(d) ? n(new dm("Unsupported protocol " + d + ":", dm.ERR_BAD_REQUEST, e)) : c.send(i || null) })) }, ng = (e, t) => { let n, r = new AbortController; const i = function (e) { if (!n) { n = !0, o(); const t = e instanceof Error ? e : this.reason; r.abort(t instanceof dm ? t : new Hm(t instanceof Error ? t.message : t)) } }; let s = t && setTimeout((() => { i(new dm("timeout ".concat(t, " of ms exceeded"), dm.ETIMEDOUT)) }), t); const o = () => { e && (s && clearTimeout(s), s = null, e.forEach((e => { e && (e.removeEventListener ? e.removeEventListener("abort", i) : e.unsubscribe(i)) })), e = null) }; e.forEach((e => e && e.addEventListener && e.addEventListener("abort", i))); const { signal: a } = r; return a.unsubscribe = o, [a, () => { s && clearTimeout(s), s = null }] }, rg = function* (e, t) { let n = e.byteLength; if (!t || n < t) return void (yield e); let r, i = 0; for (; i < n;)r = i + t, yield e.slice(i, r), i = r }, ig = (e, t, n, r, i) => { const s = async function* (e, t, n) { for await (const r of e) yield* rg(ArrayBuffer.isView(r) ? r : await n(String(r)), t) }(e, t, i); let o = 0; return new ReadableStream({ type: "bytes", async pull(e) { const { done: t, value: i } = await s.next(); if (t) return e.close(), void r(); let a = i.byteLength; n && n(o += a), e.enqueue(new Uint8Array(i)) }, cancel: e => (r(e), s.return()) }, { highWaterMark: 2 }) }, sg = (e, t) => { const n = null != e; return r => setTimeout((() => t({ lengthComputable: n, total: e, loaded: r }))) }, og = "function" === typeof fetch && "function" === typeof Request && "function" === typeof Response, ag = og && "function" === typeof ReadableStream, lg = og && ("function" === typeof TextEncoder ? (cg = new TextEncoder, e => cg.encode(e)) : async e => new Uint8Array(await new Response(e).arrayBuffer())); var cg; const ug = ag && (() => { let e = !1; const t = new Request(Pm.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t })(), dg = ag && !!(() => { try { return am.isReadableStream(new Response("").body) } catch (e) { } })(), hg = { stream: dg && (e => e.body) }; var fg; og && (fg = new Response, ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e => { !hg[e] && (hg[e] = am.isFunction(fg[e]) ? t => t[e]() : (t, n) => { throw new dm("Response type '".concat(e, "' is not supported"), dm.ERR_NOT_SUPPORT, n) }) }))); const pg = async (e, t) => { const n = am.toFiniteNumber(e.getContentLength()); return null == n ? (async e => null == e ? 0 : am.isBlob(e) ? e.size : am.isSpecCompliantForm(e) ? (await new Request(e).arrayBuffer()).byteLength : am.isArrayBufferView(e) ? e.byteLength : (am.isURLSearchParams(e) && (e += ""), am.isString(e) ? (await lg(e)).byteLength : void 0))(t) : n }, mg = og && (async e => { let { url: t, method: n, data: r, signal: i, cancelToken: s, timeout: o, onDownloadProgress: a, onUploadProgress: l, responseType: c, headers: u, withCredentials: d = "same-origin", fetchOptions: h } = eg(e); c = c ? (c + "").toLowerCase() : "text"; let f, p, [m, g] = i || s || o ? ng([i, s], o) : []; const v = () => { !f && setTimeout((() => { m && m.unsubscribe() })), f = !0 }; let y; try { if (l && ug && "get" !== n && "head" !== n && 0 !== (y = await pg(u, r))) { let e, n = new Request(t, { method: "POST", body: r, duplex: "half" }); am.isFormData(r) && (e = n.headers.get("content-type")) && u.setContentType(e), n.body && (r = ig(n.body, 65536, sg(y, Qm(l)), null, lg)) } am.isString(d) || (d = d ? "cors" : "omit"), p = new Request(t, { ...h, signal: m, method: n.toUpperCase(), headers: u.normalize().toJSON(), body: r, duplex: "half", withCredentials: d }); let i = await fetch(p); const s = dg && ("stream" === c || "response" === c); if (dg && (a || s)) { const e = {};["status", "statusText", "headers"].forEach((t => { e[t] = i[t] })); const t = am.toFiniteNumber(i.headers.get("content-length")); i = new Response(ig(i.body, 65536, a && sg(t, Qm(a, !0)), s && v, lg), e) } c = c || "text"; let o = await hg[am.findKey(hg, c) || "text"](i, e); return !s && v(), g && g(), await new Promise(((t, n) => { Wm(t, n, { data: o, headers: Bm.from(i.headers), status: i.status, statusText: i.statusText, config: e, request: p }) })) } catch (b) { if (v(), b && "TypeError" === b.name && /fetch/i.test(b.message)) throw Object.assign(new dm("Network Error", dm.ERR_NETWORK, e, p), { cause: b.cause || b }); throw dm.from(b, b && b.code, e, p) } }), gg = { http: null, xhr: tg, fetch: mg }; am.forEach(gg, ((e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (sI) { } Object.defineProperty(e, "adapterName", { value: t }) } })); const vg = e => "- ".concat(e), yg = e => am.isFunction(e) || null === e || !1 === e, bg = e => { e = am.isArray(e) ? e : [e]; const { length: t } = e; let n, r; const i = {}; for (let s = 0; s < t; s++) { let t; if (n = e[s], r = n, !yg(n) && (r = gg[(t = String(n)).toLowerCase()], void 0 === r)) throw new dm("Unknown adapter '".concat(t, "'")); if (r) break; i[t || "#" + s] = r } if (!r) { const e = Object.entries(i).map((e => { let [t, n] = e; return "adapter ".concat(t, " ") + (!1 === n ? "is not supported by the environment" : "is not available in the build") })); let n = t ? e.length > 1 ? "since :\n" + e.map(vg).join("\n") : " " + vg(e[0]) : "as no adapter specified"; throw new dm("There is no suitable adapter to dispatch the request " + n, "ERR_NOT_SUPPORT") } return r }; function wg(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Hm(null, e) } function xg(e) { wg(e), e.headers = Bm.from(e.headers), e.data = Vm.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1); return bg(e.adapter || Om.adapter)(e).then((function (t) { return wg(e), t.data = Vm.call(e, e.transformResponse, t), t.headers = Bm.from(t.headers), t }), (function (t) { return zm(t) || (wg(e), t && t.response && (t.response.data = Vm.call(e, e.transformResponse, t.response), t.response.headers = Bm.from(t.response.headers))), Promise.reject(t) })) } const Eg = "1.7.2", Sg = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => { Sg[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } })); const Ng = {}; Sg.transitional = function (e, t, n) { function r(e, t) { return "[Axios v1.7.2] Transitional option '" + e + "'" + t + (n ? ". " + n : "") } return (n, i, s) => { if (!1 === e) throw new dm(r(i, " has been removed" + (t ? " in " + t : "")), dm.ERR_DEPRECATED); return t && !Ng[i] && (Ng[i] = !0, console.warn(r(i, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, i, s) } }; const Cg = { assertOptions: function (e, t, n) { if ("object" !== typeof e) throw new dm("options must be an object", dm.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let i = r.length; for (; i-- > 0;) { const s = r[i], o = t[s]; if (o) { const t = e[s], n = void 0 === t || o(t, s, e); if (!0 !== n) throw new dm("option " + s + " must be " + n, dm.ERR_BAD_OPTION_VALUE) } else if (!0 !== n) throw new dm("Unknown option " + s, dm.ERR_BAD_OPTION) } }, validators: Sg }, Tg = Cg.validators; class Ag { constructor(e) { this.defaults = e, this.interceptors = { request: new Sm, response: new Sm } } async request(e, t) { try { return await this._request(e, t) } catch (n) { if (n instanceof Error) { let e; Error.captureStackTrace ? Error.captureStackTrace(e = {}) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; try { n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t } catch (sI) { } } throw n } } _request(e, t) { "string" === typeof e ? (t = t || {}).url = e : t = e || {}, t = $m(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: i } = t; void 0 !== n && Cg.assertOptions(n, { silentJSONParsing: Tg.transitional(Tg.boolean), forcedJSONParsing: Tg.transitional(Tg.boolean), clarifyTimeoutError: Tg.transitional(Tg.boolean) }, !1), null != r && (am.isFunction(r) ? t.paramsSerializer = { serialize: r } : Cg.assertOptions(r, { encode: Tg.function, serialize: Tg.function }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let s = i && am.merge(i.common, i[t.method]); i && am.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => { delete i[e] })), t.headers = Bm.concat(s, i); const o = []; let a = !0; this.interceptors.request.forEach((function (e) { "function" === typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, o.unshift(e.fulfilled, e.rejected)) })); const l = []; let c; this.interceptors.response.forEach((function (e) { l.push(e.fulfilled, e.rejected) })); let u, d = 0; if (!a) { const e = [xg.bind(this), void 0]; for (e.unshift.apply(e, o), e.push.apply(e, l), u = e.length, c = Promise.resolve(t); d < u;)c = c.then(e[d++], e[d++]); return c } u = o.length; let h = t; for (d = 0; d < u;) { const e = o[d++], t = o[d++]; try { h = e(h) } catch (No) { t.call(this, No); break } } try { c = xg.call(this, h) } catch (No) { return Promise.reject(No) } for (d = 0, u = l.length; d < u;)c = c.then(l[d++], l[d++]); return c } getUri(e) { return Em(Xm((e = $m(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer) } } am.forEach(["delete", "get", "head", "options"], (function (e) { Ag.prototype[e] = function (t, n) { return this.request($m(n || {}, { method: e, url: t, data: (n || {}).data })) } })), am.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (n, r, i) { return this.request($m(i || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } Ag.prototype[e] = t(), Ag.prototype[e + "Form"] = t(!0) })); const kg = Ag; class jg { constructor(e) { if ("function" !== typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise((function (e) { t = e })); const n = this; this.promise.then((e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null })), this.promise.then = e => { let t; const r = new Promise((e => { n.subscribe(e), t = e })).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e((function (e, r, i) { n.reason || (n.reason = new Hm(e, r, i), t(n.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } static source() { let e; return { token: new jg((function (t) { e = t })), cancel: e } } } const Pg = jg; const Ig = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Ig).forEach((e => { let [t, n] = e; Ig[n] = t })); const Rg = Ig; const Og = function e(t) { const n = new kg(t), r = Sp(kg.prototype.request, n); return am.extend(r, kg.prototype, n, { allOwnKeys: !0 }), am.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e($m(t, n)) }, r }(Om); Og.Axios = kg, Og.CanceledError = Hm, Og.CancelToken = Pg, Og.isCancel = zm, Og.VERSION = Eg, Og.toFormData = gm, Og.AxiosError = dm, Og.Cancel = Og.CanceledError, Og.all = function (e) { return Promise.all(e) }, Og.spread = function (e) { return function (t) { return e.apply(null, t) } }, Og.isAxiosError = function (e) { return am.isObject(e) && !0 === e.isAxiosError }, Og.mergeConfig = $m, Og.AxiosHeaders = Bm, Og.formToJSON = e => Im(am.isHTMLForm(e) ? new FormData(e) : e), Og.getAdapter = bg, Og.HttpStatusCode = Rg, Og.default = Og; const Dg = Og, _g = { type: Dn().string, tooltip: Dn().bool, as: Dn().elementType }, Mg = r.forwardRef(((e, t) => { let { as: n = "div", className: r, type: i = "valid", tooltip: s = !1, ...o } = e; return (0, Ve.jsx)(n, { ...o, ref: t, className: Pe()(r, "".concat(i, "-").concat(s ? "tooltip" : "feedback")) }) })); Mg.displayName = "Feedback", Mg.propTypes = _g; const Lg = Mg, Fg = r.createContext({}), Ug = r.forwardRef(((e, t) => { let { id: n, bsPrefix: i, className: s, type: o = "checkbox", isValid: a = !1, isInvalid: l = !1, as: c = "input", ...u } = e; const { controlId: d } = (0, r.useContext)(Fg); return i = Ge(i, "form-check-input"), (0, Ve.jsx)(c, { ...u, ref: t, type: o, id: n || d, className: Pe()(s, i, a && "is-valid", l && "is-invalid") }) })); Ug.displayName = "FormCheckInput"; const Bg = Ug, Vg = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, htmlFor: s, ...o } = e; const { controlId: a } = (0, r.useContext)(Fg); return n = Ge(n, "form-check-label"), (0, Ve.jsx)("label", { ...o, ref: t, htmlFor: s || a, className: Pe()(i, n) }) })); Vg.displayName = "FormCheckLabel"; const zg = Vg; const qg = r.forwardRef(((e, t) => { let { id: n, bsPrefix: i, bsSwitchPrefix: s, inline: o = !1, reverse: a = !1, disabled: l = !1, isValid: c = !1, isInvalid: u = !1, feedbackTooltip: d = !1, feedback: h, feedbackType: f, className: p, style: m, title: g = "", type: v = "checkbox", label: y, children: b, as: w = "input", ...x } = e; i = Ge(i, "form-check"), s = Ge(s, "form-switch"); const { controlId: E } = (0, r.useContext)(Fg), S = (0, r.useMemo)((() => ({ controlId: n || E })), [E, n]), N = !b && null != y && !1 !== y || function (e, t) { return r.Children.toArray(e).some((e => r.isValidElement(e) && e.type === t)) }(b, zg), C = (0, Ve.jsx)(Bg, { ...x, type: "switch" === v ? "checkbox" : v, ref: t, isValid: c, isInvalid: u, disabled: l, as: w }); return (0, Ve.jsx)(Fg.Provider, { value: S, children: (0, Ve.jsx)("div", { style: m, className: Pe()(p, N && i, o && "".concat(i, "-inline"), a && "".concat(i, "-reverse"), "switch" === v && s), children: b || (0, Ve.jsxs)(Ve.Fragment, { children: [C, N && (0, Ve.jsx)(zg, { title: g, children: y }), h && (0, Ve.jsx)(Lg, { type: f, tooltip: d, children: h })] }) }) }) })); qg.displayName = "FormCheck"; const Hg = Object.assign(qg, { Input: Bg, Label: zg }), Wg = r.forwardRef(((e, t) => { let { bsPrefix: n, type: i, size: s, htmlSize: o, id: a, className: l, isValid: c = !1, isInvalid: u = !1, plaintext: d, readOnly: h, as: f = "input", ...p } = e; const { controlId: m } = (0, r.useContext)(Fg); return n = Ge(n, "form-control"), (0, Ve.jsx)(f, { ...p, type: i, size: o, ref: t, readOnly: h, id: a || m, className: Pe()(l, d ? "".concat(n, "-plaintext") : n, s && "".concat(n, "-").concat(s), "color" === i && "".concat(n, "-color"), c && "is-valid", u && "is-invalid") }) })); Wg.displayName = "FormControl"; const Kg = Object.assign(Wg, { Feedback: Lg }), Gg = r.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = Ge(r, "form-floating"), (0, Ve.jsx)(i, { ref: t, className: Pe()(n, r), ...s }) })); Gg.displayName = "FormFloating"; const Qg = Gg, Yg = r.forwardRef(((e, t) => { let { controlId: n, as: i = "div", ...s } = e; const o = (0, r.useMemo)((() => ({ controlId: n })), [n]); return (0, Ve.jsx)(Fg.Provider, { value: o, children: (0, Ve.jsx)(i, { ...s, ref: t }) }) })); Yg.displayName = "FormGroup"; const Jg = Yg; function Xg(e) { let { as: t, bsPrefix: n, className: i, ...s } = e; n = Ge(n, "col"); const o = function () { const { breakpoints: e } = (0, r.useContext)(He); return e }(), a = function () { const { minBreakpoint: e } = (0, r.useContext)(He); return e }(), l = [], c = []; return o.forEach((e => { const t = s[e]; let r, i, o; delete s[e], "object" === typeof t && null != t ? ({ span: r, offset: i, order: o } = t) : r = t; const u = e !== a ? "-".concat(e) : ""; r && l.push(!0 === r ? "".concat(n).concat(u) : "".concat(n).concat(u, "-").concat(r)), null != o && c.push("order".concat(u, "-").concat(o)), null != i && c.push("offset".concat(u, "-").concat(i)) })), [{ ...s, className: Pe()(i, ...l, ...c) }, { as: t, bsPrefix: n, spans: l }] } const Zg = r.forwardRef(((e, t) => { const [{ className: n, ...r }, { as: i = "div", bsPrefix: s, spans: o }] = Xg(e); return (0, Ve.jsx)(i, { ...r, ref: t, className: Pe()(n, !o.length && s) }) })); Zg.displayName = "Col"; const $g = Zg, ev = r.forwardRef(((e, t) => { let { as: n = "label", bsPrefix: i, column: s = !1, visuallyHidden: o = !1, className: a, htmlFor: l, ...c } = e; const { controlId: u } = (0, r.useContext)(Fg); i = Ge(i, "form-label"); let d = "col-form-label"; "string" === typeof s && (d = "".concat(d, " ").concat(d, "-").concat(s)); const h = Pe()(a, i, o && "visually-hidden", s && d); return l = l || u, s ? (0, Ve.jsx)($g, { ref: t, as: "label", className: h, htmlFor: l, ...c }) : (0, Ve.jsx)(n, { ref: t, className: h, htmlFor: l, ...c }) })); ev.displayName = "FormLabel"; const tv = ev, nv = r.forwardRef(((e, t) => { let { bsPrefix: n, className: i, id: s, ...o } = e; const { controlId: a } = (0, r.useContext)(Fg); return n = Ge(n, "form-range"), (0, Ve.jsx)("input", { ...o, type: "range", ref: t, className: Pe()(i, n), id: s || a }) })); nv.displayName = "FormRange"; const rv = nv, iv = r.forwardRef(((e, t) => { let { bsPrefix: n, size: i, htmlSize: s, className: o, isValid: a = !1, isInvalid: l = !1, id: c, ...u } = e; const { controlId: d } = (0, r.useContext)(Fg); return n = Ge(n, "form-select"), (0, Ve.jsx)("select", { ...u, size: s, ref: t, className: Pe()(o, n, i && "".concat(n, "-").concat(i), a && "is-valid", l && "is-invalid"), id: c || d }) })); iv.displayName = "FormSelect"; const sv = iv, ov = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i = "small", muted: s, ...o } = e; return n = Ge(n, "form-text"), (0, Ve.jsx)(i, { ...o, ref: t, className: Pe()(r, n, s && "text-muted") }) })); ov.displayName = "FormText"; const av = ov, lv = r.forwardRef(((e, t) => (0, Ve.jsx)(Hg, { ...e, ref: t, type: "switch" }))); lv.displayName = "Switch"; const cv = Object.assign(lv, { Input: Hg.Input, Label: Hg.Label }), uv = r.forwardRef(((e, t) => { let { bsPrefix: n, className: r, children: i, controlId: s, label: o, ...a } = e; return n = Ge(n, "form-floating"), (0, Ve.jsxs)(Jg, { ref: t, className: Pe()(r, n), controlId: s, ...a, children: [i, (0, Ve.jsx)("label", { htmlFor: s, children: o })] }) })); uv.displayName = "FloatingLabel"; const dv = uv, hv = { _ref: Dn().any, validated: Dn().bool, as: Dn().elementType }, fv = r.forwardRef(((e, t) => { let { className: n, validated: r, as: i = "form", ...s } = e; return (0, Ve.jsx)(i, { ...s, ref: t, className: Pe()(n, r && "was-validated") }) })); fv.displayName = "Form", fv.propTypes = hv; const pv = Object.assign(fv, { Group: Jg, Control: Kg, Floating: Qg, Check: Hg, Switch: cv, Label: tv, Text: av, Range: rv, Select: sv, FloatingLabel: dv }), mv = function (e) { const t = []; let n = 0; for (let r = 0; r < e.length; r++) { let i = e.charCodeAt(r); i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192, t[n++] = 63 & i | 128) : 55296 === (64512 & i) && r + 1 < e.length && 56320 === (64512 & e.charCodeAt(r + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & e.charCodeAt(++r)), t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) : (t[n++] = i >> 12 | 224, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) } return t }, gv = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" === typeof atob, encodeByteArray(e, t) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = []; for (let i = 0; i < e.length; i += 3) { const t = e[i], s = i + 1 < e.length, o = s ? e[i + 1] : 0, a = i + 2 < e.length, l = a ? e[i + 2] : 0, c = t >> 2, u = (3 & t) << 4 | o >> 4; let d = (15 & o) << 2 | l >> 6, h = 63 & l; a || (h = 64, s || (d = 64)), r.push(n[c], n[u], n[d], n[h]) } return r.join("") }, encodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(mv(e), t) }, decodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function (e) { const t = []; let n = 0, r = 0; for (; n < e.length;) { const i = e[n++]; if (i < 128) t[r++] = String.fromCharCode(i); else if (i > 191 && i < 224) { const s = e[n++]; t[r++] = String.fromCharCode((31 & i) << 6 | 63 & s) } else if (i > 239 && i < 365) { const s = ((7 & i) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536; t[r++] = String.fromCharCode(55296 + (s >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & s)) } else { const s = e[n++], o = e[n++]; t[r++] = String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | 63 & o) } } return t.join("") }(this.decodeStringToByteArray(e, t)) }, decodeStringToByteArray(e, t) { this.init_(); const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = []; for (let i = 0; i < e.length;) { const t = n[e.charAt(i++)], s = i < e.length ? n[e.charAt(i)] : 0; ++i; const o = i < e.length ? n[e.charAt(i)] : 64; ++i; const a = i < e.length ? n[e.charAt(i)] : 64; if (++i, null == t || null == s || null == o || null == a) throw new vv; const l = t << 2 | s >> 4; if (r.push(l), 64 !== o) { const e = s << 4 & 240 | o >> 2; if (r.push(e), 64 !== a) { const e = o << 6 & 192 | a; r.push(e) } } } return r }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }; class vv extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } const yv = function (e) { return function (e) { const t = mv(e); return gv.encodeByteArray(t, !0) }(e).replace(/\./g, "") }, bv = function (e) { try { return gv.decodeString(e, !0) } catch (sI) { console.error("base64Decode failed: ", sI) } return null }; const wv = () => function () { if ("undefined" !== typeof self) return self; if ("undefined" !== typeof window) return window; if ("undefined" !== typeof n.g) return n.g; throw new Error("Unable to locate global object.") }().__FIREBASE_DEFAULTS__, xv = () => { try { return wv() || (() => { if ("undefined" === typeof process) return; const e = { NODE_ENV: "production", PUBLIC_URL: "", WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0, REACT_APP_FIREBASE_API_KEY: "AIzaSyCAcMKQIWGwcpTZfDfYamOc1TtTsoqDmA0", REACT_APP_FIREBASE_APP_ID: "1:234384132534:web:eecf01823c9eb638b81917", REACT_APP_FIREBASE_AUTH_DOMAIN: "auth-web-3b1e9.firebaseapp.com", REACT_APP_FIREBASE_MESSAGING_SENDER_ID: "234384132534", REACT_APP_FIREBASE_PROJECT_ID: "auth-web-3b1e9", REACT_APP_FIREBASE_STORAGE_BUCKET: "auth-web-3b1e9.appspot.com" }.__FIREBASE_DEFAULTS__; return e ? JSON.parse(e) : void 0 })() || (() => { if ("undefined" === typeof document) return; let e; try { e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch (sI) { return } const t = e && bv(e[1]); return t && JSON.parse(t) })() } catch (sI) { return void console.info("Unable to get __FIREBASE_DEFAULTS__ due to: ".concat(sI)) } }, Ev = e => { var t, n; return null === (n = null === (t = xv()) || void 0 === t ? void 0 : t.emulatorHosts) || void 0 === n ? void 0 : n[e] }, Sv = () => { var e; return null === (e = xv()) || void 0 === e ? void 0 : e.config }, Nv = e => { var t; return null === (t = xv()) || void 0 === t ? void 0 : t["_".concat(e)] }; class Cv { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } wrapCallback(e) { return (t, n) => { t ? this.reject(t) : this.resolve(n), "function" === typeof e && (this.promise.catch((() => { })), 1 === e.length ? e(t) : e(t, n)) } } } function Tv() { return "undefined" !== typeof navigator && "string" === typeof navigator.userAgent ? navigator.userAgent : "" } function Av() { return !function () { var e; const t = null === (e = xv()) || void 0 === e ? void 0 : e.forceEnvironment; if ("node" === t) return !0; if ("browser" === t) return !1; try { return "[object process]" === Object.prototype.toString.call(n.g.process) } catch (sI) { return !1 } }() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function kv() { try { return "object" === typeof indexedDB } catch (sI) { return !1 } } class jv extends Error { constructor(e, t, n) { super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, jv.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Pv.prototype.create) } } class Pv { constructor(e, t, n) { this.service = e, this.serviceName = t, this.errors = n } create(e) { const t = (arguments.length <= 1 ? void 0 : arguments[1]) || {}, n = "".concat(this.service, "/").concat(e), r = this.errors[e], i = r ? function (e, t) { return e.replace(Iv, ((e, n) => { const r = t[n]; return null != r ? String(r) : "<".concat(n, "?>") })) }(r, t) : "Error", s = "".concat(this.serviceName, ": ").concat(i, " (").concat(n, ")."); return new jv(n, s, t) } } const Iv = /\{\$([^}]+)}/g; function Rv(e, t) { if (e === t) return !0; const n = Object.keys(e), r = Object.keys(t); for (const i of n) { if (!r.includes(i)) return !1; const n = e[i], s = t[i]; if (Ov(n) && Ov(s)) { if (!Rv(n, s)) return !1 } else if (n !== s) return !1 } for (const i of r) if (!n.includes(i)) return !1; return !0 } function Ov(e) { return null !== e && "object" === typeof e } function Dv(e) { const t = []; for (const [n, r] of Object.entries(e)) Array.isArray(r) ? r.forEach((e => { t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e)) })) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r)); return t.length ? "&" + t.join("&") : "" } function _v(e) { const t = {}; return e.replace(/^\?/, "").split("&").forEach((e => { if (e) { const [n, r] = e.split("="); t[decodeURIComponent(n)] = decodeURIComponent(r) } })), t } function Mv(e) { const t = e.indexOf("?"); if (!t) return ""; const n = e.indexOf("#", t); return e.substring(t, n > 0 ? n : void 0) } class Lv { constructor(e, t) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then((() => { e(this) })).catch((e => { this.error(e) })) } next(e) { this.forEachObserver((t => { t.next(e) })) } error(e) { this.forEachObserver((t => { t.error(e) })), this.close(e) } complete() { this.forEachObserver((e => { e.complete() })), this.close() } subscribe(e, t, n) { let r; if (void 0 === e && void 0 === t && void 0 === n) throw new Error("Missing Observer."); r = function (e, t) { if ("object" !== typeof e || null === e) return !1; for (const n of t) if (n in e && "function" === typeof e[n]) return !0; return !1 }(e, ["next", "error", "complete"]) ? e : { next: e, error: t, complete: n }, void 0 === r.next && (r.next = Fv), void 0 === r.error && (r.error = Fv), void 0 === r.complete && (r.complete = Fv); const i = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then((() => { try { this.finalError ? r.error(this.finalError) : r.complete() } catch (sI) { } })), this.observers.push(r), i } unsubscribeOne(e) { void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(e) { if (!this.finalized) for (let t = 0; t < this.observers.length; t++)this.sendOne(t, e) } sendOne(e, t) { this.task.then((() => { if (void 0 !== this.observers && void 0 !== this.observers[e]) try { t(this.observers[e]) } catch (sI) { "undefined" !== typeof console && console.error && console.error(sI) } })) } close(e) { this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then((() => { this.observers = void 0, this.onNoObservers = void 0 }))) } } function Fv() { } function Uv(e) { return e && e._delegate ? e._delegate : e } class Bv { constructor(e, t, n) { this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(e) { return this.instantiationMode = e, this } setMultipleInstances(e) { return this.multipleInstances = e, this } setServiceProps(e) { return this.serviceProps = e, this } setInstanceCreatedCallback(e) { return this.onInstanceCreated = e, this } } const Vv = "[DEFAULT]"; class zv { constructor(e, t) { this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(e) { const t = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(t)) { const e = new Cv; if (this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()) try { const n = this.getOrInitializeService({ instanceIdentifier: t }); n && e.resolve(n) } catch (sI) { } } return this.instancesDeferred.get(t).promise } getImmediate(e) { var t; const n = this.normalizeInstanceIdentifier(null === e || void 0 === e ? void 0 : e.identifier), r = null !== (t = null === e || void 0 === e ? void 0 : e.optional) && void 0 !== t && t; if (!this.isInitialized(n) && !this.shouldAutoInitialize()) { if (r) return null; throw Error("Service ".concat(this.name, " is not available")) } try { return this.getOrInitializeService({ instanceIdentifier: n }) } catch (sI) { if (r) return null; throw sI } } getComponent() { return this.component } setComponent(e) { if (e.name !== this.name) throw Error("Mismatching Component ".concat(e.name, " for Provider ").concat(this.name, ".")); if (this.component) throw Error("Component for ".concat(this.name, " has already been provided")); if (this.component = e, this.shouldAutoInitialize()) { if (function (e) { return "EAGER" === e.instantiationMode }(e)) try { this.getOrInitializeService({ instanceIdentifier: Vv }) } catch (sI) { } for (const [e, t] of this.instancesDeferred.entries()) { const n = this.normalizeInstanceIdentifier(e); try { const e = this.getOrInitializeService({ instanceIdentifier: n }); t.resolve(e) } catch (sI) { } } } } clearInstance() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vv; this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete() { const e = Array.from(this.instances.values()); await Promise.all([...e.filter((e => "INTERNAL" in e)).map((e => e.INTERNAL.delete())), ...e.filter((e => "_delete" in e)).map((e => e._delete()))]) } isComponentSet() { return null != this.component } isInitialized() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vv; return this.instances.has(e) } getOptions() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vv; return this.instancesOptions.get(e) || {} } initialize() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { options: t = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(n)) throw Error("".concat(this.name, "(").concat(n, ") has already been initialized")); if (!this.isComponentSet()) throw Error("Component ".concat(this.name, " has not been registered yet")); const r = this.getOrInitializeService({ instanceIdentifier: n, options: t }); for (const [i, s] of this.instancesDeferred.entries()) { n === this.normalizeInstanceIdentifier(i) && s.resolve(r) } return r } onInit(e, t) { var n; const r = this.normalizeInstanceIdentifier(t), i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set; i.add(e), this.onInitCallbacks.set(r, i); const s = this.instances.get(r); return s && e(s, r), () => { i.delete(e) } } invokeOnInitCallbacks(e, t) { const n = this.onInitCallbacks.get(t); if (n) for (const r of n) try { r(e, t) } catch (oI) { } } getOrInitializeService(e) { let { instanceIdentifier: t, options: n = {} } = e, r = this.instances.get(t); if (!r && this.component && (r = this.component.instanceFactory(this.container, { instanceIdentifier: (i = t, i === Vv ? void 0 : i), options: n }), this.instances.set(t, r), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(r, t), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, t, r) } catch (oI) { } var i; return r || null } normalizeInstanceIdentifier() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vv; return this.component ? this.component.multipleInstances ? e : Vv : e } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class qv { constructor(e) { this.name = e, this.providers = new Map } addComponent(e) { const t = this.getProvider(e.name); if (t.isComponentSet()) throw new Error("Component ".concat(e.name, " has already been registered with ").concat(this.name)); t.setComponent(e) } addOrOverwriteComponent(e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) } getProvider(e) { if (this.providers.has(e)) return this.providers.get(e); const t = new zv(e, this); return this.providers.set(e, t), t } getProviders() { return Array.from(this.providers.values()) } } const Hv = []; var Wv; !function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" }(Wv || (Wv = {})); const Kv = { debug: Wv.DEBUG, verbose: Wv.VERBOSE, info: Wv.INFO, warn: Wv.WARN, error: Wv.ERROR, silent: Wv.SILENT }, Gv = Wv.INFO, Qv = { [Wv.DEBUG]: "log", [Wv.VERBOSE]: "log", [Wv.INFO]: "info", [Wv.WARN]: "warn", [Wv.ERROR]: "error" }, Yv = function (e, t) { if (t < e.logLevel) return; const n = (new Date).toISOString(), r = Qv[t]; if (!r) throw new Error("Attempted to log a message with an invalid logType (value: ".concat(t, ")")); for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)s[o - 2] = arguments[o]; console[r]("[".concat(n, "]  ").concat(e.name, ":"), ...s) }; class Jv { constructor(e) { this.name = e, this._logLevel = Gv, this._logHandler = Yv, this._userLogHandler = null, Hv.push(this) } get logLevel() { return this._logLevel } set logLevel(e) { if (!(e in Wv)) throw new TypeError('Invalid value "'.concat(e, '" assigned to `logLevel`')); this._logLevel = e } setLogLevel(e) { this._logLevel = "string" === typeof e ? Kv[e] : e } get logHandler() { return this._logHandler } set logHandler(e) { if ("function" !== typeof e) throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = e } get userLogHandler() { return this._userLogHandler } set userLogHandler(e) { this._userLogHandler = e } debug() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Wv.DEBUG, ...t), this._logHandler(this, Wv.DEBUG, ...t) } log() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Wv.VERBOSE, ...t), this._logHandler(this, Wv.VERBOSE, ...t) } info() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Wv.INFO, ...t), this._logHandler(this, Wv.INFO, ...t) } warn() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Wv.WARN, ...t), this._logHandler(this, Wv.WARN, ...t) } error() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Wv.ERROR, ...t), this._logHandler(this, Wv.ERROR, ...t) } } const Xv = (e, t) => t.some((t => e instanceof t)); let Zv, $v; const ey = new WeakMap, ty = new WeakMap, ny = new WeakMap, ry = new WeakMap, iy = new WeakMap; let sy = { get(e, t, n) { if (e instanceof IDBTransaction) { if ("done" === t) return ty.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || ny.get(e); if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]) } return ly(e[t]) }, set: (e, t, n) => (e[t] = n, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function oy(e) { return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? ($v || ($v = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return e.apply(cy(this), n), ly(ey.get(this)) } : function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return ly(e.apply(cy(this), n)) } : function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; const s = e.call(cy(this), t, ...r); return ny.set(s, t.sort ? t.sort() : [t]), ly(s) } } function ay(e) { return "function" === typeof e ? oy(e) : (e instanceof IDBTransaction && function (e) { if (ty.has(e)) return; const t = new Promise(((t, n) => { const r = () => { e.removeEventListener("complete", i), e.removeEventListener("error", s), e.removeEventListener("abort", s) }, i = () => { t(), r() }, s = () => { n(e.error || new DOMException("AbortError", "AbortError")), r() }; e.addEventListener("complete", i), e.addEventListener("error", s), e.addEventListener("abort", s) })); ty.set(e, t) }(e), Xv(e, Zv || (Zv = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(e, sy) : e) } function ly(e) { if (e instanceof IDBRequest) return function (e) { const t = new Promise(((t, n) => { const r = () => { e.removeEventListener("success", i), e.removeEventListener("error", s) }, i = () => { t(ly(e.result)), r() }, s = () => { n(e.error), r() }; e.addEventListener("success", i), e.addEventListener("error", s) })); return t.then((t => { t instanceof IDBCursor && ey.set(t, e) })).catch((() => { })), iy.set(t, e), t }(e); if (ry.has(e)) return ry.get(e); const t = ay(e); return t !== e && (ry.set(e, t), iy.set(t, e)), t } const cy = e => iy.get(e); const uy = ["get", "getKey", "getAll", "getAllKeys", "count"], dy = ["put", "add", "delete", "clear"], hy = new Map; function fy(e, t) { if (!(e instanceof IDBDatabase) || t in e || "string" !== typeof t) return; if (hy.get(t)) return hy.get(t); const n = t.replace(/FromIndex$/, ""), r = t !== n, i = dy.includes(n); if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !i && !uy.includes(n)) return; const s = async function (e) { const t = this.transaction(e, i ? "readwrite" : "readonly"); let s = t.store; for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)a[l - 1] = arguments[l]; return r && (s = s.index(a.shift())), (await Promise.all([s[n](...a), i && t.done]))[0] }; return hy.set(t, s), s } sy = (e => ({ ...e, get: (t, n, r) => fy(t, n) || e.get(t, n, r), has: (t, n) => !!fy(t, n) || e.has(t, n) }))(sy); class py { constructor(e) { this.container = e } getPlatformInfoString() { return this.container.getProviders().map((e => { if (function (e) { const t = e.getComponent(); return "VERSION" === (null === t || void 0 === t ? void 0 : t.type) }(e)) { const t = e.getImmediate(); return "".concat(t.library, "/").concat(t.version) } return null })).filter((e => e)).join(" ") } } const my = "@firebase/app", gy = "0.10.6", vy = new Jv("@firebase/app"), yy = "[DEFAULT]", by = { [my]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "@firebase/vertexai-preview": "fire-vertex", "fire-js": "fire-js", firebase: "fire-js-all" }, wy = new Map, xy = new Map, Ey = new Map; function Sy(e, t) { try { e.container.addComponent(t) } catch (sI) { vy.debug("Component ".concat(t.name, " failed to register with FirebaseApp ").concat(e.name), sI) } } function Ny(e) { const t = e.name; if (Ey.has(t)) return vy.debug("There were multiple attempts to register component ".concat(t, ".")), !1; Ey.set(t, e); for (const n of wy.values()) Sy(n, e); for (const n of xy.values()) Sy(n, e); return !0 } function Cy(e, t) { const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return n && n.triggerHeartbeat(), e.container.getProvider(t) } function Ty(e) { return void 0 !== e.settings } const Ay = new Pv("app", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}'", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "server-app-deleted": "Firebase Server App has been deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.", "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.", "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments." }); class ky { constructor(e, t, n) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new Bv("app", (() => this), "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(e) { this._isDeleted = e } checkDestroyed() { if (this.isDeleted) throw Ay.create("app-deleted", { appName: this._name }) } } const jy = "10.12.3"; function Py(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e; if ("object" !== typeof t) { t = { name: t } } const r = Object.assign({ name: yy, automaticDataCollectionEnabled: !1 }, t), i = r.name; if ("string" !== typeof i || !i) throw Ay.create("bad-app-name", { appName: String(i) }); if (n || (n = Sv()), !n) throw Ay.create("no-options"); const s = wy.get(i); if (s) { if (Rv(n, s.options) && Rv(r, s.config)) return s; throw Ay.create("duplicate-app", { appName: i }) } const o = new qv(i); for (const l of Ey.values()) o.addComponent(l); const a = new ky(n, r, o); return wy.set(i, a), a } function Iy() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yy; const t = wy.get(e); if (!t && e === yy && Sv()) return Py(); if (!t) throw Ay.create("no-app", { appName: e }); return t } function Ry(e, t, n) { var r; let i = null !== (r = by[e]) && void 0 !== r ? r : e; n && (i += "-".concat(n)); const s = i.match(/\s|\//), o = t.match(/\s|\//); if (s || o) { const e = ['Unable to register library "'.concat(i, '" with version "').concat(t, '":')]; return s && e.push('library name "'.concat(i, '" contains illegal characters (whitespace or "/")')), s && o && e.push("and"), o && e.push('version name "'.concat(t, '" contains illegal characters (whitespace or "/")')), void vy.warn(e.join(" ")) } Ny(new Bv("".concat(i, "-version"), (() => ({ library: i, version: t })), "VERSION")) } const Oy = "firebase-heartbeat-database", Dy = 1, _y = "firebase-heartbeat-store"; let My = null; function Ly() { return My || (My = function (e, t) { let { blocked: n, upgrade: r, blocking: i, terminated: s } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const o = indexedDB.open(e, t), a = ly(o); return r && o.addEventListener("upgradeneeded", (e => { r(ly(o.result), e.oldVersion, e.newVersion, ly(o.transaction), e) })), n && o.addEventListener("blocked", (e => n(e.oldVersion, e.newVersion, e))), a.then((e => { s && e.addEventListener("close", (() => s())), i && e.addEventListener("versionchange", (e => i(e.oldVersion, e.newVersion, e))) })).catch((() => { })), a }(Oy, Dy, { upgrade: (e, t) => { if (0 === t) try { e.createObjectStore(_y) } catch (sI) { console.warn(sI) } } }).catch((e => { throw Ay.create("idb-open", { originalErrorMessage: e.message }) }))), My } async function Fy(e, t) { try { const n = (await Ly()).transaction(_y, "readwrite"), r = n.objectStore(_y); await r.put(t, Uy(e)), await n.done } catch (sI) { if (sI instanceof jv) vy.warn(sI.message); else { const t = Ay.create("idb-set", { originalErrorMessage: null === sI || void 0 === sI ? void 0 : sI.message }); vy.warn(t.message) } } } function Uy(e) { return "".concat(e.name, "!").concat(e.options.appId) } class By { constructor(e) { this.container = e, this._heartbeatsCache = null; const t = this.container.getProvider("app").getImmediate(); this._storage = new zy(t), this._heartbeatsCachePromise = this._storage.read().then((e => (this._heartbeatsCache = e, e))) } async triggerHeartbeat() { var e, t; const n = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), r = Vy(); if ((null != (null === (e = this._heartbeatsCache) || void 0 === e ? void 0 : e.heartbeats) || (this._heartbeatsCache = await this._heartbeatsCachePromise, null != (null === (t = this._heartbeatsCache) || void 0 === t ? void 0 : t.heartbeats))) && this._heartbeatsCache.lastSentHeartbeatDate !== r && !this._heartbeatsCache.heartbeats.some((e => e.date === r))) return this._heartbeatsCache.heartbeats.push({ date: r, agent: n }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((e => { const t = new Date(e.date).valueOf(); return Date.now() - t <= 2592e6 })), this._storage.overwrite(this._heartbeatsCache) } async getHeartbeatsHeader() { var e; if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, null == (null === (e = this._heartbeatsCache) || void 0 === e ? void 0 : e.heartbeats) || 0 === this._heartbeatsCache.heartbeats.length) return ""; const t = Vy(), { heartbeatsToSend: n, unsentEntries: r } = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1024; const n = []; let r = e.slice(); for (const i of e) { const e = n.find((e => e.agent === i.agent)); if (e) { if (e.dates.push(i.date), qy(n) > t) { e.dates.pop(); break } } else if (n.push({ agent: i.agent, dates: [i.date] }), qy(n) > t) { n.pop(); break } r = r.slice(1) } return { heartbeatsToSend: n, unsentEntries: r } }(this._heartbeatsCache.heartbeats), i = yv(JSON.stringify({ version: 2, heartbeats: n })); return this._heartbeatsCache.lastSentHeartbeatDate = t, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i } } function Vy() { return (new Date).toISOString().substring(0, 10) } class zy { constructor(e) { this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return !!kv() && new Promise(((e, t) => { try { let n = !0; const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r); i.onsuccess = () => { i.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0) }, i.onupgradeneeded = () => { n = !1 }, i.onerror = () => { var e; t((null === (e = i.error) || void 0 === e ? void 0 : e.message) || "") } } catch (No) { t(No) } })).then((() => !0)).catch((() => !1)) } async read() { if (await this._canUseIndexedDBPromise) { const e = await async function (e) { try { const t = (await Ly()).transaction(_y), n = await t.objectStore(_y).get(Uy(e)); return await t.done, n } catch (sI) { if (sI instanceof jv) vy.warn(sI.message); else { const t = Ay.create("idb-get", { originalErrorMessage: null === sI || void 0 === sI ? void 0 : sI.message }); vy.warn(t.message) } } }(this.app); return (null === e || void 0 === e ? void 0 : e.heartbeats) ? e : { heartbeats: [] } } return { heartbeats: [] } } async overwrite(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return Fy(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: e.heartbeats }) } } async add(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return Fy(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: [...n.heartbeats, ...e.heartbeats] }) } } } function qy(e) { return yv(JSON.stringify({ version: 2, heartbeats: e })).length } var Hy; Hy = "", Ny(new Bv("platform-logger", (e => new py(e)), "PRIVATE")), Ny(new Bv("heartbeat", (e => new By(e)), "PRIVATE")), Ry(my, gy, Hy), Ry(my, gy, "esm2017"), Ry("fire-js", ""); function Wy(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n } Object.create; Object.create; "function" === typeof SuppressedError && SuppressedError; function Ky() { return { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." } } const Gy = Ky, Qy = new Pv("auth", "Firebase", { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." }), Yy = new Jv("@firebase/auth"); function Jy(e) { if (Yy.logLevel <= Wv.ERROR) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; Yy.error("Auth (".concat(jy, "): ").concat(e), ...n) } } function Xy(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; throw nb(e, ...n) } function Zy(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; return nb(e, ...n) } function $y(e, t, n) { const r = Object.assign(Object.assign({}, Gy()), { [t]: n }); return new Pv("auth", "Firebase", r).create(t, { appName: e.name }) } function eb(e) { return $y(e, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp") } function tb(e, t, n) { if (!(t instanceof n)) throw n.name !== t.constructor.name && Xy(e, "argument-error"), $y(e, "argument-error", "Type of ".concat(t.constructor.name, " does not match expected instance.") + "Did you pass a reference from a different Auth SDK?") } function nb(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; if ("string" !== typeof e) { const t = n[0], r = [...n.slice(1)]; return r[0] && (r[0].appName = e.name), e._errorFactory.create(t, ...r) } return Qy.create(e, ...n) } function rb(e, t) { if (!e) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; throw nb(t, ...r) } } function ib(e) { const t = "INTERNAL ASSERTION FAILED: " + e; throw Jy(t), new Error(t) } function sb(e, t) { e || ib(t) } function ob() { var e; return "undefined" !== typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.href) || "" } function ab() { return "http:" === lb() || "https:" === lb() } function lb() { var e; return "undefined" !== typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.protocol) || null } function cb() { return !("undefined" !== typeof navigator && navigator && "onLine" in navigator && "boolean" === typeof navigator.onLine && (ab() || function () { const e = "object" === typeof chrome ? chrome.runtime : "object" === typeof browser ? browser.runtime : void 0; return "object" === typeof e && void 0 !== e.id }() || "connection" in navigator)) || navigator.onLine } class ub { constructor(e, t) { this.shortDelay = e, this.longDelay = t, sb(t > e, "Short delay should be less than long delay!"), this.isMobile = "undefined" !== typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Tv()) || "object" === typeof navigator && "ReactNative" === navigator.product } get() { return cb() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay) } } function db(e, t) { sb(e.emulator, "Emulator should always be set here"); const { url: n } = e.emulator; return t ? "".concat(n).concat(t.startsWith("/") ? t.slice(1) : t) : n } class hb { static initialize(e, t, n) { this.fetchImpl = e, t && (this.headersImpl = t), n && (this.responseImpl = n) } static fetch() { return this.fetchImpl ? this.fetchImpl : "undefined" !== typeof self && "fetch" in self ? self.fetch : "undefined" !== typeof globalThis && globalThis.fetch ? globalThis.fetch : "undefined" !== typeof fetch ? fetch : void ib("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { return this.headersImpl ? this.headersImpl : "undefined" !== typeof self && "Headers" in self ? self.Headers : "undefined" !== typeof globalThis && globalThis.Headers ? globalThis.Headers : "undefined" !== typeof Headers ? Headers : void ib("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { return this.responseImpl ? this.responseImpl : "undefined" !== typeof self && "Response" in self ? self.Response : "undefined" !== typeof globalThis && globalThis.Response ? globalThis.Response : "undefined" !== typeof Response ? Response : void ib("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } } const fb = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "missing-password", INVALID_LOGIN_CREDENTIALS: "invalid-credential", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error", RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled", MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token", INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token", INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action", MISSING_CLIENT_TYPE: "missing-client-type", MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version", INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version", INVALID_REQ_TYPE: "invalid-req-type" }, pb = new ub(3e4, 6e4); function mb(e, t) { return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), { tenantId: e.tenantId }) : t } async function gb(e, t, n, r) { return vb(e, arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, (async () => { let i = {}, s = {}; r && ("GET" === t ? s = r : i = { body: JSON.stringify(r) }); const o = Dv(Object.assign({ key: e.config.apiKey }, s)).slice(1), a = await e._getAdditionalHeaders(); return a["Content-Type"] = "application/json", e.languageCode && (a["X-Firebase-Locale"] = e.languageCode), hb.fetch()(bb(e, e.config.apiHost, n, o), Object.assign({ method: t, headers: a, referrerPolicy: "no-referrer" }, i)) })) } async function vb(e, t, n) { e._canInitEmulator = !1; const r = Object.assign(Object.assign({}, fb), t); try { const t = new xb(e), i = await Promise.race([n(), t.promise]); t.clearNetworkTimeout(); const s = await i.json(); if ("needConfirmation" in s) throw Eb(e, "account-exists-with-different-credential", s); if (i.ok && !("errorMessage" in s)) return s; { const t = i.ok ? s.errorMessage : s.error.message, [n, o] = t.split(" : "); if ("FEDERATED_USER_ID_ALREADY_LINKED" === n) throw Eb(e, "credential-already-in-use", s); if ("EMAIL_EXISTS" === n) throw Eb(e, "email-already-in-use", s); if ("USER_DISABLED" === n) throw Eb(e, "user-disabled", s); const a = r[n] || n.toLowerCase().replace(/[_\s]+/g, "-"); if (o) throw $y(e, a, o); Xy(e, a) } } catch (sI) { if (sI instanceof jv) throw sI; Xy(e, "network-request-failed", { message: String(sI) }) } } async function yb(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; const s = await gb(e, t, n, r, i); return "mfaPendingCredential" in s && Xy(e, "multi-factor-auth-required", { _serverResponse: s }), s } function bb(e, t, n, r) { const i = "".concat(t).concat(n, "?").concat(r); return e.config.emulator ? db(e.config, i) : "".concat(e.config.apiScheme, "://").concat(i) } function wb(e) { switch (e) { case "ENFORCE": return "ENFORCE"; case "AUDIT": return "AUDIT"; case "OFF": return "OFF"; default: return "ENFORCEMENT_STATE_UNSPECIFIED" } } class xb { constructor(e) { this.auth = e, this.timer = null, this.promise = new Promise(((e, t) => { this.timer = setTimeout((() => t(Zy(this.auth, "network-request-failed"))), pb.get()) })) } clearNetworkTimeout() { clearTimeout(this.timer) } } function Eb(e, t, n) { const r = { appName: e.name }; n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber); const i = Zy(e, t, r); return i.customData._tokenResponse = n, i } function Sb(e) { return void 0 !== e && void 0 !== e.enterprise } class Nb { constructor(e) { if (this.siteKey = "", this.recaptchaEnforcementState = [], void 0 === e.recaptchaKey) throw new Error("recaptchaKey undefined"); this.siteKey = e.recaptchaKey.split("/")[3], this.recaptchaEnforcementState = e.recaptchaEnforcementState } getProviderEnforcementState(e) { if (!this.recaptchaEnforcementState || 0 === this.recaptchaEnforcementState.length) return null; for (const t of this.recaptchaEnforcementState) if (t.provider && t.provider === e) return wb(t.enforcementState); return null } isProviderEnabled(e) { return "ENFORCE" === this.getProviderEnforcementState(e) || "AUDIT" === this.getProviderEnforcementState(e) } } async function Cb(e, t) { return gb(e, "GET", "/v2/recaptchaConfig", mb(e, t)) } async function Tb(e, t) { return gb(e, "POST", "/v1/accounts:lookup", t) } function Ab(e) { if (e) try { const t = new Date(Number(e)); if (!isNaN(t.getTime())) return t.toUTCString() } catch (sI) { } } function kb(e) { return 1e3 * Number(e) } function jb(e) { const [t, n, r] = e.split("."); if (void 0 === t || void 0 === n || void 0 === r) return Jy("JWT malformed, contained fewer than 3 sections"), null; try { const e = bv(n); return e ? JSON.parse(e) : (Jy("Failed to decode base64 JWT payload"), null) } catch (sI) { return Jy("Caught error parsing JWT payload as JSON", null === sI || void 0 === sI ? void 0 : sI.toString()), null } } function Pb(e) { const t = jb(e); return rb(t, "internal-error"), rb("undefined" !== typeof t.exp, "internal-error"), rb("undefined" !== typeof t.iat, "internal-error"), Number(t.exp) - Number(t.iat) } async function Ib(e, t) { if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) return t; try { return await t } catch (sI) { throw sI instanceof jv && function (e) { let { code: t } = e; return t === "auth/".concat("user-disabled") || t === "auth/".concat("user-token-expired") }(sI) && e.auth.currentUser === e && await e.auth.signOut(), sI } } class Rb { constructor(e) { this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId)) } getInterval(e) { var t; if (e) { const e = this.errorBackoff; return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), e } { this.errorBackoff = 3e4; const e = (null !== (t = this.user.stsTokenManager.expirationTime) && void 0 !== t ? t : 0) - Date.now() - 3e5; return Math.max(0, e) } } schedule() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (!this.isRunning) return; const t = this.getInterval(e); this.timerId = setTimeout((async () => { await this.iteration() }), t) } async iteration() { try { await this.user.getIdToken(!0) } catch (sI) { return void ((null === sI || void 0 === sI ? void 0 : sI.code) === "auth/".concat("network-request-failed") && this.schedule(!0)) } this.schedule() } } class Ob { constructor(e, t) { this.createdAt = e, this.lastLoginAt = t, this._initializeTime() } _initializeTime() { this.lastSignInTime = Ab(this.lastLoginAt), this.creationTime = Ab(this.createdAt) } _copy(e) { this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } } async function Db(e) { var t; const n = e.auth, r = await e.getIdToken(), i = await Ib(e, Tb(n, { idToken: r })); rb(null === i || void 0 === i ? void 0 : i.users.length, n, "internal-error"); const s = i.users[0]; e._notifyReloadListener(s); const o = (null === (t = s.providerUserInfo) || void 0 === t ? void 0 : t.length) ? _b(s.providerUserInfo) : [], a = function (e, t) { const n = e.filter((e => !t.some((t => t.providerId === e.providerId)))); return [...n, ...t] }(e.providerData, o), l = e.isAnonymous, c = !(e.email && s.passwordHash) && !(null === a || void 0 === a ? void 0 : a.length), u = !!l && c, d = { uid: s.localId, displayName: s.displayName || null, photoURL: s.photoUrl || null, email: s.email || null, emailVerified: s.emailVerified || !1, phoneNumber: s.phoneNumber || null, tenantId: s.tenantId || null, providerData: a, metadata: new Ob(s.createdAt, s.lastLoginAt), isAnonymous: u }; Object.assign(e, d) } function _b(e) { return e.map((e => { var { providerId: t } = e, n = Wy(e, ["providerId"]); return { providerId: t, uid: n.rawId || "", displayName: n.displayName || null, email: n.email || null, phoneNumber: n.phoneNumber || null, photoURL: n.photoUrl || null } })) } class Mb { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(e) { rb(e.idToken, "internal-error"), rb("undefined" !== typeof e.idToken, "internal-error"), rb("undefined" !== typeof e.refreshToken, "internal-error"); const t = "expiresIn" in e && "undefined" !== typeof e.expiresIn ? Number(e.expiresIn) : Pb(e.idToken); this.updateTokensAndExpiration(e.idToken, e.refreshToken, t) } updateFromIdToken(e) { rb(0 !== e.length, "internal-error"); const t = Pb(e); this.updateTokensAndExpiration(e, null, t) } async getToken(e) { return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] || !this.accessToken || this.isExpired ? (rb(this.refreshToken, e, "user-token-expired"), this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null) : this.accessToken } clearRefreshToken() { this.refreshToken = null } async refresh(e, t) { const { accessToken: n, refreshToken: r, expiresIn: i } = await async function (e, t) { const n = await vb(e, {}, (async () => { const n = Dv({ grant_type: "refresh_token", refresh_token: t }).slice(1), { tokenApiHost: r, apiKey: i } = e.config, s = bb(e, r, "/v1/token", "key=".concat(i)), o = await e._getAdditionalHeaders(); return o["Content-Type"] = "application/x-www-form-urlencoded", hb.fetch()(s, { method: "POST", headers: o, body: n }) })); return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token } }(e, t); this.updateTokensAndExpiration(n, r, Number(i)) } updateTokensAndExpiration(e, t, n) { this.refreshToken = t || null, this.accessToken = e || null, this.expirationTime = Date.now() + 1e3 * n } static fromJSON(e, t) { const { refreshToken: n, accessToken: r, expirationTime: i } = t, s = new Mb; return n && (rb("string" === typeof n, "internal-error", { appName: e }), s.refreshToken = n), r && (rb("string" === typeof r, "internal-error", { appName: e }), s.accessToken = r), i && (rb("number" === typeof i, "internal-error", { appName: e }), s.expirationTime = i), s } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(e) { this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime } _clone() { return Object.assign(new Mb, this.toJSON()) } _performRefresh() { return ib("not implemented") } } function Lb(e, t) { rb("string" === typeof e || "undefined" === typeof e, "internal-error", { appName: t }) } class Fb { constructor(e) { var { uid: t, auth: n, stsTokenManager: r } = e, i = Wy(e, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new Rb(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = t, this.auth = n, this.stsTokenManager = r, this.accessToken = r.accessToken, this.displayName = i.displayName || null, this.email = i.email || null, this.emailVerified = i.emailVerified || !1, this.phoneNumber = i.phoneNumber || null, this.photoURL = i.photoURL || null, this.isAnonymous = i.isAnonymous || !1, this.tenantId = i.tenantId || null, this.providerData = i.providerData ? [...i.providerData] : [], this.metadata = new Ob(i.createdAt || void 0, i.lastLoginAt || void 0) } async getIdToken(e) { const t = await Ib(this, this.stsTokenManager.getToken(this.auth, e)); return rb(t, this.auth, "internal-error"), this.accessToken !== t && (this.accessToken = t, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), t } getIdTokenResult(e) { return async function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = Uv(e), r = await n.getIdToken(t), i = jb(r); rb(i && i.exp && i.auth_time && i.iat, n.auth, "internal-error"); const s = "object" === typeof i.firebase ? i.firebase : void 0, o = null === s || void 0 === s ? void 0 : s.sign_in_provider; return { claims: i, token: r, authTime: Ab(kb(i.auth_time)), issuedAtTime: Ab(kb(i.iat)), expirationTime: Ab(kb(i.exp)), signInProvider: o || null, signInSecondFactor: (null === s || void 0 === s ? void 0 : s.sign_in_second_factor) || null } }(this, e) } reload() { return async function (e) { const t = Uv(e); await Db(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t) }(this) } _assign(e) { this !== e && (rb(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map((e => Object.assign({}, e))), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager)) } _clone(e) { const t = new Fb(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() })); return t.metadata._copy(this.metadata), t } _onReload(e) { rb(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(e) { this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } async _updateTokensIfNecessary(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = !1; e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), t && await Db(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this) } async delete() { if (Ty(this.auth.app)) return Promise.reject(eb(this.auth)); const e = await this.getIdToken(); return await Ib(this, async function (e, t) { return gb(e, "POST", "/v1/accounts:delete", t) }(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map((e => Object.assign({}, e))), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(e, t) { var n, r, i, s, o, a, l, c; const u = null !== (n = t.displayName) && void 0 !== n ? n : void 0, d = null !== (r = t.email) && void 0 !== r ? r : void 0, h = null !== (i = t.phoneNumber) && void 0 !== i ? i : void 0, f = null !== (s = t.photoURL) && void 0 !== s ? s : void 0, p = null !== (o = t.tenantId) && void 0 !== o ? o : void 0, m = null !== (a = t._redirectEventId) && void 0 !== a ? a : void 0, g = null !== (l = t.createdAt) && void 0 !== l ? l : void 0, v = null !== (c = t.lastLoginAt) && void 0 !== c ? c : void 0, { uid: y, emailVerified: b, isAnonymous: w, providerData: x, stsTokenManager: E } = t; rb(y && E, e, "internal-error"); const S = Mb.fromJSON(this.name, E); rb("string" === typeof y, e, "internal-error"), Lb(u, e.name), Lb(d, e.name), rb("boolean" === typeof b, e, "internal-error"), rb("boolean" === typeof w, e, "internal-error"), Lb(h, e.name), Lb(f, e.name), Lb(p, e.name), Lb(m, e.name), Lb(g, e.name), Lb(v, e.name); const N = new Fb({ uid: y, auth: e, email: d, emailVerified: b, displayName: u, isAnonymous: w, photoURL: f, phoneNumber: h, tenantId: p, stsTokenManager: S, createdAt: g, lastLoginAt: v }); return x && Array.isArray(x) && (N.providerData = x.map((e => Object.assign({}, e)))), m && (N._redirectEventId = m), N } static async _fromIdTokenResponse(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = new Mb; r.updateFromServerResponse(t); const i = new Fb({ uid: t.localId, auth: e, stsTokenManager: r, isAnonymous: n }); return await Db(i), i } static async _fromGetAccountInfoResponse(e, t, n) { const r = t.users[0]; rb(void 0 !== r.localId, "internal-error"); const i = void 0 !== r.providerUserInfo ? _b(r.providerUserInfo) : [], s = !(r.email && r.passwordHash) && !(null === i || void 0 === i ? void 0 : i.length), o = new Mb; o.updateFromIdToken(n); const a = new Fb({ uid: r.localId, auth: e, stsTokenManager: o, isAnonymous: s }), l = { uid: r.localId, displayName: r.displayName || null, photoURL: r.photoUrl || null, email: r.email || null, emailVerified: r.emailVerified || !1, phoneNumber: r.phoneNumber || null, tenantId: r.tenantId || null, providerData: i, metadata: new Ob(r.createdAt, r.lastLoginAt), isAnonymous: !(r.email && r.passwordHash) && !(null === i || void 0 === i ? void 0 : i.length) }; return Object.assign(a, l), a } } const Ub = new Map; function Bb(e) { sb(e instanceof Function, "Expected a class definition"); let t = Ub.get(e); return t ? (sb(t instanceof e, "Instance stored in cache mismatched with class"), t) : (t = new e, Ub.set(e, t), t) } class Vb { constructor() { this.type = "NONE", this.storage = {} } async _isAvailable() { return !0 } async _set(e, t) { this.storage[e] = t } async _get(e) { const t = this.storage[e]; return void 0 === t ? null : t } async _remove(e) { delete this.storage[e] } _addListener(e, t) { } _removeListener(e, t) { } } Vb.type = "NONE"; const zb = Vb; function qb(e, t, n) { return "firebase".concat(":", e, ":").concat(t, ":").concat(n) } class Hb { constructor(e, t, n) { this.persistence = e, this.auth = t, this.userKey = n; const { config: r, name: i } = this.auth; this.fullUserKey = qb(this.userKey, r.apiKey, i), this.fullPersistenceKey = qb("persistence", r.apiKey, i), this.boundEventHandler = t._onStorageEvent.bind(t), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(e) { return this.persistence._set(this.fullUserKey, e.toJSON()) } async getCurrentUser() { const e = await this.persistence._get(this.fullUserKey); return e ? Fb._fromJSON(this.auth, e) : null } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } async setPersistence(e) { if (this.persistence === e) return; const t = await this.getCurrentUser(); return await this.removeCurrentUser(), this.persistence = e, t ? this.setCurrentUser(t) : void 0 } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static async create(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "authUser"; if (!t.length) return new Hb(Bb(zb), e, n); const r = (await Promise.all(t.map((async e => { if (await e._isAvailable()) return e })))).filter((e => e)); let i = r[0] || Bb(zb); const s = qb(n, e.config.apiKey, e.name); let o = null; for (const l of t) try { const t = await l._get(s); if (t) { const n = Fb._fromJSON(e, t); l !== i && (o = n), i = l; break } } catch (oI) { } const a = r.filter((e => e._shouldAllowMigration)); return i._shouldAllowMigration && a.length ? (i = a[0], o && await i._set(s, o.toJSON()), await Promise.all(t.map((async e => { if (e !== i) try { await e._remove(s) } catch (oI) { } }))), new Hb(i, e, n)) : new Hb(i, e, n) } } function Wb(e) { const t = e.toLowerCase(); if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/")) return "Opera"; if (Yb(t)) return "IEMobile"; if (t.includes("msie") || t.includes("trident/")) return "IE"; if (t.includes("edge/")) return "Edge"; if (Kb(t)) return "Firefox"; if (t.includes("silk/")) return "Silk"; if (Xb(t)) return "Blackberry"; if (Zb(t)) return "Webos"; if (Gb(t)) return "Safari"; if ((t.includes("chrome/") || Qb(t)) && !t.includes("edge/")) return "Chrome"; if (Jb(t)) return "Android"; { const t = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, n = e.match(t); if (2 === (null === n || void 0 === n ? void 0 : n.length)) return n[1] } return "Other" } function Kb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /firefox\//i.test(e) } function Gb() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv()).toLowerCase(); return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android") } function Qb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /crios\//i.test(e) } function Yb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /iemobile/i.test(e) } function Jb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /android/i.test(e) } function Xb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /blackberry/i.test(e) } function Zb() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /webos/i.test(e) } function $b() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e) } function ew() { return function () { const e = Tv(); return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0 }() && 10 === document.documentMode } function tw() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv(); return $b(e) || Jb(e) || Zb(e) || Xb(e) || /windows phone/i.test(e) || Yb(e) } function nw(e) { let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; switch (e) { case "Browser": t = Wb(Tv()); break; case "Worker": t = "".concat(Wb(Tv()), "-").concat(e); break; default: t = e }const r = n.length ? n.join(",") : "FirebaseCore-web"; return "".concat(t, "/", "JsCore", "/").concat(jy, "/").concat(r) } class rw { constructor(e) { this.auth = e, this.queue = [] } pushCallback(e, t) { const n = t => new Promise(((n, r) => { try { n(e(t)) } catch (sI) { r(sI) } })); n.onAbort = t, this.queue.push(n); const r = this.queue.length - 1; return () => { this.queue[r] = () => Promise.resolve() } } async runMiddleware(e) { if (this.auth.currentUser === e) return; const t = []; try { for (const n of this.queue) await n(e), n.onAbort && t.push(n.onAbort) } catch (sI) { t.reverse(); for (const r of t) try { r() } catch (n) { } throw this.auth._errorFactory.create("login-blocked", { originalMessage: null === sI || void 0 === sI ? void 0 : sI.message }) } } } class iw { constructor(e) { var t, n, r, i; const s = e.customStrengthOptions; this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = null !== (t = s.minPasswordLength) && void 0 !== t ? t : 6, s.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = s.maxPasswordLength), void 0 !== s.containsLowercaseCharacter && (this.customStrengthOptions.containsLowercaseLetter = s.containsLowercaseCharacter), void 0 !== s.containsUppercaseCharacter && (this.customStrengthOptions.containsUppercaseLetter = s.containsUppercaseCharacter), void 0 !== s.containsNumericCharacter && (this.customStrengthOptions.containsNumericCharacter = s.containsNumericCharacter), void 0 !== s.containsNonAlphanumericCharacter && (this.customStrengthOptions.containsNonAlphanumericCharacter = s.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, "ENFORCEMENT_STATE_UNSPECIFIED" === this.enforcementState && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = null !== (r = null === (n = e.allowedNonAlphanumericCharacters) || void 0 === n ? void 0 : n.join("")) && void 0 !== r ? r : "", this.forceUpgradeOnSignin = null !== (i = e.forceUpgradeOnSignin) && void 0 !== i && i, this.schemaVersion = e.schemaVersion } validatePassword(e) { var t, n, r, i, s, o; const a = { isValid: !0, passwordPolicy: this }; return this.validatePasswordLengthOptions(e, a), this.validatePasswordCharacterOptions(e, a), a.isValid && (a.isValid = null === (t = a.meetsMinPasswordLength) || void 0 === t || t), a.isValid && (a.isValid = null === (n = a.meetsMaxPasswordLength) || void 0 === n || n), a.isValid && (a.isValid = null === (r = a.containsLowercaseLetter) || void 0 === r || r), a.isValid && (a.isValid = null === (i = a.containsUppercaseLetter) || void 0 === i || i), a.isValid && (a.isValid = null === (s = a.containsNumericCharacter) || void 0 === s || s), a.isValid && (a.isValid = null === (o = a.containsNonAlphanumericCharacter) || void 0 === o || o), a } validatePasswordLengthOptions(e, t) { const n = this.customStrengthOptions.minPasswordLength, r = this.customStrengthOptions.maxPasswordLength; n && (t.meetsMinPasswordLength = e.length >= n), r && (t.meetsMaxPasswordLength = e.length <= r) } validatePasswordCharacterOptions(e, t) { let n; this.updatePasswordCharacterOptionsStatuses(t, !1, !1, !1, !1); for (let r = 0; r < e.length; r++)n = e.charAt(r), this.updatePasswordCharacterOptionsStatuses(t, n >= "a" && n <= "z", n >= "A" && n <= "Z", n >= "0" && n <= "9", this.allowedNonAlphanumericCharacters.includes(n)) } updatePasswordCharacterOptionsStatuses(e, t, n, r, i) { this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = t)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = n)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = r)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = i)) } } class sw { constructor(e, t, n, r) { this.app = e, this.heartbeatServiceProvider = t, this.appCheckServiceProvider = n, this.config = r, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new aw(this), this.idTokenSubscription = new aw(this), this.beforeStateQueue = new rw(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = Qy, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = r.sdkClientVersion } _initializeWithPersistence(e, t) { return t && (this._popupRedirectResolver = Bb(t)), this._initializationPromise = this.queue((async () => { var n, r; if (!this._deleted && (this.persistenceManager = await Hb.create(this, e), !this._deleted)) { if (null === (n = this._popupRedirectResolver) || void 0 === n ? void 0 : n._shouldInitProactively) try { await this._popupRedirectResolver._initialize(this) } catch (sI) { } await this.initializeCurrentUser(t), this.lastNotifiedUid = (null === (r = this.currentUser) || void 0 === r ? void 0 : r.uid) || null, this._deleted || (this._isInitialized = !0) } })), this._initializationPromise } async _onStorageEvent() { if (this._deleted) return; const e = await this.assertedPersistence.getCurrentUser(); return this.currentUser || e ? this.currentUser && e && this.currentUser.uid === e.uid ? (this._currentUser._assign(e), void await this.currentUser.getIdToken()) : void await this._updateCurrentUser(e, !0) : void 0 } async initializeCurrentUserFromIdToken(e) { try { const t = await Tb(this, { idToken: e }), n = await Fb._fromGetAccountInfoResponse(this, t, e); await this.directlySetCurrentUser(n) } catch (t) { console.warn("FirebaseServerApp could not login user with provided authIdToken: ", t), await this.directlySetCurrentUser(null) } } async initializeCurrentUser(e) { var t; if (Ty(this.app)) { const e = this.app.settings.authIdToken; return e ? new Promise((t => { setTimeout((() => this.initializeCurrentUserFromIdToken(e).then(t, t))) })) : this.directlySetCurrentUser(null) } const n = await this.assertedPersistence.getCurrentUser(); let r = n, i = !1; if (e && this.config.authDomain) { await this.getOrInitRedirectPersistenceManager(); const n = null === (t = this.redirectUser) || void 0 === t ? void 0 : t._redirectEventId, s = null === r || void 0 === r ? void 0 : r._redirectEventId, o = await this.tryRedirectSignIn(e); n && n !== s || !(null === o || void 0 === o ? void 0 : o.user) || (r = o.user, i = !0) } if (!r) return this.directlySetCurrentUser(null); if (!r._redirectEventId) { if (i) try { await this.beforeStateQueue.runMiddleware(r) } catch (sI) { r = n, this._popupRedirectResolver._overrideRedirectResult(this, (() => Promise.reject(sI))) } return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null) } return rb(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId ? this.directlySetCurrentUser(r) : this.reloadAndSetCurrentUserOrClear(r) } async tryRedirectSignIn(e) { let t = null; try { t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0) } catch (sI) { await this._setRedirectUser(null) } return t } async reloadAndSetCurrentUserOrClear(e) { try { await Db(e) } catch (sI) { if ((null === sI || void 0 === sI ? void 0 : sI.code) !== "auth/".concat("network-request-failed")) return this.directlySetCurrentUser(null) } return this.directlySetCurrentUser(e) } useDeviceLanguage() { this.languageCode = function () { if ("undefined" === typeof navigator) return null; const e = navigator; return e.languages && e.languages[0] || e.language || null }() } async _delete() { this._deleted = !0 } async updateCurrentUser(e) { if (Ty(this.app)) return Promise.reject(eb(this)); const t = e ? Uv(e) : null; return t && rb(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(t && t._clone(this)) } async _updateCurrentUser(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!this._deleted) return e && rb(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), t || await this.beforeStateQueue.runMiddleware(e), this.queue((async () => { await this.directlySetCurrentUser(e), this.notifyAuthListeners() })) } async signOut() { return Ty(this.app) ? Promise.reject(eb(this)) : (await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)) } setPersistence(e) { return Ty(this.app) ? Promise.reject(eb(this)) : this.queue((async () => { await this.assertedPersistence.setPersistence(Bb(e)) })) } _getRecaptchaConfig() { return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId] } async validatePassword(e) { this._getPasswordPolicyInternal() || await this._updatePasswordPolicy(); const t = this._getPasswordPolicyInternal(); return t.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : t.validatePassword(e) } _getPasswordPolicyInternal() { return null === this.tenantId ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId] } async _updatePasswordPolicy() { const e = await async function (e) { return gb(e, "GET", "/v2/passwordPolicy", mb(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})) }(this), t = new iw(e); null === this.tenantId ? this._projectPasswordPolicy = t : this._tenantPasswordPolicies[this.tenantId] = t } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(e) { this._errorFactory = new Pv("auth", "Firebase", e()) } onAuthStateChanged(e, t, n) { return this.registerStateListener(this.authStateSubscription, e, t, n) } beforeAuthStateChanged(e, t) { return this.beforeStateQueue.pushCallback(e, t) } onIdTokenChanged(e, t, n) { return this.registerStateListener(this.idTokenSubscription, e, t, n) } authStateReady() { return new Promise(((e, t) => { if (this.currentUser) e(); else { const n = this.onAuthStateChanged((() => { n(), e() }), t) } })) } async revokeAccessToken(e) { if (this.currentUser) { const t = { providerId: "apple.com", tokenType: "ACCESS_TOKEN", token: e, idToken: await this.currentUser.getIdToken() }; null != this.tenantId && (t.tenantId = this.tenantId), await async function (e, t) { return gb(e, "POST", "/v2/accounts:revokeToken", mb(e, t)) }(this, t) } } toJSON() { var e; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: null === (e = this._currentUser) || void 0 === e ? void 0 : e.toJSON() } } async _setRedirectUser(e, t) { const n = await this.getOrInitRedirectPersistenceManager(t); return null === e ? n.removeCurrentUser() : n.setCurrentUser(e) } async getOrInitRedirectPersistenceManager(e) { if (!this.redirectPersistenceManager) { const t = e && Bb(e) || this._popupRedirectResolver; rb(t, this, "argument-error"), this.redirectPersistenceManager = await Hb.create(this, [Bb(t._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser() } return this.redirectPersistenceManager } async _redirectUserForId(e) { var t, n; return this._isInitialized && await this.queue((async () => { })), (null === (t = this._currentUser) || void 0 === t ? void 0 : t._redirectEventId) === e ? this._currentUser : (null === (n = this.redirectUser) || void 0 === n ? void 0 : n._redirectEventId) === e ? this.redirectUser : null } async _persistUserIfCurrent(e) { if (e === this.currentUser) return this.queue((async () => this.directlySetCurrentUser(e))) } _notifyListenersIfCurrent(e) { e === this.currentUser && this.notifyAuthListeners() } _key() { return "".concat(this.config.authDomain, ":").concat(this.config.apiKey, ":").concat(this.name) } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var e, t; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); const n = null !== (t = null === (e = this.currentUser) || void 0 === e ? void 0 : e.uid) && void 0 !== t ? t : null; this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser)) } registerStateListener(e, t, n, r) { if (this._deleted) return () => { }; const i = "function" === typeof t ? t : t.next.bind(t); let s = !1; const o = this._isInitialized ? Promise.resolve() : this._initializationPromise; if (rb(o, this, "internal-error"), o.then((() => { s || i(this.currentUser) })), "function" === typeof t) { const i = e.addObserver(t, n, r); return () => { s = !0, i() } } { const n = e.addObserver(t); return () => { s = !0, n() } } } async directlySetCurrentUser(e) { this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser() } queue(e) { return this.operations = this.operations.then(e, e), this.operations } get assertedPersistence() { return rb(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(e) { e && !this.frameworks.includes(e) && (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = nw(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } async _getAdditionalHeaders() { var e; const t = { "X-Client-Version": this.clientVersion }; this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId); const n = await (null === (e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) || void 0 === e ? void 0 : e.getHeartbeatsHeader()); n && (t["X-Firebase-Client"] = n); const r = await this._getAppCheckToken(); return r && (t["X-Firebase-AppCheck"] = r), t } async _getAppCheckToken() { var e; const t = await (null === (e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) || void 0 === e ? void 0 : e.getToken()); return (null === t || void 0 === t ? void 0 : t.error) && function (e) { if (Yy.logLevel <= Wv.WARN) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; Yy.warn("Auth (".concat(jy, "): ").concat(e), ...n) } }("Error while retrieving App Check token: ".concat(t.error)), null === t || void 0 === t ? void 0 : t.token } } function ow(e) { return Uv(e) } class aw { constructor(e) { this.auth = e, this.observer = null, this.addObserver = function (e, t) { const n = new Lv(e, t); return n.subscribe.bind(n) }((e => this.observer = e)) } get next() { return rb(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } } let lw = { async loadJS() { throw new Error("Unable to load external scripts") }, recaptchaV2Script: "", recaptchaEnterpriseScript: "", gapiScript: "" }; function cw(e) { return lw.loadJS(e) } function uw(e) { return "__".concat(e).concat(Math.floor(1e6 * Math.random())) } class dw { constructor(e) { this.type = "recaptcha-enterprise", this.auth = ow(e) } async verify() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "verify", t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; function n(t, n, r) { const i = window.grecaptcha; Sb(i) ? i.enterprise.ready((() => { i.enterprise.execute(t, { action: e }).then((e => { n(e) })).catch((() => { n("NO_RECAPTCHA") })) })) : r(Error("No reCAPTCHA enterprise script loaded.")) } return new Promise(((e, r) => { (async function (e) { if (!t) { if (null == e.tenantId && null != e._agentRecaptchaConfig) return e._agentRecaptchaConfig.siteKey; if (null != e.tenantId && void 0 !== e._tenantRecaptchaConfigs[e.tenantId]) return e._tenantRecaptchaConfigs[e.tenantId].siteKey } return new Promise((async (t, n) => { Cb(e, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" }).then((r => { if (void 0 !== r.recaptchaKey) { const n = new Nb(r); return null == e.tenantId ? e._agentRecaptchaConfig = n : e._tenantRecaptchaConfigs[e.tenantId] = n, t(n.siteKey) } n(new Error("recaptcha Enterprise site key undefined")) })).catch((e => { n(e) })) })) })(this.auth).then((i => { if (!t && Sb(window.grecaptcha)) n(i, e, r); else { if ("undefined" === typeof window) return void r(new Error("RecaptchaVerifier is only supported in browser")); let t = lw.recaptchaEnterpriseScript; 0 !== t.length && (t += i), cw(t).then((() => { n(i, e, r) })).catch((e => { r(e) })) } })).catch((e => { r(e) })) })) } } async function hw(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const i = new dw(e); let s; try { s = await i.verify(n) } catch (No) { s = await i.verify(n, !0) } const o = Object.assign({}, t); return r ? Object.assign(o, { captchaResp: s }) : Object.assign(o, { captchaResponse: s }), Object.assign(o, { clientType: "CLIENT_TYPE_WEB" }), Object.assign(o, { recaptchaVersion: "RECAPTCHA_ENTERPRISE" }), o } async function fw(e, t, n, r) { var i; if (null === (i = e._getRecaptchaConfig()) || void 0 === i ? void 0 : i.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")) { const i = await hw(e, t, n, "getOobCode" === n); return r(e, i) } return r(e, t).catch((async i => { if (i.code === "auth/".concat("missing-recaptcha-token")) { console.log("".concat(n, " is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.")); const i = await hw(e, t, n, "getOobCode" === n); return r(e, i) } return Promise.reject(i) })) } function pw(e, t, n) { const r = ow(e); rb(r._canInitEmulator, r, "emulator-config-failed"), rb(/^https?:\/\//.test(t), r, "invalid-emulator-scheme"); const i = !!(null === n || void 0 === n ? void 0 : n.disableWarnings), s = mw(t), { host: o, port: a } = function (e) { const t = mw(e), n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length)); if (!n) return { host: "", port: null }; const r = n[2].split("@").pop() || "", i = /^(\[[^\]]+\])(:|$)/.exec(r); if (i) { const e = i[1]; return { host: e, port: gw(r.substr(e.length + 1)) } } { const [e, t] = r.split(":"); return { host: e, port: gw(t) } } }(t), l = null === a ? "" : ":".concat(a); r.config.emulator = { url: "".concat(s, "//").concat(o).concat(l, "/") }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({ host: o, port: a, protocol: s.replace(":", ""), options: Object.freeze({ disableWarnings: i }) }), i || function () { function e() { const e = document.createElement("p"), t = e.style; e.innerText = "Running in emulator mode. Do not use with production credentials.", t.position = "fixed", t.width = "100%", t.backgroundColor = "#ffffff", t.border = ".1em solid #000000", t.color = "#b50000", t.bottom = "0px", t.left = "0px", t.margin = "0px", t.zIndex = "10000", t.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e) } "undefined" !== typeof console && "function" === typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."); "undefined" !== typeof window && "undefined" !== typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", e) : e()) }() } function mw(e) { const t = e.indexOf(":"); return t < 0 ? "" : e.substr(0, t + 1) } function gw(e) { if (!e) return null; const t = Number(e); return isNaN(t) ? null : t } class vw { constructor(e, t) { this.providerId = e, this.signInMethod = t } toJSON() { return ib("not implemented") } _getIdTokenResponse(e) { return ib("not implemented") } _linkToIdToken(e, t) { return ib("not implemented") } _getReauthenticationResolver(e) { return ib("not implemented") } } async function yw(e, t) { return gb(e, "POST", "/v1/accounts:signUp", t) } async function bw(e, t) { return yb(e, "POST", "/v1/accounts:signInWithPassword", mb(e, t)) } class ww extends vw { constructor(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; super("password", n), this._email = e, this._password = t, this._tenantId = r } static _fromEmailAndPassword(e, t) { return new ww(e, t, "password") } static _fromEmailAndCode(e, t) { return new ww(e, t, "emailLink", arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(e) { const t = "string" === typeof e ? JSON.parse(e) : e; if ((null === t || void 0 === t ? void 0 : t.email) && (null === t || void 0 === t ? void 0 : t.password)) { if ("password" === t.signInMethod) return this._fromEmailAndPassword(t.email, t.password); if ("emailLink" === t.signInMethod) return this._fromEmailAndCode(t.email, t.password, t.tenantId) } return null } async _getIdTokenResponse(e) { switch (this.signInMethod) { case "password": return fw(e, { returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }, "signInWithPassword", bw); case "emailLink": return async function (e, t) { return yb(e, "POST", "/v1/accounts:signInWithEmailLink", mb(e, t)) }(e, { email: this._email, oobCode: this._password }); default: Xy(e, "internal-error") } } async _linkToIdToken(e, t) { switch (this.signInMethod) { case "password": return fw(e, { idToken: t, returnSecureToken: !0, email: this._email, password: this._password, clientType: "CLIENT_TYPE_WEB" }, "signUpPassword", yw); case "emailLink": return async function (e, t) { return yb(e, "POST", "/v1/accounts:signInWithEmailLink", mb(e, t)) }(e, { idToken: t, email: this._email, oobCode: this._password }); default: Xy(e, "internal-error") } } _getReauthenticationResolver(e) { return this._getIdTokenResponse(e) } } async function xw(e, t) { return yb(e, "POST", "/v1/accounts:signInWithIdp", mb(e, t)) } class Ew extends vw { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(e) { const t = new Ew(e.providerId, e.signInMethod); return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken), e.accessToken && (t.accessToken = e.accessToken), e.nonce && !e.pendingToken && (t.nonce = e.nonce), e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken, t.secret = e.oauthTokenSecret) : Xy("argument-error"), t } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(e) { const t = "string" === typeof e ? JSON.parse(e) : e, { providerId: n, signInMethod: r } = t, i = Wy(t, ["providerId", "signInMethod"]); if (!n || !r) return null; const s = new Ew(n, r); return s.idToken = i.idToken || void 0, s.accessToken = i.accessToken || void 0, s.secret = i.secret, s.nonce = i.nonce, s.pendingToken = i.pendingToken || null, s } _getIdTokenResponse(e) { return xw(e, this.buildRequest()) } _linkToIdToken(e, t) { const n = this.buildRequest(); return n.idToken = t, xw(e, n) } _getReauthenticationResolver(e) { const t = this.buildRequest(); return t.autoCreate = !1, xw(e, t) } buildRequest() { const e = { requestUri: "http://localhost", returnSecureToken: !0 }; if (this.pendingToken) e.pendingToken = this.pendingToken; else { const t = {}; this.idToken && (t.id_token = this.idToken), this.accessToken && (t.access_token = this.accessToken), this.secret && (t.oauth_token_secret = this.secret), t.providerId = this.providerId, this.nonce && !this.pendingToken && (t.nonce = this.nonce), e.postBody = Dv(t) } return e } } const Sw = { USER_NOT_FOUND: "user-not-found" }; class Nw extends vw { constructor(e) { super("phone", "phone"), this.params = e } static _fromVerification(e, t) { return new Nw({ verificationId: e, verificationCode: t }) } static _fromTokenResponse(e, t) { return new Nw({ phoneNumber: e, temporaryProof: t }) } _getIdTokenResponse(e) { return async function (e, t) { return yb(e, "POST", "/v1/accounts:signInWithPhoneNumber", mb(e, t)) }(e, this._makeVerificationRequest()) } _linkToIdToken(e, t) { return async function (e, t) { const n = await yb(e, "POST", "/v1/accounts:signInWithPhoneNumber", mb(e, t)); if (n.temporaryProof) throw Eb(e, "account-exists-with-different-credential", n); return n }(e, Object.assign({ idToken: t }, this._makeVerificationRequest())) } _getReauthenticationResolver(e) { return async function (e, t) { return yb(e, "POST", "/v1/accounts:signInWithPhoneNumber", mb(e, Object.assign(Object.assign({}, t), { operation: "REAUTH" })), Sw) }(e, this._makeVerificationRequest()) } _makeVerificationRequest() { const { temporaryProof: e, phoneNumber: t, verificationId: n, verificationCode: r } = this.params; return e && t ? { temporaryProof: e, phoneNumber: t } : { sessionInfo: n, code: r } } toJSON() { const e = { providerId: this.providerId }; return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e } static fromJSON(e) { "string" === typeof e && (e = JSON.parse(e)); const { verificationId: t, verificationCode: n, phoneNumber: r, temporaryProof: i } = e; return n || t || r || i ? new Nw({ verificationId: t, verificationCode: n, phoneNumber: r, temporaryProof: i }) : null } } class Cw { constructor(e) { var t, n, r, i, s, o; const a = _v(Mv(e)), l = null !== (t = a.apiKey) && void 0 !== t ? t : null, c = null !== (n = a.oobCode) && void 0 !== n ? n : null, u = function (e) { switch (e) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } }(null !== (r = a.mode) && void 0 !== r ? r : null); rb(l && c && u, "argument-error"), this.apiKey = l, this.operation = u, this.code = c, this.continueUrl = null !== (i = a.continueUrl) && void 0 !== i ? i : null, this.languageCode = null !== (s = a.languageCode) && void 0 !== s ? s : null, this.tenantId = null !== (o = a.tenantId) && void 0 !== o ? o : null } static parseLink(e) { const t = function (e) { const t = _v(Mv(e)).link, n = t ? _v(Mv(t)).deep_link_id : null, r = _v(Mv(e)).deep_link_id; return (r ? _v(Mv(r)).link : null) || r || n || t || e }(e); try { return new Cw(t) } catch (oI) { return null } } } class Tw { constructor() { this.providerId = Tw.PROVIDER_ID } static credential(e, t) { return ww._fromEmailAndPassword(e, t) } static credentialWithLink(e, t) { const n = Cw.parseLink(t); return rb(n, "argument-error"), ww._fromEmailAndCode(e, n.code, n.tenantId) } } Tw.PROVIDER_ID = "password", Tw.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", Tw.EMAIL_LINK_SIGN_IN_METHOD = "emailLink"; class Aw { constructor(e) { this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(e) { this.defaultLanguageCode = e } setCustomParameters(e) { return this.customParameters = e, this } getCustomParameters() { return this.customParameters } } class kw extends Aw { constructor() { super(...arguments), this.scopes = [] } addScope(e) { return this.scopes.includes(e) || this.scopes.push(e), this } getScopes() { return [...this.scopes] } } class jw extends kw { constructor() { super("facebook.com") } static credential(e) { return Ew._fromParams({ providerId: jw.PROVIDER_ID, signInMethod: jw.FACEBOOK_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return jw.credentialFromTaggedObject(e) } static credentialFromError(e) { return jw.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject(e) { let { _tokenResponse: t } = e; if (!t || !("oauthAccessToken" in t)) return null; if (!t.oauthAccessToken) return null; try { return jw.credential(t.oauthAccessToken) } catch (oI) { return null } } } jw.FACEBOOK_SIGN_IN_METHOD = "facebook.com", jw.PROVIDER_ID = "facebook.com"; class Pw extends kw { constructor() { super("google.com"), this.addScope("profile") } static credential(e, t) { return Ew._fromParams({ providerId: Pw.PROVIDER_ID, signInMethod: Pw.GOOGLE_SIGN_IN_METHOD, idToken: e, accessToken: t }) } static credentialFromResult(e) { return Pw.credentialFromTaggedObject(e) } static credentialFromError(e) { return Pw.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject(e) { let { _tokenResponse: t } = e; if (!t) return null; const { oauthIdToken: n, oauthAccessToken: r } = t; if (!n && !r) return null; try { return Pw.credential(n, r) } catch (oI) { return null } } } Pw.GOOGLE_SIGN_IN_METHOD = "google.com", Pw.PROVIDER_ID = "google.com"; class Iw extends kw { constructor() { super("github.com") } static credential(e) { return Ew._fromParams({ providerId: Iw.PROVIDER_ID, signInMethod: Iw.GITHUB_SIGN_IN_METHOD, accessToken: e }) } static credentialFromResult(e) { return Iw.credentialFromTaggedObject(e) } static credentialFromError(e) { return Iw.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject(e) { let { _tokenResponse: t } = e; if (!t || !("oauthAccessToken" in t)) return null; if (!t.oauthAccessToken) return null; try { return Iw.credential(t.oauthAccessToken) } catch (oI) { return null } } } Iw.GITHUB_SIGN_IN_METHOD = "github.com", Iw.PROVIDER_ID = "github.com"; class Rw extends kw { constructor() { super("twitter.com") } static credential(e, t) { return Ew._fromParams({ providerId: Rw.PROVIDER_ID, signInMethod: Rw.TWITTER_SIGN_IN_METHOD, oauthToken: e, oauthTokenSecret: t }) } static credentialFromResult(e) { return Rw.credentialFromTaggedObject(e) } static credentialFromError(e) { return Rw.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject(e) { let { _tokenResponse: t } = e; if (!t) return null; const { oauthAccessToken: n, oauthTokenSecret: r } = t; if (!n || !r) return null; try { return Rw.credential(n, r) } catch (oI) { return null } } } async function Ow(e, t) { return yb(e, "POST", "/v1/accounts:signUp", mb(e, t)) } Rw.TWITTER_SIGN_IN_METHOD = "twitter.com", Rw.PROVIDER_ID = "twitter.com"; class Dw { constructor(e) { this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType } static async _fromIdTokenResponse(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const i = await Fb._fromIdTokenResponse(e, n, r), s = _w(n); return new Dw({ user: i, providerId: s, _tokenResponse: n, operationType: t }) } static async _forOperation(e, t, n) { await e._updateTokensIfNecessary(n, !0); const r = _w(n); return new Dw({ user: e, providerId: r, _tokenResponse: n, operationType: t }) } } function _w(e) { return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null } class Mw extends jv { constructor(e, t, n, r) { var i; super(t.code, t.message), this.operationType = n, this.user = r, Object.setPrototypeOf(this, Mw.prototype), this.customData = { appName: e.name, tenantId: null !== (i = e.tenantId) && void 0 !== i ? i : void 0, _serverResponse: t.customData._serverResponse, operationType: n } } static _fromErrorAndOperation(e, t, n, r) { return new Mw(e, t, n, r) } } function Lw(e, t, n, r) { return ("reauthenticate" === t ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch((n => { if (n.code === "auth/".concat("multi-factor-auth-required")) throw Mw._fromErrorAndOperation(e, n, t, r); throw n })) } async function Fw(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = await Ib(e, t._linkToIdToken(e.auth, await e.getIdToken()), n); return Dw._forOperation(e, "link", r) } async function Uw(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const { auth: r } = e; if (Ty(r.app)) return Promise.reject(eb(r)); const i = "reauthenticate"; try { const s = await Ib(e, Lw(r, i, t, e), n); rb(s.idToken, r, "internal-error"); const o = jb(s.idToken); rb(o, r, "internal-error"); const { sub: a } = o; return rb(e.uid === a, r, "user-mismatch"), Dw._forOperation(e, i, s) } catch (sI) { throw (null === sI || void 0 === sI ? void 0 : sI.code) === "auth/".concat("user-not-found") && Xy(r, "user-mismatch"), sI } } async function Bw(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (Ty(e.app)) return Promise.reject(eb(e)); const r = "signIn", i = await Lw(e, r, t), s = await Dw._fromIdTokenResponse(e, r, i); return n || await e._updateCurrentUser(s.user), s } async function Vw(e, t) { return Bw(ow(e), t) } async function zw(e) { const t = ow(e); t._getPasswordPolicyInternal() && await t._updatePasswordPolicy() } new WeakMap; const qw = "__sak"; class Hw { constructor(e, t) { this.storageRetriever = e, this.type = t } _isAvailable() { try { return this.storage ? (this.storage.setItem(qw, "1"), this.storage.removeItem(qw), Promise.resolve(!0)) : Promise.resolve(!1) } catch (oI) { return Promise.resolve(!1) } } _set(e, t) { return this.storage.setItem(e, JSON.stringify(t)), Promise.resolve() } _get(e) { const t = this.storage.getItem(e); return Promise.resolve(t ? JSON.parse(t) : null) } _remove(e) { return this.storage.removeItem(e), Promise.resolve() } get storage() { return this.storageRetriever() } } class Ww extends Hw { constructor() { super((() => window.localStorage), "LOCAL"), this.boundEventHandler = (e, t) => this.onStorageEvent(e, t), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function () { const e = Tv(); return Gb(e) || $b(e) }() && function () { try { return !(!window || window === window.top) } catch (sI) { return !1 } }(), this.fallbackToPolling = tw(), this._shouldAllowMigration = !0 } forAllChangedKeys(e) { for (const t of Object.keys(this.listeners)) { const n = this.storage.getItem(t), r = this.localCache[t]; n !== r && e(t, r, n) } } onStorageEvent(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e.key) return void this.forAllChangedKeys(((e, t, n) => { this.notifyListeners(e, n) })); const n = e.key; if (t ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) { const r = this.storage.getItem(n); if (e.newValue !== r) null !== e.newValue ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n); else if (this.localCache[n] === e.newValue && !t) return } const r = () => { const e = this.storage.getItem(n); (t || this.localCache[n] !== e) && this.notifyListeners(n, e) }, i = this.storage.getItem(n); ew() && i !== e.newValue && e.newValue !== e.oldValue ? setTimeout(r, 10) : r() } notifyListeners(e, t) { this.localCache[e] = t; const n = this.listeners[e]; if (n) for (const r of Array.from(n)) r(t ? JSON.parse(t) : t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval((() => { this.forAllChangedKeys(((e, t, n) => { this.onStorageEvent(new StorageEvent("storage", { key: e, oldValue: t, newValue: n }), !0) })) }), 1e3) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling()) } async _set(e, t) { await super._set(e, t), this.localCache[e] = JSON.stringify(t) } async _get(e) { const t = await super._get(e); return this.localCache[e] = JSON.stringify(t), t } async _remove(e) { await super._remove(e), delete this.localCache[e] } } Ww.type = "LOCAL"; const Kw = Ww; class Gw extends Hw { constructor() { super((() => window.sessionStorage), "SESSION") } _addListener(e, t) { } _removeListener(e, t) { } } Gw.type = "SESSION"; const Qw = Gw; class Yw { constructor(e) { this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(e) { const t = this.receivers.find((t => t.isListeningto(e))); if (t) return t; const n = new Yw(e); return this.receivers.push(n), n } isListeningto(e) { return this.eventTarget === e } async handleEvent(e) { const t = e, { eventId: n, eventType: r, data: i } = t.data, s = this.handlersMap[r]; if (!(null === s || void 0 === s ? void 0 : s.size)) return; t.ports[0].postMessage({ status: "ack", eventId: n, eventType: r }); const o = Array.from(s).map((async e => e(t.origin, i))), a = await function (e) { return Promise.all(e.map((async e => { try { return { fulfilled: !0, value: await e } } catch (t) { return { fulfilled: !1, reason: t } } }))) }(o); t.ports[0].postMessage({ status: "done", eventId: n, eventType: r, response: a }) } _subscribe(e, t) { 0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(t) } _unsubscribe(e, t) { this.handlersMap[e] && t && this.handlersMap[e].delete(t), t && 0 !== this.handlersMap[e].size || delete this.handlersMap[e], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } function Jw() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, n = ""; for (let r = 0; r < t; r++)n += Math.floor(10 * Math.random()); return e + n } Yw.receivers = []; class Xw { constructor(e) { this.target = e, this.handlers = new Set } removeMessageHandler(e) { e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e) } async _send(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50; const r = "undefined" !== typeof MessageChannel ? new MessageChannel : null; if (!r) throw new Error("connection_unavailable"); let i, s; return new Promise(((o, a) => { const l = Jw("", 20); r.port1.start(); const c = setTimeout((() => { a(new Error("unsupported_event")) }), n); s = { messageChannel: r, onMessage(e) { const t = e; if (t.data.eventId === l) switch (t.data.status) { case "ack": clearTimeout(c), i = setTimeout((() => { a(new Error("timeout")) }), 3e3); break; case "done": clearTimeout(i), o(t.data.response); break; default: clearTimeout(c), clearTimeout(i), a(new Error("invalid_response")) } } }, this.handlers.add(s), r.port1.addEventListener("message", s.onMessage), this.target.postMessage({ eventType: e, eventId: l, data: t }, [r.port2]) })).finally((() => { s && this.removeMessageHandler(s) })) } } function Zw() { return window } function $w() { return "undefined" !== typeof Zw().WorkerGlobalScope && "function" === typeof Zw().importScripts } const ex = "firebaseLocalStorageDb", tx = "firebaseLocalStorage", nx = "fbase_key"; class rx { constructor(e) { this.request = e } toPromise() { return new Promise(((e, t) => { this.request.addEventListener("success", (() => { e(this.request.result) })), this.request.addEventListener("error", (() => { t(this.request.error) })) })) } } function ix(e, t) { return e.transaction([tx], t ? "readwrite" : "readonly").objectStore(tx) } function sx() { const e = indexedDB.open(ex, 1); return new Promise(((t, n) => { e.addEventListener("error", (() => { n(e.error) })), e.addEventListener("upgradeneeded", (() => { const t = e.result; try { t.createObjectStore(tx, { keyPath: nx }) } catch (sI) { n(sI) } })), e.addEventListener("success", (async () => { const n = e.result; n.objectStoreNames.contains(tx) ? t(n) : (n.close(), await function () { const e = indexedDB.deleteDatabase(ex); return new rx(e).toPromise() }(), t(await sx())) })) })) } async function ox(e, t, n) { const r = ix(e, !0).put({ [nx]: t, value: n }); return new rx(r).toPromise() } function ax(e, t) { const n = ix(e, !0).delete(t); return new rx(n).toPromise() } class lx { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then((() => { }), (() => { })) } async _openDb() { return this.db || (this.db = await sx()), this.db } async _withRetries(e) { let t = 0; for (; ;)try { const t = await this._openDb(); return await e(t) } catch (sI) { if (t++ > 3) throw sI; this.db && (this.db.close(), this.db = void 0) } } async initializeServiceWorkerMessaging() { return $w() ? this.initializeReceiver() : this.initializeSender() } async initializeReceiver() { this.receiver = Yw._getInstance($w() ? self : null), this.receiver._subscribe("keyChanged", (async (e, t) => ({ keyProcessed: (await this._poll()).includes(t.key) }))), this.receiver._subscribe("ping", (async (e, t) => ["keyChanged"])) } async initializeSender() { var e, t; if (this.activeServiceWorker = await async function () { if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker)) return null; try { return (await navigator.serviceWorker.ready).active } catch (e) { return null } }(), !this.activeServiceWorker) return; this.sender = new Xw(this.activeServiceWorker); const n = await this.sender._send("ping", {}, 800); n && (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) && (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0) } async notifyServiceWorker(e) { if (this.sender && this.activeServiceWorker && function () { var e; return (null === (e = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === e ? void 0 : e.controller) || null }() === this.activeServiceWorker) try { await this.sender._send("keyChanged", { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50) } catch (oI) { } } async _isAvailable() { try { if (!indexedDB) return !1; const e = await sx(); return await ox(e, qw, "1"), await ax(e, qw), !0 } catch (oI) { } return !1 } async _withPendingWrite(e) { this.pendingWrites++; try { await e() } finally { this.pendingWrites-- } } async _set(e, t) { return this._withPendingWrite((async () => (await this._withRetries((n => ox(n, e, t))), this.localCache[e] = t, this.notifyServiceWorker(e)))) } async _get(e) { const t = await this._withRetries((t => async function (e, t) { const n = ix(e, !1).get(t), r = await new rx(n).toPromise(); return void 0 === r ? null : r.value }(t, e))); return this.localCache[e] = t, t } async _remove(e) { return this._withPendingWrite((async () => (await this._withRetries((t => ax(t, e))), delete this.localCache[e], this.notifyServiceWorker(e)))) } async _poll() { const e = await this._withRetries((e => { const t = ix(e, !1).getAll(); return new rx(t).toPromise() })); if (!e) return []; if (0 !== this.pendingWrites) return []; const t = [], n = new Set; if (0 !== e.length) for (const { fbase_key: r, value: i } of e) n.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i), t.push(r)); for (const r of Object.keys(this.localCache)) this.localCache[r] && !n.has(r) && (this.notifyListeners(r, null), t.push(r)); return t } notifyListeners(e, t) { this.localCache[e] = t; const n = this.listeners[e]; if (n) for (const r of Array.from(n)) r(t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval((async () => this._poll()), 800) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && this.stopPolling() } } lx.type = "LOCAL"; const cx = lx; uw("rcb"), new ub(3e4, 6e4); const ux = "recaptcha"; async function dx(e, t, n) { var r; const i = await n.verify(); try { let s; if (rb("string" === typeof i, e, "argument-error"), rb(n.type === ux, e, "argument-error"), s = "string" === typeof t ? { phoneNumber: t } : t, "session" in s) { const t = s.session; if ("phoneNumber" in s) { rb("enroll" === t.type, e, "internal-error"); const n = await function (e, t) { return gb(e, "POST", "/v2/accounts/mfaEnrollment:start", mb(e, t)) }(e, { idToken: t.credential, phoneEnrollmentInfo: { phoneNumber: s.phoneNumber, recaptchaToken: i } }); return n.phoneSessionInfo.sessionInfo } { rb("signin" === t.type, e, "internal-error"); const n = (null === (r = s.multiFactorHint) || void 0 === r ? void 0 : r.uid) || s.multiFactorUid; rb(n, e, "missing-multi-factor-info"); const o = await function (e, t) { return gb(e, "POST", "/v2/accounts/mfaSignIn:start", mb(e, t)) }(e, { mfaPendingCredential: t.credential, mfaEnrollmentId: n, phoneSignInInfo: { recaptchaToken: i } }); return o.phoneResponseInfo.sessionInfo } } { const { sessionInfo: t } = await async function (e, t) { return gb(e, "POST", "/v1/accounts:sendVerificationCode", mb(e, t)) }(e, { phoneNumber: s.phoneNumber, recaptchaToken: i }); return t } } finally { n._reset() } } class hx { constructor(e) { this.providerId = hx.PROVIDER_ID, this.auth = ow(e) } verifyPhoneNumber(e, t) { return dx(this.auth, e, Uv(t)) } static credential(e, t) { return Nw._fromVerification(e, t) } static credentialFromResult(e) { const t = e; return hx.credentialFromTaggedObject(t) } static credentialFromError(e) { return hx.credentialFromTaggedObject(e.customData || {}) } static credentialFromTaggedObject(e) { let { _tokenResponse: t } = e; if (!t) return null; const { phoneNumber: n, temporaryProof: r } = t; return n && r ? Nw._fromTokenResponse(n, r) : null } } function fx(e, t) { return t ? Bb(t) : (rb(e._popupRedirectResolver, e, "argument-error"), e._popupRedirectResolver) } hx.PROVIDER_ID = "phone", hx.PHONE_SIGN_IN_METHOD = "phone"; class px extends vw { constructor(e) { super("custom", "custom"), this.params = e } _getIdTokenResponse(e) { return xw(e, this._buildIdpRequest()) } _linkToIdToken(e, t) { return xw(e, this._buildIdpRequest(t)) } _getReauthenticationResolver(e) { return xw(e, this._buildIdpRequest()) } _buildIdpRequest(e) { const t = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return e && (t.idToken = e), t } } function mx(e) { return Bw(e.auth, new px(e), e.bypassAuthState) } function gx(e) { const { auth: t, user: n } = e; return rb(n, t, "internal-error"), Uw(n, new px(e), e.bypassAuthState) } async function vx(e) { const { auth: t, user: n } = e; return rb(n, t, "internal-error"), Fw(n, new px(e), e.bypassAuthState) } class yx { constructor(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; this.auth = e, this.resolver = n, this.user = r, this.bypassAuthState = i, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(t) ? t : [t] } execute() { return new Promise((async (e, t) => { this.pendingPromise = { resolve: e, reject: t }; try { this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this) } catch (sI) { this.reject(sI) } })) } async onAuthEvent(e) { const { urlResponse: t, sessionId: n, postBody: r, tenantId: i, error: s, type: o } = e; if (s) return void this.reject(s); const a = { auth: this.auth, requestUri: t, sessionId: n, tenantId: i || void 0, postBody: r || void 0, user: this.user, bypassAuthState: this.bypassAuthState }; try { this.resolve(await this.getIdpTask(o)(a)) } catch (sI) { this.reject(sI) } } onError(e) { this.reject(e) } getIdpTask(e) { switch (e) { case "signInViaPopup": case "signInViaRedirect": return mx; case "linkViaPopup": case "linkViaRedirect": return vx; case "reauthViaPopup": case "reauthViaRedirect": return gx; default: Xy(this.auth, "internal-error") } } resolve(e) { sb(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp() } reject(e) { sb(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } } const bx = new ub(2e3, 1e4); class wx extends yx { constructor(e, t, n, r, i) { super(e, t, r, i), this.provider = n, this.authWindow = null, this.pollId = null, wx.currentPopupAction && wx.currentPopupAction.cancel(), wx.currentPopupAction = this } async executeNotNull() { const e = await this.execute(); return rb(e, this.auth, "internal-error"), e } async onExecution() { sb(1 === this.filter.length, "Popup operations only handle one event"); const e = Jw(); this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch((e => { this.reject(e) })), this.resolver._isIframeWebStorageSupported(this.auth, (e => { e || this.reject(Zy(this.auth, "web-storage-unsupported")) })), this.pollUserCancellation() } get eventId() { var e; return (null === (e = this.authWindow) || void 0 === e ? void 0 : e.associatedEvent) || null } cancel() { this.reject(Zy(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, wx.currentPopupAction = null } pollUserCancellation() { const e = () => { var t, n; (null === (n = null === (t = this.authWindow) || void 0 === t ? void 0 : t.window) || void 0 === n ? void 0 : n.closed) ? this.pollId = window.setTimeout((() => { this.pollId = null, this.reject(Zy(this.auth, "popup-closed-by-user")) }), 8e3) : this.pollId = window.setTimeout(e, bx.get()) }; e() } } wx.currentPopupAction = null; const xx = "pendingRedirect", Ex = new Map; class Sx extends yx { constructor(e, t) { super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, arguments.length > 2 && void 0 !== arguments[2] && arguments[2]), this.eventId = null } async execute() { let e = Ex.get(this.auth._key()); if (!e) { try { const t = await async function (e, t) { const n = Tx(t), r = Cx(e); if (!await r._isAvailable()) return !1; const i = "true" === await r._get(n); return await r._remove(n), i }(this.resolver, this.auth), n = t ? await super.execute() : null; e = () => Promise.resolve(n) } catch (sI) { e = () => Promise.reject(sI) } Ex.set(this.auth._key(), e) } return this.bypassAuthState || Ex.set(this.auth._key(), (() => Promise.resolve(null))), e() } async onAuthEvent(e) { if ("signInViaRedirect" === e.type) return super.onAuthEvent(e); if ("unknown" !== e.type) { if (e.eventId) { const t = await this.auth._redirectUserForId(e.eventId); if (t) return this.user = t, super.onAuthEvent(e); this.resolve(null) } } else this.resolve(null) } async onExecution() { } cleanUp() { } } function Nx(e, t) { Ex.set(e._key(), t) } function Cx(e) { return Bb(e._redirectPersistence) } function Tx(e) { return qb(xx, e.config.apiKey, e.name) } async function Ax(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (Ty(e.app)) return Promise.reject(eb(e)); const r = ow(e), i = fx(r, t), s = new Sx(r, i, n), o = await s.execute(); return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, t)), o } class kx { constructor(e) { this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(e) { this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(e) { this.consumers.delete(e) } onEvent(e) { if (this.hasEventBeenHandled(e)) return !1; let t = !1; return this.consumers.forEach((n => { this.isEventForConsumer(e, n) && (t = !0, this.sendToConsumer(e, n), this.saveEventToCache(e)) })), this.hasHandledPotentialRedirect || !function (e) { switch (e.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return Px(e); default: return !1 } }(e) || (this.hasHandledPotentialRedirect = !0, t || (this.queuedRedirectEvent = e, t = !0)), t } sendToConsumer(e, t) { var n; if (e.error && !Px(e)) { const r = (null === (n = e.error.code) || void 0 === n ? void 0 : n.split("auth/")[1]) || "internal-error"; t.onError(Zy(this.auth, r)) } else t.onAuthEvent(e) } isEventForConsumer(e, t) { const n = null === t.eventId || !!e.eventId && e.eventId === t.eventId; return t.filter.includes(e.type) && n } hasEventBeenHandled(e) { return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(jx(e)) } saveEventToCache(e) { this.cachedEventUids.add(jx(e)), this.lastProcessedEventTime = Date.now() } } function jx(e) { return [e.type, e.eventId, e.sessionId, e.tenantId].filter((e => e)).join("-") } function Px(e) { let { type: t, error: n } = e; return "unknown" === t && (null === n || void 0 === n ? void 0 : n.code) === "auth/".concat("no-auth-event") } const Ix = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, Rx = /^https?/; async function Ox(e) { if (e.config.emulator) return; const { authorizedDomains: t } = await async function (e) { return gb(e, "GET", "/v1/projects", arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}) }(e); for (const n of t) try { if (Dx(n)) return } catch (oI) { } Xy(e, "unauthorized-domain") } function Dx(e) { const t = ob(), { protocol: n, hostname: r } = new URL(t); if (e.startsWith("chrome-extension://")) { const i = new URL(e); return "" === i.hostname && "" === r ? "chrome-extension:" === n && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : "chrome-extension:" === n && i.hostname === r } if (!Rx.test(n)) return !1; if (Ix.test(e)) return r === e; const i = e.replace(/\./g, "\\."); return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r) } const _x = new ub(3e4, 6e4); function Mx() { const e = Zw().___jsl; if (null === e || void 0 === e ? void 0 : e.H) for (const t of Object.keys(e.H)) if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP) for (let n = 0; n < e.CP.length; n++)e.CP[n] = null } function Lx(e) { return new Promise(((t, n) => { var r, i, s; function o() { Mx(), gapi.load("gapi.iframes", { callback: () => { t(gapi.iframes.getContext()) }, ontimeout: () => { Mx(), n(Zy(e, "network-request-failed")) }, timeout: _x.get() }) } if (null === (i = null === (r = Zw().gapi) || void 0 === r ? void 0 : r.iframes) || void 0 === i ? void 0 : i.Iframe) t(gapi.iframes.getContext()); else { if (!(null === (s = Zw().gapi) || void 0 === s ? void 0 : s.load)) { const t = uw("iframefcb"); return Zw()[t] = () => { gapi.load ? o() : n(Zy(e, "network-request-failed")) }, cw("".concat(lw.gapiScript, "?onload=").concat(t)).catch((e => n(e))) } o() } })).catch((e => { throw Fx = null, e })) } let Fx = null; const Ux = new ub(5e3, 15e3), Bx = "__/auth/iframe", Vx = "emulator/auth/iframe", zx = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, qx = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); function Hx(e) { const t = e.config; rb(t.authDomain, e, "auth-domain-config-required"); const n = t.emulator ? db(t, Vx) : "https://".concat(e.config.authDomain, "/").concat(Bx), r = { apiKey: t.apiKey, appName: e.name, v: jy }, i = qx.get(e.config.apiHost); i && (r.eid = i); const s = e._getFrameworks(); return s.length && (r.fw = s.join(",")), "".concat(n, "?").concat(Dv(r).slice(1)) } async function Wx(e) { const t = await function (e) { return Fx = Fx || Lx(e), Fx }(e), n = Zw().gapi; return rb(n, e, "internal-error"), t.open({ where: document.body, url: Hx(e), messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: zx, dontclear: !0 }, (t => new Promise((async (n, r) => { await t.restyle({ setHideOnLeave: !1 }); const i = Zy(e, "network-request-failed"), s = Zw().setTimeout((() => { r(i) }), Ux.get()); function o() { Zw().clearTimeout(s), n(t) } t.ping(o).then(o, (() => { r(i) })) })))) } const Kx = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }; class Gx { constructor(e) { this.window = e, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch (sI) { } } } function Qx(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 600; const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(), o = Math.max((window.screen.availWidth - r) / 2, 0).toString(); let a = ""; const l = Object.assign(Object.assign({}, Kx), { width: r.toString(), height: i.toString(), top: s, left: o }), c = Tv().toLowerCase(); n && (a = Qb(c) ? "_blank" : n), Kb(c) && (t = t || "http://localhost", l.scrollbars = "yes"); const u = Object.entries(l).reduce(((e, t) => { let [n, r] = t; return "".concat(e).concat(n, "=").concat(r, ",") }), ""); if (function () { var e; return $b(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tv()) && !!(null === (e = window.navigator) || void 0 === e ? void 0 : e.standalone) }(c) && "_self" !== a) return function (e, t) { const n = document.createElement("a"); n.href = e, n.target = t; const r = document.createEvent("MouseEvent"); r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r) }(t || "", a), new Gx(null); const d = window.open(t || "", a, u); rb(d, e, "popup-blocked"); try { d.focus() } catch (sI) { } return new Gx(d) } const Yx = "__/auth/handler", Jx = "emulator/auth/handler", Xx = encodeURIComponent("fac"); async function Zx(e, t, n, r, i, s) { rb(e.config.authDomain, e, "auth-domain-config-required"), rb(e.config.apiKey, e, "invalid-api-key"); const o = { apiKey: e.config.apiKey, appName: e.name, authType: n, redirectUrl: r, v: jy, eventId: i }; if (t instanceof Aw) { t.setDefaultLanguage(e.languageCode), o.providerId = t.providerId || "", function (e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 }(t.getCustomParameters()) || (o.customParameters = JSON.stringify(t.getCustomParameters())); for (const [e, t] of Object.entries(s || {})) o[e] = t } if (t instanceof kw) { const e = t.getScopes().filter((e => "" !== e)); e.length > 0 && (o.scopes = e.join(",")) } e.tenantId && (o.tid = e.tenantId); const a = o; for (const u of Object.keys(a)) void 0 === a[u] && delete a[u]; const l = await e._getAppCheckToken(), c = l ? "#".concat(Xx, "=").concat(encodeURIComponent(l)) : ""; return "".concat(function (e) { let { config: t } = e; if (!t.emulator) return "https://".concat(t.authDomain, "/").concat(Yx); return db(t, Jx) }(e), "?").concat(Dv(a).slice(1)).concat(c) } const $x = "webStorageSupport"; const eE = class { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = Qw, this._completeRedirectFn = Ax, this._overrideRedirectResult = Nx } async _openPopup(e, t, n, r) { var i; sb(null === (i = this.eventManagers[e._key()]) || void 0 === i ? void 0 : i.manager, "_initialize() not called before _openPopup()"); return Qx(e, await Zx(e, t, n, ob(), r), Jw()) } async _openRedirect(e, t, n, r) { await this._originValidation(e); return function (e) { Zw().location.href = e }(await Zx(e, t, n, ob(), r)), new Promise((() => { })) } _initialize(e) { const t = e._key(); if (this.eventManagers[t]) { const { manager: e, promise: n } = this.eventManagers[t]; return e ? Promise.resolve(e) : (sb(n, "If manager is not set, promise should be"), n) } const n = this.initAndGetManager(e); return this.eventManagers[t] = { promise: n }, n.catch((() => { delete this.eventManagers[t] })), n } async initAndGetManager(e) { const t = await Wx(e), n = new kx(e); return t.register("authEvent", (t => { rb(null === t || void 0 === t ? void 0 : t.authEvent, e, "invalid-auth-event"); return { status: n.onEvent(t.authEvent) ? "ACK" : "ERROR" } }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: n }, this.iframes[e._key()] = t, n } _isIframeWebStorageSupported(e, t) { this.iframes[e._key()].send($x, { type: $x }, (n => { var r; const i = null === (r = null === n || void 0 === n ? void 0 : n[0]) || void 0 === r ? void 0 : r[$x]; void 0 !== i && t(!!i), Xy(e, "internal-error") }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(e) { const t = e._key(); return this.originValidationPromises[t] || (this.originValidationPromises[t] = Ox(e)), this.originValidationPromises[t] } get _shouldInitProactively() { return tw() || Gb() || $b() } }; var tE = "@firebase/auth", nE = "1.7.5"; class rE { constructor(e) { this.auth = e, this.internalListeners = new Map } getUid() { var e; return this.assertAuthConfigured(), (null === (e = this.auth.currentUser) || void 0 === e ? void 0 : e.uid) || null } async getToken(e) { if (this.assertAuthConfigured(), await this.auth._initializationPromise, !this.auth.currentUser) return null; return { accessToken: await this.auth.currentUser.getIdToken(e) } } addAuthTokenListener(e) { if (this.assertAuthConfigured(), this.internalListeners.has(e)) return; const t = this.auth.onIdTokenChanged((t => { e((null === t || void 0 === t ? void 0 : t.stsTokenManager.accessToken) || null) })); this.internalListeners.set(e, t), this.updateProactiveRefresh() } removeAuthTokenListener(e) { this.assertAuthConfigured(); const t = this.internalListeners.get(e); t && (this.internalListeners.delete(e), t(), this.updateProactiveRefresh()) } assertAuthConfigured() { rb(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } } const iE = Nv("authIdTokenMaxAge") || 300; let sE = null; var oE; !function (e) { lw = e }({ loadJS: e => new Promise(((t, n) => { const r = document.createElement("script"); r.setAttribute("src", e), r.onload = t, r.onerror = e => { const t = Zy("internal-error"); t.customData = e, n(t) }, r.type = "text/javascript", r.charset = "UTF-8", function () { var e, t; return null !== (t = null === (e = document.getElementsByTagName("head")) || void 0 === e ? void 0 : e[0]) && void 0 !== t ? t : document }().appendChild(r) })), gapiScript: "https://apis.google.com/js/api.js", recaptchaV2Script: "https://www.google.com/recaptcha/api.js", recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render=" }), oE = "Browser", Ny(new Bv("auth", ((e, t) => { let { options: n } = t; const r = e.getProvider("app").getImmediate(), i = e.getProvider("heartbeat"), s = e.getProvider("app-check-internal"), { apiKey: o, authDomain: a } = r.options; rb(o && !o.includes(":"), "invalid-api-key", { appName: r.name }); const l = { apiKey: o, authDomain: a, clientPlatform: oE, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: nw(oE) }, c = new sw(r, i, s, l); return function (e, t) { const n = (null === t || void 0 === t ? void 0 : t.persistence) || [], r = (Array.isArray(n) ? n : [n]).map(Bb); (null === t || void 0 === t ? void 0 : t.errorMap) && e._updateErrorMap(t.errorMap), e._initializeWithPersistence(r, null === t || void 0 === t ? void 0 : t.popupRedirectResolver) }(c, n), c }), "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback(((e, t, n) => { e.getProvider("auth-internal").initialize() }))), Ny(new Bv("auth-internal", (e => (e => new rE(e))(ow(e.getProvider("auth").getImmediate()))), "PRIVATE").setInstantiationMode("EXPLICIT")), Ry(tE, nE, function (e) { switch (e) { case "Node": return "node"; case "ReactNative": return "rn"; case "Worker": return "webworker"; case "Cordova": return "cordova"; case "WebExtension": return "web-extension"; default: return } }(oE)), Ry(tE, nE, "esm2017"); Ry("firebase", "10.12.3", "app"); var aE, lE, cE = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {}, uE = {}; (function () { var e; function t() { this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.B = Array(this.blockSize), this.o = this.h = 0, this.s() } function n(e, t, n) { n || (n = 0); var r = Array(16); if ("string" === typeof t) for (var i = 0; 16 > i; ++i)r[i] = t.charCodeAt(n++) | t.charCodeAt(n++) << 8 | t.charCodeAt(n++) << 16 | t.charCodeAt(n++) << 24; else for (i = 0; 16 > i; ++i)r[i] = t[n++] | t[n++] << 8 | t[n++] << 16 | t[n++] << 24; t = e.g[0], n = e.g[1], i = e.g[2]; var s = e.g[3], o = t + (s ^ n & (i ^ s)) + r[0] + 3614090360 & 4294967295; o = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = n + (o << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[1] + 3905402710 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[2] + 606105819 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[3] + 3250441966 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[4] + 4118548399 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[5] + 1200080426 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[6] + 2821735955 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[7] + 4249261313 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[8] + 1770035416 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[9] + 2336552879 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[10] + 4294925233 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[11] + 2304563134 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[12] + 1804603682 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[13] + 4254626195 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[14] + 2792965006 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[15] + 1236535329 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (i ^ s & (n ^ i)) + r[1] + 4129170786 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[6] + 3225465664 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[11] + 643717713 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[0] + 3921069994 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[5] + 3593408605 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[10] + 38016083 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[15] + 3634488961 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[4] + 3889429448 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[9] + 568446438 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[14] + 3275163606 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[3] + 4107603335 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[8] + 1163531501 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[13] + 2850285829 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[2] + 4243563512 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[7] + 1735328473 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[12] + 2368359562 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (n ^ i ^ s) + r[5] + 4294588738 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[8] + 2272392833 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[11] + 1839030562 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[14] + 4259657740 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[1] + 2763975236 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[4] + 1272893353 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[7] + 4139469664 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[10] + 3200236656 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[13] + 681279174 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[0] + 3936430074 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[3] + 3572445317 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[6] + 76029189 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[9] + 3654602809 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[12] + 3873151461 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[15] + 530742520 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[2] + 3299628645 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (i ^ (n | ~s)) + r[0] + 4096336452 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[7] + 1126891415 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[14] + 2878612391 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[5] + 4237533241 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((o = t + (i ^ (n | ~s)) + r[12] + 1700485571 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[3] + 2399980690 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[10] + 4293915773 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[1] + 2240044497 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((o = t + (i ^ (n | ~s)) + r[8] + 1873313359 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[15] + 4264355552 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[6] + 2734768916 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[13] + 1309151649 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((s = (t = n + ((o = t + (i ^ (n | ~s)) + r[4] + 4149444226 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[11] + 3174756917 & 4294967295) << 10 & 4294967295 | o >>> 22)) ^ ((i = s + ((o = i + (t ^ (s | ~n)) + r[2] + 718787259 & 4294967295) << 15 & 4294967295 | o >>> 17)) | ~t)) + r[9] + 3951481745 & 4294967295, e.g[0] = e.g[0] + t & 4294967295, e.g[1] = e.g[1] + (i + (o << 21 & 4294967295 | o >>> 11)) & 4294967295, e.g[2] = e.g[2] + i & 4294967295, e.g[3] = e.g[3] + s & 4294967295 } function r(e, t) { this.h = t; for (var n = [], r = !0, i = e.length - 1; 0 <= i; i--) { var s = 0 | e[i]; r && s == t || (n[i] = s, r = !1) } this.g = n } !function (e, t) { function n() { } n.prototype = t.prototype, e.D = t.prototype, e.prototype = new n, e.prototype.constructor = e, e.C = function (e, n, r) { for (var i = Array(arguments.length - 2), s = 2; s < arguments.length; s++)i[s - 2] = arguments[s]; return t.prototype[n].apply(e, i) } }(t, (function () { this.blockSize = -1 })), t.prototype.s = function () { this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0 }, t.prototype.u = function (e, t) { void 0 === t && (t = e.length); for (var r = t - this.blockSize, i = this.B, s = this.h, o = 0; o < t;) { if (0 == s) for (; o <= r;)n(this, e, o), o += this.blockSize; if ("string" === typeof e) { for (; o < t;)if (i[s++] = e.charCodeAt(o++), s == this.blockSize) { n(this, i), s = 0; break } } else for (; o < t;)if (i[s++] = e[o++], s == this.blockSize) { n(this, i), s = 0; break } } this.h = s, this.o += t }, t.prototype.v = function () { var e = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h); e[0] = 128; for (var t = 1; t < e.length - 8; ++t)e[t] = 0; var n = 8 * this.o; for (t = e.length - 8; t < e.length; ++t)e[t] = 255 & n, n /= 256; for (this.u(e), e = Array(16), t = n = 0; 4 > t; ++t)for (var r = 0; 32 > r; r += 8)e[n++] = this.g[t] >>> r & 255; return e }; var i = {}; function s(e) { return -128 <= e && 128 > e ? function (e, t) { var n = i; return Object.prototype.hasOwnProperty.call(n, e) ? n[e] : n[e] = t(e) }(e, (function (e) { return new r([0 | e], 0 > e ? -1 : 0) })) : new r([0 | e], 0 > e ? -1 : 0) } function o(e) { if (isNaN(e) || !isFinite(e)) return a; if (0 > e) return h(o(-e)); for (var t = [], n = 1, i = 0; e >= n; i++)t[i] = e / n | 0, n *= 4294967296; return new r(t, 0) } var a = s(0), l = s(1), c = s(16777216); function u(e) { if (0 != e.h) return !1; for (var t = 0; t < e.g.length; t++)if (0 != e.g[t]) return !1; return !0 } function d(e) { return -1 == e.h } function h(e) { for (var t = e.g.length, n = [], i = 0; i < t; i++)n[i] = ~e.g[i]; return new r(n, ~e.h).add(l) } function f(e, t) { return e.add(h(t)) } function p(e, t) { for (; (65535 & e[t]) != e[t];)e[t + 1] += e[t] >>> 16, e[t] &= 65535, t++ } function m(e, t) { this.g = e, this.h = t } function g(e, t) { if (u(t)) throw Error("division by zero"); if (u(e)) return new m(a, a); if (d(e)) return t = g(h(e), t), new m(h(t.g), h(t.h)); if (d(t)) return t = g(e, h(t)), new m(h(t.g), t.h); if (30 < e.g.length) { if (d(e) || d(t)) throw Error("slowDivide_ only works with positive integers."); for (var n = l, r = t; 0 >= r.l(e);)n = v(n), r = v(r); var i = y(n, 1), s = y(r, 1); for (r = y(r, 2), n = y(n, 2); !u(r);) { var c = s.add(r); 0 >= c.l(e) && (i = i.add(n), s = c), r = y(r, 1), n = y(n, 1) } return t = f(e, i.j(t)), new m(i, t) } for (i = a; 0 <= e.l(t);) { for (n = Math.max(1, Math.floor(e.m() / t.m())), r = 48 >= (r = Math.ceil(Math.log(n) / Math.LN2)) ? 1 : Math.pow(2, r - 48), c = (s = o(n)).j(t); d(c) || 0 < c.l(e);)c = (s = o(n -= r)).j(t); u(s) && (s = l), i = i.add(s), e = f(e, c) } return new m(i, e) } function v(e) { for (var t = e.g.length + 1, n = [], i = 0; i < t; i++)n[i] = e.i(i) << 1 | e.i(i - 1) >>> 31; return new r(n, e.h) } function y(e, t) { var n = t >> 5; t %= 32; for (var i = e.g.length - n, s = [], o = 0; o < i; o++)s[o] = 0 < t ? e.i(o + n) >>> t | e.i(o + n + 1) << 32 - t : e.i(o + n); return new r(s, e.h) } (e = r.prototype).m = function () { if (d(this)) return -h(this).m(); for (var e = 0, t = 1, n = 0; n < this.g.length; n++) { var r = this.i(n); e += (0 <= r ? r : 4294967296 + r) * t, t *= 4294967296 } return e }, e.toString = function (e) { if (2 > (e = e || 10) || 36 < e) throw Error("radix out of range: " + e); if (u(this)) return "0"; if (d(this)) return "-" + h(this).toString(e); for (var t = o(Math.pow(e, 6)), n = this, r = ""; ;) { var i = g(n, t).g, s = ((0 < (n = f(n, i.j(t))).g.length ? n.g[0] : n.h) >>> 0).toString(e); if (u(n = i)) return s + r; for (; 6 > s.length;)s = "0" + s; r = s + r } }, e.i = function (e) { return 0 > e ? 0 : e < this.g.length ? this.g[e] : this.h }, e.l = function (e) { return d(e = f(this, e)) ? -1 : u(e) ? 0 : 1 }, e.abs = function () { return d(this) ? h(this) : this }, e.add = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], i = 0, s = 0; s <= t; s++) { var o = i + (65535 & this.i(s)) + (65535 & e.i(s)), a = (o >>> 16) + (this.i(s) >>> 16) + (e.i(s) >>> 16); i = a >>> 16, o &= 65535, a &= 65535, n[s] = a << 16 | o } return new r(n, -2147483648 & n[n.length - 1] ? -1 : 0) }, e.j = function (e) { if (u(this) || u(e)) return a; if (d(this)) return d(e) ? h(this).j(h(e)) : h(h(this).j(e)); if (d(e)) return h(this.j(h(e))); if (0 > this.l(c) && 0 > e.l(c)) return o(this.m() * e.m()); for (var t = this.g.length + e.g.length, n = [], i = 0; i < 2 * t; i++)n[i] = 0; for (i = 0; i < this.g.length; i++)for (var s = 0; s < e.g.length; s++) { var l = this.i(i) >>> 16, f = 65535 & this.i(i), m = e.i(s) >>> 16, g = 65535 & e.i(s); n[2 * i + 2 * s] += f * g, p(n, 2 * i + 2 * s), n[2 * i + 2 * s + 1] += l * g, p(n, 2 * i + 2 * s + 1), n[2 * i + 2 * s + 1] += f * m, p(n, 2 * i + 2 * s + 1), n[2 * i + 2 * s + 2] += l * m, p(n, 2 * i + 2 * s + 2) } for (i = 0; i < t; i++)n[i] = n[2 * i + 1] << 16 | n[2 * i]; for (i = t; i < 2 * t; i++)n[i] = 0; return new r(n, 0) }, e.A = function (e) { return g(this, e).h }, e.and = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], i = 0; i < t; i++)n[i] = this.i(i) & e.i(i); return new r(n, this.h & e.h) }, e.or = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], i = 0; i < t; i++)n[i] = this.i(i) | e.i(i); return new r(n, this.h | e.h) }, e.xor = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], i = 0; i < t; i++)n[i] = this.i(i) ^ e.i(i); return new r(n, this.h ^ e.h) }, t.prototype.digest = t.prototype.v, t.prototype.reset = t.prototype.s, t.prototype.update = t.prototype.u, lE = uE.Md5 = t, r.prototype.add = r.prototype.add, r.prototype.multiply = r.prototype.j, r.prototype.modulo = r.prototype.A, r.prototype.compare = r.prototype.l, r.prototype.toNumber = r.prototype.m, r.prototype.toString = r.prototype.toString, r.prototype.getBits = r.prototype.i, r.fromNumber = o, r.fromString = function e(t, n) { if (0 == t.length) throw Error("number format error: empty string"); if (2 > (n = n || 10) || 36 < n) throw Error("radix out of range: " + n); if ("-" == t.charAt(0)) return h(e(t.substring(1), n)); if (0 <= t.indexOf("-")) throw Error('number format error: interior "-" character'); for (var r = o(Math.pow(n, 8)), i = a, s = 0; s < t.length; s += 8) { var l = Math.min(8, t.length - s), c = parseInt(t.substring(s, s + l), n); 8 > l ? (l = o(Math.pow(n, l)), i = i.j(l).add(o(c))) : i = (i = i.j(r)).add(o(c)) } return i }, aE = uE.Integer = r }).apply("undefined" !== typeof cE ? cE : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {}); var dE, hE, fE, pE, mE, gE, vE, yE, bE, wE = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {}, xE = {}; (function () { var e, t = "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, n) { return e == Array.prototype || e == Object.prototype || (e[t] = n.value), e }; var n = function (e) { e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof wE && wE]; for (var t = 0; t < e.length; ++t) { var n = e[t]; if (n && n.Math == Math) return n } throw Error("Cannot find global object") }(this); !function (e, r) { if (r) e: { var i = n; e = e.split("."); for (var s = 0; s < e.length - 1; s++) { var o = e[s]; if (!(o in i)) break e; i = i[o] } (r = r(s = i[e = e[e.length - 1]])) != s && null != r && t(i, e, { configurable: !0, writable: !0, value: r }) } }("Array.prototype.values", (function (e) { return e || function () { return function (e, t) { e instanceof String && (e += ""); var n = 0, r = !1, i = { next: function () { if (!r && n < e.length) { var i = n++; return { value: t(i, e[i]), done: !1 } } return r = !0, { done: !0, value: void 0 } } }; return i[Symbol.iterator] = function () { return i }, i }(this, (function (e, t) { return t })) } })); var r = r || {}, i = this || self; function s(e) { var t = typeof e; return "array" == (t = "object" != t ? t : e ? Array.isArray(e) ? "array" : t : "null") || "object" == t && "number" == typeof e.length } function o(e) { var t = typeof e; return "object" == t && null != e || "function" == t } function a(e, t, n) { return e.call.apply(e.bind, arguments) } function l(e, t, n) { if (!e) throw Error(); if (2 < arguments.length) { var r = Array.prototype.slice.call(arguments, 2); return function () { var n = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(n, r), e.apply(t, n) } } return function () { return e.apply(t, arguments) } } function c(e, t, n) { return (c = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? a : l).apply(null, arguments) } function u(e, t) { var n = Array.prototype.slice.call(arguments, 1); return function () { var t = n.slice(); return t.push.apply(t, arguments), e.apply(this, t) } } function d(e, t) { function n() { } n.prototype = t.prototype, e.aa = t.prototype, e.prototype = new n, e.prototype.constructor = e, e.Qb = function (e, n, r) { for (var i = Array(arguments.length - 2), s = 2; s < arguments.length; s++)i[s - 2] = arguments[s]; return t.prototype[n].apply(e, i) } } function h(e) { const t = e.length; if (0 < t) { const n = Array(t); for (let r = 0; r < t; r++)n[r] = e[r]; return n } return [] } function f(e, t) { for (let n = 1; n < arguments.length; n++) { const t = arguments[n]; if (s(t)) { const n = e.length || 0, r = t.length || 0; e.length = n + r; for (let i = 0; i < r; i++)e[n + i] = t[i] } else e.push(t) } } function p(e) { return /^[\s\xa0]*$/.test(e) } function m() { var e = i.navigator; return e && (e = e.userAgent) ? e : "" } function g(e) { return g[" "](e), e } g[" "] = function () { }; var v = -1 != m().indexOf("Gecko") && !(-1 != m().toLowerCase().indexOf("webkit") && -1 == m().indexOf("Edge")) && !(-1 != m().indexOf("Trident") || -1 != m().indexOf("MSIE")) && -1 == m().indexOf("Edge"); function y(e, t, n) { for (const r in e) t.call(n, e[r], r, e) } function b(e) { const t = {}; for (const n in e) t[n] = e[n]; return t } const w = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function x(e, t) { let n, r; for (let i = 1; i < arguments.length; i++) { for (n in r = arguments[i], r) e[n] = r[n]; for (let t = 0; t < w.length; t++)n = w[t], Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]) } } function E(e) { var t = 1; e = e.split(":"); const n = []; for (; 0 < t && e.length;)n.push(e.shift()), t--; return e.length && n.push(e.join(":")), n } function S(e) { i.setTimeout((() => { throw e }), 0) } function N() { var e = j; let t = null; return e.g && (t = e.g, e.g = e.g.next, e.g || (e.h = null), t.next = null), t } var C = new class { constructor(e, t) { this.i = e, this.j = t, this.h = 0, this.g = null } get() { let e; return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e } }((() => new T), (e => e.reset())); class T { constructor() { this.next = this.g = this.h = null } set(e, t) { this.h = e, this.g = t, this.next = null } reset() { this.next = this.g = this.h = null } } let A, k = !1, j = new class { constructor() { this.h = this.g = null } add(e, t) { const n = C.get(); n.set(e, t), this.h ? this.h.next = n : this.g = n, this.h = n } }, P = () => { const e = i.Promise.resolve(void 0); A = () => { e.then(I) } }; var I = () => { for (var e; e = N();) { try { e.h.call(e.g) } catch (n) { S(n) } var t = C; t.j(e), 100 > t.h && (t.h++, e.next = t.g, t.g = e) } k = !1 }; function R() { this.s = this.s, this.C = this.C } function O(e, t) { this.type = e, this.g = this.target = t, this.defaultPrevented = !1 } R.prototype.s = !1, R.prototype.ma = function () { this.s || (this.s = !0, this.N()) }, R.prototype.N = function () { if (this.C) for (; this.C.length;)this.C.shift()() }, O.prototype.h = function () { this.defaultPrevented = !0 }; var D = function () { if (!i.addEventListener || !Object.defineProperty) return !1; var e = !1, t = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); try { const e = () => { }; i.addEventListener("test", e, t), i.removeEventListener("test", e, t) } catch (n) { } return e }(); function _(e, t) { if (O.call(this, e ? e.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, e) { var n = this.type = e.type, r = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null; if (this.target = e.target || e.srcElement, this.g = t, t = e.relatedTarget) { if (v) { e: { try { g(t.nodeName); var i = !0; break e } catch (s) { } i = !1 } i || (t = null) } } else "mouseover" == n ? t = e.fromElement : "mouseout" == n && (t = e.toElement); this.relatedTarget = t, r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = void 0 !== e.clientX ? e.clientX : e.pageX, this.clientY = void 0 !== e.clientY ? e.clientY : e.pageY, this.screenX = e.screenX || 0, this.screenY = e.screenY || 0), this.button = e.button, this.key = e.key || "", this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.pointerId = e.pointerId || 0, this.pointerType = "string" === typeof e.pointerType ? e.pointerType : M[e.pointerType] || "", this.state = e.state, this.i = e, e.defaultPrevented && _.aa.h.call(this) } } d(_, O); var M = { 2: "touch", 3: "pen", 4: "mouse" }; _.prototype.h = function () { _.aa.h.call(this); var e = this.i; e.preventDefault ? e.preventDefault() : e.returnValue = !1 }; var L = "closure_listenable_" + (1e6 * Math.random() | 0), F = 0; function U(e, t, n, r, i) { this.listener = e, this.proxy = null, this.src = t, this.type = n, this.capture = !!r, this.ha = i, this.key = ++F, this.da = this.fa = !1 } function B(e) { e.da = !0, e.listener = null, e.proxy = null, e.src = null, e.ha = null } function V(e) { this.src = e, this.g = {}, this.h = 0 } function z(e, t) { var n = t.type; if (n in e.g) { var r, i = e.g[n], s = Array.prototype.indexOf.call(i, t, void 0); (r = 0 <= s) && Array.prototype.splice.call(i, s, 1), r && (B(t), 0 == e.g[n].length && (delete e.g[n], e.h--)) } } function q(e, t, n, r) { for (var i = 0; i < e.length; ++i) { var s = e[i]; if (!s.da && s.listener == t && s.capture == !!n && s.ha == r) return i } return -1 } V.prototype.add = function (e, t, n, r, i) { var s = e.toString(); (e = this.g[s]) || (e = this.g[s] = [], this.h++); var o = q(e, t, r, i); return -1 < o ? (t = e[o], n || (t.fa = !1)) : ((t = new U(t, this.src, s, !!r, i)).fa = n, e.push(t)), t }; var H = "closure_lm_" + (1e6 * Math.random() | 0), W = {}; function K(e, t, n, r, i) { if (r && r.once) return Q(e, t, n, r, i); if (Array.isArray(t)) { for (var s = 0; s < t.length; s++)K(e, t[s], n, r, i); return null } return n = te(n), e && e[L] ? e.K(t, n, o(r) ? !!r.capture : !!r, i) : G(e, t, n, !1, r, i) } function G(e, t, n, r, i, s) { if (!t) throw Error("Invalid event type"); var a = o(i) ? !!i.capture : !!i, l = $(e); if (l || (e[H] = l = new V(e)), (n = l.add(t, n, r, a, s)).proxy) return n; if (r = function () { function e(n) { return t.call(e.src, e.listener, n) } const t = Z; return e }(), n.proxy = r, r.src = e, r.listener = n, e.addEventListener) D || (i = a), void 0 === i && (i = !1), e.addEventListener(t.toString(), r, i); else if (e.attachEvent) e.attachEvent(X(t.toString()), r); else { if (!e.addListener || !e.removeListener) throw Error("addEventListener and attachEvent are unavailable."); e.addListener(r) } return n } function Q(e, t, n, r, i) { if (Array.isArray(t)) { for (var s = 0; s < t.length; s++)Q(e, t[s], n, r, i); return null } return n = te(n), e && e[L] ? e.L(t, n, o(r) ? !!r.capture : !!r, i) : G(e, t, n, !0, r, i) } function Y(e, t, n, r, i) { if (Array.isArray(t)) for (var s = 0; s < t.length; s++)Y(e, t[s], n, r, i); else r = o(r) ? !!r.capture : !!r, n = te(n), e && e[L] ? (e = e.i, (t = String(t).toString()) in e.g && (-1 < (n = q(s = e.g[t], n, r, i)) && (B(s[n]), Array.prototype.splice.call(s, n, 1), 0 == s.length && (delete e.g[t], e.h--)))) : e && (e = $(e)) && (t = e.g[t.toString()], e = -1, t && (e = q(t, n, r, i)), (n = -1 < e ? t[e] : null) && J(n)) } function J(e) { if ("number" !== typeof e && e && !e.da) { var t = e.src; if (t && t[L]) z(t.i, e); else { var n = e.type, r = e.proxy; t.removeEventListener ? t.removeEventListener(n, r, e.capture) : t.detachEvent ? t.detachEvent(X(n), r) : t.addListener && t.removeListener && t.removeListener(r), (n = $(t)) ? (z(n, e), 0 == n.h && (n.src = null, t[H] = null)) : B(e) } } } function X(e) { return e in W ? W[e] : W[e] = "on" + e } function Z(e, t) { if (e.da) e = !0; else { t = new _(t, this); var n = e.listener, r = e.ha || e.src; e.fa && J(e), e = n.call(r, t) } return e } function $(e) { return (e = e[H]) instanceof V ? e : null } var ee = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function te(e) { return "function" === typeof e ? e : (e[ee] || (e[ee] = function (t) { return e.handleEvent(t) }), e[ee]) } function ne() { R.call(this), this.i = new V(this), this.M = this, this.F = null } function re(e, t) { var n, r = e.F; if (r) for (n = []; r; r = r.F)n.push(r); if (e = e.M, r = t.type || t, "string" === typeof t) t = new O(t, e); else if (t instanceof O) t.target = t.target || e; else { var i = t; x(t = new O(r, e), i) } if (i = !0, n) for (var s = n.length - 1; 0 <= s; s--) { var o = t.g = n[s]; i = ie(o, r, !0, t) && i } if (i = ie(o = t.g = e, r, !0, t) && i, i = ie(o, r, !1, t) && i, n) for (s = 0; s < n.length; s++)i = ie(o = t.g = n[s], r, !1, t) && i } function ie(e, t, n, r) { if (!(t = e.i.g[String(t)])) return !0; t = t.concat(); for (var i = !0, s = 0; s < t.length; ++s) { var o = t[s]; if (o && !o.da && o.capture == n) { var a = o.listener, l = o.ha || o.src; o.fa && z(e.i, o), i = !1 !== a.call(l, r) && i } } return i && !r.defaultPrevented } function se(e, t, n) { if ("function" === typeof e) n && (e = c(e, n)); else { if (!e || "function" != typeof e.handleEvent) throw Error("Invalid listener argument"); e = c(e.handleEvent, e) } return 2147483647 < Number(t) ? -1 : i.setTimeout(e, t || 0) } function oe(e) { e.g = se((() => { e.g = null, e.i && (e.i = !1, oe(e)) }), e.l); const t = e.h; e.h = null, e.m.apply(null, t) } d(ne, R), ne.prototype[L] = !0, ne.prototype.removeEventListener = function (e, t, n, r) { Y(this, e, t, n, r) }, ne.prototype.N = function () { if (ne.aa.N.call(this), this.i) { var e, t = this.i; for (e in t.g) { for (var n = t.g[e], r = 0; r < n.length; r++)B(n[r]); delete t.g[e], t.h-- } } this.F = null }, ne.prototype.K = function (e, t, n, r) { return this.i.add(String(e), t, !1, n, r) }, ne.prototype.L = function (e, t, n, r) { return this.i.add(String(e), t, !0, n, r) }; class ae extends R { constructor(e, t) { super(), this.m = e, this.l = t, this.h = null, this.i = !1, this.g = null } j(e) { this.h = arguments, this.g ? this.i = !0 : oe(this) } N() { super.N(), this.g && (i.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function le(e) { R.call(this), this.h = e, this.g = {} } d(le, R); var ce = []; function ue(e) { y(e.g, (function (e, t) { this.g.hasOwnProperty(t) && J(e) }), e), e.g = {} } le.prototype.N = function () { le.aa.N.call(this), ue(this) }, le.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }; var de = i.JSON.stringify, he = i.JSON.parse, fe = class { stringify(e) { return i.JSON.stringify(e, void 0) } parse(e) { return i.JSON.parse(e, void 0) } }; function pe() { } function me(e) { return e.h || (e.h = e.i()) } function ge() { } pe.prototype.h = null; var ve = { OPEN: "a", kb: "b", Ja: "c", wb: "d" }; function ye() { O.call(this, "d") } function be() { O.call(this, "c") } d(ye, O), d(be, O); var we = {}, xe = null; function Ee() { return xe = xe || new ne } function Se(e) { O.call(this, we.La, e) } function Ne(e) { const t = Ee(); re(t, new Se(t)) } function Ce(e, t) { O.call(this, we.STAT_EVENT, e), this.stat = t } function Te(e) { const t = Ee(); re(t, new Ce(t, e)) } function Ae(e, t) { O.call(this, we.Ma, e), this.size = t } function ke(e, t) { if ("function" !== typeof e) throw Error("Fn must not be null and must be a function"); return i.setTimeout((function () { e() }), t) } function je() { this.g = !0 } function Pe(e, t, n, r) { e.info((function () { return "XMLHTTP TEXT (" + t + "): " + function (e, t) { if (!e.g) return t; if (!t) return null; try { var n = JSON.parse(t); if (n) for (e = 0; e < n.length; e++)if (Array.isArray(n[e])) { var r = n[e]; if (!(2 > r.length)) { var i = r[1]; if (Array.isArray(i) && !(1 > i.length)) { var s = i[0]; if ("noop" != s && "stop" != s && "close" != s) for (var o = 1; o < i.length; o++)i[o] = "" } } } return de(n) } catch (a) { return t } }(e, n) + (r ? " " + r : "") })) } we.La = "serverreachability", d(Se, O), we.STAT_EVENT = "statevent", d(Ce, O), we.Ma = "timingevent", d(Ae, O), je.prototype.xa = function () { this.g = !1 }, je.prototype.info = function () { }; var Ie, Re = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 }, Oe = { lb: "complete", Hb: "success", Ja: "error", Ia: "abort", zb: "ready", Ab: "readystatechange", TIMEOUT: "timeout", vb: "incrementaldata", yb: "progress", ob: "downloadprogress", Pb: "uploadprogress" }; function De() { } function _e(e, t, n, r) { this.j = e, this.i = t, this.l = n, this.R = r || 1, this.U = new le(this), this.I = 45e3, this.H = null, this.o = !1, this.m = this.A = this.v = this.L = this.F = this.S = this.B = null, this.D = [], this.g = null, this.C = 0, this.s = this.u = null, this.X = -1, this.J = !1, this.O = 0, this.M = null, this.W = this.K = this.T = this.P = !1, this.h = new Me } function Me() { this.i = null, this.g = "", this.h = !1 } d(De, pe), De.prototype.g = function () { return new XMLHttpRequest }, De.prototype.i = function () { return {} }, Ie = new De; var Le = {}, Fe = {}; function Ue(e, t, n) { e.L = 1, e.v = dt(ot(t)), e.m = n, e.P = !0, Be(e, null) } function Be(e, t) { e.F = Date.now(), qe(e), e.A = ot(e.v); var n = e.A, r = e.R; Array.isArray(r) || (r = [String(r)]), Nt(n.i, "t", r), e.C = 0, n = e.j.J, e.h = new Me, e.g = hn(e.j, n ? t : null, !e.m), 0 < e.O && (e.M = new ae(c(e.Y, e, e.g), e.O)), t = e.U, n = e.g, r = e.ca; var i = "readystatechange"; Array.isArray(i) || (i && (ce[0] = i.toString()), i = ce); for (var s = 0; s < i.length; s++) { var o = K(n, i[s], r || t.handleEvent, !1, t.h || t); if (!o) break; t.g[o.key] = o } t = e.H ? b(e.H) : {}, e.m ? (e.u || (e.u = "POST"), t["Content-Type"] = "application/x-www-form-urlencoded", e.g.ea(e.A, e.u, e.m, t)) : (e.u = "GET", e.g.ea(e.A, e.u, null, t)), Ne(), function (e, t, n, r, i, s) { e.info((function () { if (e.g) if (s) for (var o = "", a = s.split("&"), l = 0; l < a.length; l++) { var c = a[l].split("="); if (1 < c.length) { var u = c[0]; c = c[1]; var d = u.split("_"); o = 2 <= d.length && "type" == d[1] ? o + (u + "=") + c + "&" : o + (u + "=redacted&") } } else o = null; else o = s; return "XMLHTTP REQ (" + r + ") [attempt " + i + "]: " + t + "\n" + n + "\n" + o })) }(e.i, e.u, e.A, e.l, e.R, e.m) } function Ve(e) { return !!e.g && ("GET" == e.u && 2 != e.L && e.j.Ca) } function ze(e, t) { var n = e.C, r = t.indexOf("\n", n); return -1 == r ? Fe : (n = Number(t.substring(n, r)), isNaN(n) ? Le : (r += 1) + n > t.length ? Fe : (t = t.slice(r, r + n), e.C = r + n, t)) } function qe(e) { e.S = Date.now() + e.I, He(e, e.I) } function He(e, t) { if (null != e.B) throw Error("WatchDog timer not null"); e.B = ke(c(e.ba, e), t) } function We(e) { e.B && (i.clearTimeout(e.B), e.B = null) } function Ke(e) { 0 == e.j.G || e.J || an(e.j, e) } function Ge(e) { We(e); var t = e.M; t && "function" == typeof t.ma && t.ma(), e.M = null, ue(e.U), e.g && (t = e.g, e.g = null, t.abort(), t.ma()) } function Qe(e, t) { try { var n = e.j; if (0 != n.G && (n.g == e || $e(n.h, e))) if (!e.K && $e(n.h, e) && 3 == n.G) { try { var r = n.Da.g.parse(t) } catch (u) { r = null } if (Array.isArray(r) && 3 == r.length) { var i = r; if (0 == i[0]) { e: if (!n.u) { if (n.g) { if (!(n.g.F + 3e3 < e.F)) break e; on(n), Yt(n) } nn(n), Te(18) } } else n.za = i[1], 0 < n.za - n.T && 37500 > i[2] && n.F && 0 == n.v && !n.C && (n.C = ke(c(n.Za, n), 6e3)); if (1 >= Ze(n.h) && n.ca) { try { n.ca() } catch (u) { } n.ca = void 0 } } else cn(n, 11) } else if ((e.K || n.g == e) && on(n), !p(t)) for (i = n.Da.g.parse(t), t = 0; t < i.length; t++) { let c = i[t]; if (n.T = c[0], c = c[1], 2 == n.G) if ("c" == c[0]) { n.K = c[1], n.ia = c[2]; const t = c[3]; null != t && (n.la = t, n.j.info("VER=" + n.la)); const i = c[4]; null != i && (n.Aa = i, n.j.info("SVER=" + n.Aa)); const u = c[5]; null != u && "number" === typeof u && 0 < u && (r = 1.5 * u, n.L = r, n.j.info("backChannelRequestTimeoutMs_=" + r)), r = n; const d = e.g; if (d) { const e = d.g ? d.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (e) { var s = r.h; s.g || -1 == e.indexOf("spdy") && -1 == e.indexOf("quic") && -1 == e.indexOf("h2") || (s.j = s.l, s.g = new Set, s.h && (et(s, s.h), s.h = null)) } if (r.D) { const e = d.g ? d.g.getResponseHeader("X-HTTP-Session-Id") : null; e && (r.ya = e, ut(r.I, r.D, e)) } } n.G = 3, n.l && n.l.ua(), n.ba && (n.R = Date.now() - e.F, n.j.info("Handshake RTT: " + n.R + "ms")); var o = e; if ((r = n).qa = dn(r, r.J ? r.ia : null, r.W), o.K) { tt(r.h, o); var a = o, l = r.L; l && (a.I = l), a.B && (We(a), qe(a)), r.g = o } else tn(r); 0 < n.i.length && Xt(n) } else "stop" != c[0] && "close" != c[0] || cn(n, 7); else 3 == n.G && ("stop" == c[0] || "close" == c[0] ? "stop" == c[0] ? cn(n, 7) : Qt(n) : "noop" != c[0] && n.l && n.l.ta(c), n.v = 0) } Ne() } catch (u) { } } _e.prototype.ca = function (e) { e = e.target; const t = this.M; t && 3 == Ht(e) ? t.j() : this.Y(e) }, _e.prototype.Y = function (e) { try { if (e == this.g) e: { const h = Ht(this.g); var t = this.g.Ba(); this.g.Z(); if (!(3 > h) && (3 != h || this.g && (this.h.h || this.g.oa() || Wt(this.g)))) { this.J || 4 != h || 7 == t || Ne(), We(this); var n = this.g.Z(); this.X = n; t: if (Ve(this)) { var r = Wt(this.g); e = ""; var s = r.length, o = 4 == Ht(this.g); if (!this.h.i) { if ("undefined" === typeof TextDecoder) { Ge(this), Ke(this); var a = ""; break t } this.h.i = new i.TextDecoder } for (t = 0; t < s; t++)this.h.h = !0, e += this.h.i.decode(r[t], { stream: !(o && t == s - 1) }); r.length = 0, this.h.g += e, this.C = 0, a = this.h.g } else a = this.g.oa(); if (this.o = 200 == n, function (e, t, n, r, i, s, o) { e.info((function () { return "XMLHTTP RESP (" + r + ") [ attempt " + i + "]: " + t + "\n" + n + "\n" + s + " " + o })) }(this.i, this.u, this.A, this.l, this.R, h, n), this.o) { if (this.T && !this.K) { t: { if (this.g) { var l, c = this.g; if ((l = c.g ? c.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !p(l)) { var u = l; break t } } u = null } if (!(n = u)) { this.o = !1, this.s = 3, Te(12), Ge(this), Ke(this); break e } Pe(this.i, this.l, n, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, Qe(this, n) } if (this.P) { let e; for (n = !0; !this.J && this.C < a.length;) { if (e = ze(this, a), e == Fe) { 4 == h && (this.s = 4, Te(14), n = !1), Pe(this.i, this.l, null, "[Incomplete Response]"); break } if (e == Le) { this.s = 4, Te(15), Pe(this.i, this.l, a, "[Invalid Chunk]"), n = !1; break } Pe(this.i, this.l, e, null), Qe(this, e) } if (Ve(this) && 0 != this.C && (this.h.g = this.h.g.slice(this.C), this.C = 0), 4 != h || 0 != a.length || this.h.h || (this.s = 1, Te(16), n = !1), this.o = this.o && n, n) { if (0 < a.length && !this.W) { this.W = !0; var d = this.j; d.g == this && d.ba && !d.M && (d.j.info("Great, no buffering proxy detected. Bytes received: " + a.length), rn(d), d.M = !0, Te(11)) } } else Pe(this.i, this.l, a, "[Invalid Chunked Response]"), Ge(this), Ke(this) } else Pe(this.i, this.l, a, null), Qe(this, a); 4 == h && Ge(this), this.o && !this.J && (4 == h ? an(this.j, this) : (this.o = !1, qe(this))) } else (function (e) { const t = {}; e = (e.g && 2 <= Ht(e) && e.g.getAllResponseHeaders() || "").split("\r\n"); for (let r = 0; r < e.length; r++) { if (p(e[r])) continue; var n = E(e[r]); const i = n[0]; if ("string" !== typeof (n = n[1])) continue; n = n.trim(); const s = t[i] || []; t[i] = s, s.push(n) } !function (e, t) { for (const n in e) t.call(void 0, e[n], n, e) }(t, (function (e) { return e.join(", ") })) })(this.g), 400 == n && 0 < a.indexOf("Unknown SID") ? (this.s = 3, Te(12)) : (this.s = 0, Te(13)), Ge(this), Ke(this) } } } catch (h) { } }, _e.prototype.cancel = function () { this.J = !0, Ge(this) }, _e.prototype.ba = function () { this.B = null; const e = Date.now(); 0 <= e - this.S ? (function (e, t) { e.info((function () { return "TIMEOUT: " + t })) }(this.i, this.A), 2 != this.L && (Ne(), Te(17)), Ge(this), this.s = 2, Ke(this)) : He(this, this.S - e) }; var Ye = class { constructor(e, t) { this.g = e, this.map = t } }; function Je(e) { this.l = e || 10, i.PerformanceNavigationTiming ? e = 0 < (e = i.performance.getEntriesByType("navigation")).length && ("hq" == e[0].nextHopProtocol || "h2" == e[0].nextHopProtocol) : e = !!(i.chrome && i.chrome.loadTimes && i.chrome.loadTimes() && i.chrome.loadTimes().wasFetchedViaSpdy), this.j = e ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } function Xe(e) { return !!e.h || !!e.g && e.g.size >= e.j } function Ze(e) { return e.h ? 1 : e.g ? e.g.size : 0 } function $e(e, t) { return e.h ? e.h == t : !!e.g && e.g.has(t) } function et(e, t) { e.g ? e.g.add(t) : e.h = t } function tt(e, t) { e.h && e.h == t ? e.h = null : e.g && e.g.has(t) && e.g.delete(t) } function nt(e) { if (null != e.h) return e.i.concat(e.h.D); if (null != e.g && 0 !== e.g.size) { let t = e.i; for (const n of e.g.values()) t = t.concat(n.D); return t } return h(e.i) } function rt(e, t) { if (e.forEach && "function" == typeof e.forEach) e.forEach(t, void 0); else if (s(e) || "string" === typeof e) Array.prototype.forEach.call(e, t, void 0); else for (var n = function (e) { if (e.na && "function" == typeof e.na) return e.na(); if (!e.V || "function" != typeof e.V) { if ("undefined" !== typeof Map && e instanceof Map) return Array.from(e.keys()); if (!("undefined" !== typeof Set && e instanceof Set)) { if (s(e) || "string" === typeof e) { var t = []; e = e.length; for (var n = 0; n < e; n++)t.push(n); return t } t = [], n = 0; for (const r in e) t[n++] = r; return t } } }(e), r = function (e) { if (e.V && "function" == typeof e.V) return e.V(); if ("undefined" !== typeof Map && e instanceof Map || "undefined" !== typeof Set && e instanceof Set) return Array.from(e.values()); if ("string" === typeof e) return e.split(""); if (s(e)) { for (var t = [], n = e.length, r = 0; r < n; r++)t.push(e[r]); return t } for (r in t = [], n = 0, e) t[n++] = e[r]; return t }(e), i = r.length, o = 0; o < i; o++)t.call(void 0, r[o], n && n[o], e) } Je.prototype.cancel = function () { if (this.i = nt(this), this.h) this.h.cancel(), this.h = null; else if (this.g && 0 !== this.g.size) { for (const e of this.g.values()) e.cancel(); this.g.clear() } }; var it = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function st(e) { if (this.g = this.o = this.j = "", this.s = null, this.m = this.l = "", this.h = !1, e instanceof st) { this.h = e.h, at(this, e.j), this.o = e.o, this.g = e.g, lt(this, e.s), this.l = e.l; var t = e.i, n = new wt; n.i = t.i, t.g && (n.g = new Map(t.g), n.h = t.h), ct(this, n), this.m = e.m } else e && (t = String(e).match(it)) ? (this.h = !1, at(this, t[1] || "", !0), this.o = ht(t[2] || ""), this.g = ht(t[3] || "", !0), lt(this, t[4]), this.l = ht(t[5] || "", !0), ct(this, t[6] || "", !0), this.m = ht(t[7] || "")) : (this.h = !1, this.i = new wt(null, this.h)) } function ot(e) { return new st(e) } function at(e, t, n) { e.j = n ? ht(t, !0) : t, e.j && (e.j = e.j.replace(/:$/, "")) } function lt(e, t) { if (t) { if (t = Number(t), isNaN(t) || 0 > t) throw Error("Bad port number " + t); e.s = t } else e.s = null } function ct(e, t, n) { t instanceof wt ? (e.i = t, function (e, t) { t && !e.j && (xt(e), e.i = null, e.g.forEach((function (e, t) { var n = t.toLowerCase(); t != n && (Et(this, t), Nt(this, n, e)) }), e)), e.j = t }(e.i, e.h)) : (n || (t = ft(t, yt)), e.i = new wt(t, e.h)) } function ut(e, t, n) { e.i.set(t, n) } function dt(e) { return ut(e, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), e } function ht(e, t) { return e ? t ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : "" } function ft(e, t, n) { return "string" === typeof e ? (e = encodeURI(e).replace(t, pt), n && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), e) : null } function pt(e) { return "%" + ((e = e.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & e).toString(16) } st.prototype.toString = function () { var e = [], t = this.j; t && e.push(ft(t, mt, !0), ":"); var n = this.g; return (n || "file" == t) && (e.push("//"), (t = this.o) && e.push(ft(t, mt, !0), "@"), e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (n = this.s) && e.push(":", String(n))), (n = this.l) && (this.g && "/" != n.charAt(0) && e.push("/"), e.push(ft(n, "/" == n.charAt(0) ? vt : gt, !0))), (n = this.i.toString()) && e.push("?", n), (n = this.m) && e.push("#", ft(n, bt)), e.join("") }; var mt = /[#\/\?@]/g, gt = /[#\?:]/g, vt = /[#\?]/g, yt = /[#\?@]/g, bt = /#/g; function wt(e, t) { this.h = this.g = null, this.i = e || null, this.j = !!t } function xt(e) { e.g || (e.g = new Map, e.h = 0, e.i && function (e, t) { if (e) { e = e.split("&"); for (var n = 0; n < e.length; n++) { var r = e[n].indexOf("="), i = null; if (0 <= r) { var s = e[n].substring(0, r); i = e[n].substring(r + 1) } else s = e[n]; t(s, i ? decodeURIComponent(i.replace(/\+/g, " ")) : "") } } }(e.i, (function (t, n) { e.add(decodeURIComponent(t.replace(/\+/g, " ")), n) }))) } function Et(e, t) { xt(e), t = Ct(e, t), e.g.has(t) && (e.i = null, e.h -= e.g.get(t).length, e.g.delete(t)) } function St(e, t) { return xt(e), t = Ct(e, t), e.g.has(t) } function Nt(e, t, n) { Et(e, t), 0 < n.length && (e.i = null, e.g.set(Ct(e, t), h(n)), e.h += n.length) } function Ct(e, t) { return t = String(t), e.j && (t = t.toLowerCase()), t } function Tt(e, t, n, r, i) { try { i && (i.onload = null, i.onerror = null, i.onabort = null, i.ontimeout = null), r(n) } catch (s) { } } function At() { this.g = new fe } function kt(e, t, n) { const r = n || ""; try { rt(e, (function (e, n) { let i = e; o(e) && (i = de(e)), t.push(r + n + "=" + encodeURIComponent(i)) })) } catch (sI) { throw t.push(r + "type=" + encodeURIComponent("_badmap")), sI } } function jt(e) { this.l = e.Ub || null, this.j = e.eb || !1 } function Pt(e, t) { ne.call(this), this.D = e, this.o = t, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.u = new Headers, this.h = null, this.B = "GET", this.A = "", this.g = !1, this.v = this.j = this.l = null } function It(e) { e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e)) } function Rt(e) { e.readyState = 4, e.l = null, e.j = null, e.v = null, Ot(e) } function Ot(e) { e.onreadystatechange && e.onreadystatechange.call(e) } function Dt(e) { let t = ""; return y(e, (function (e, n) { t += n, t += ":", t += e, t += "\r\n" })), t } function _t(e, t, n) { e: { for (r in n) { var r = !1; break e } r = !0 } r || (n = Dt(n), "string" === typeof e ? null != n && encodeURIComponent(String(n)) : ut(e, t, n)) } function Mt(e) { ne.call(this), this.headers = new Map, this.o = e || null, this.h = !1, this.v = this.g = null, this.D = "", this.m = 0, this.l = "", this.j = this.B = this.u = this.A = !1, this.I = null, this.H = "", this.J = !1 } (e = wt.prototype).add = function (e, t) { xt(this), this.i = null, e = Ct(this, e); var n = this.g.get(e); return n || this.g.set(e, n = []), n.push(t), this.h += 1, this }, e.forEach = function (e, t) { xt(this), this.g.forEach((function (n, r) { n.forEach((function (n) { e.call(t, n, r, this) }), this) }), this) }, e.na = function () { xt(this); const e = Array.from(this.g.values()), t = Array.from(this.g.keys()), n = []; for (let r = 0; r < t.length; r++) { const i = e[r]; for (let e = 0; e < i.length; e++)n.push(t[r]) } return n }, e.V = function (e) { xt(this); let t = []; if ("string" === typeof e) St(this, e) && (t = t.concat(this.g.get(Ct(this, e)))); else { e = Array.from(this.g.values()); for (let n = 0; n < e.length; n++)t = t.concat(e[n]) } return t }, e.set = function (e, t) { return xt(this), this.i = null, St(this, e = Ct(this, e)) && (this.h -= this.g.get(e).length), this.g.set(e, [t]), this.h += 1, this }, e.get = function (e, t) { return e && 0 < (e = this.V(e)).length ? String(e[0]) : t }, e.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const e = [], t = Array.from(this.g.keys()); for (var n = 0; n < t.length; n++) { var r = t[n]; const s = encodeURIComponent(String(r)), o = this.V(r); for (r = 0; r < o.length; r++) { var i = s; "" !== o[r] && (i += "=" + encodeURIComponent(String(o[r]))), e.push(i) } } return this.i = e.join("&") }, d(jt, pe), jt.prototype.g = function () { return new Pt(this.l, this.j) }, jt.prototype.i = function (e) { return function () { return e } }({}), d(Pt, ne), (e = Pt.prototype).open = function (e, t) { if (0 != this.readyState) throw this.abort(), Error("Error reopening a connection"); this.B = e, this.A = t, this.readyState = 1, Ot(this) }, e.send = function (e) { if (1 != this.readyState) throw this.abort(), Error("need to call open() first. "); this.g = !0; const t = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 }; e && (t.body = e), (this.D || i).fetch(new Request(this.A, t)).then(this.Sa.bind(this), this.ga.bind(this)) }, e.abort = function () { this.response = this.responseText = "", this.u = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch((() => { })), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1, Rt(this)), this.readyState = 0 }, e.Sa = function (e) { if (this.g && (this.l = e, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = e.headers, this.readyState = 2, Ot(this)), this.g && (this.readyState = 3, Ot(this), this.g))) if ("arraybuffer" === this.responseType) e.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this)); else if ("undefined" !== typeof i.ReadableStream && "body" in e) { if (this.j = e.body.getReader(), this.o) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.v = new TextDecoder; It(this) } else e.text().then(this.Ra.bind(this), this.ga.bind(this)) }, e.Pa = function (e) { if (this.g) { if (this.o && e.value) this.response.push(e.value); else if (!this.o) { var t = e.value ? e.value : new Uint8Array(0); (t = this.v.decode(t, { stream: !e.done })) && (this.response = this.responseText += t) } e.done ? Rt(this) : Ot(this), 3 == this.readyState && It(this) } }, e.Ra = function (e) { this.g && (this.response = this.responseText = e, Rt(this)) }, e.Qa = function (e) { this.g && (this.response = e, Rt(this)) }, e.ga = function () { this.g && Rt(this) }, e.setRequestHeader = function (e, t) { this.u.append(e, t) }, e.getResponseHeader = function (e) { return this.h && this.h.get(e.toLowerCase()) || "" }, e.getAllResponseHeaders = function () { if (!this.h) return ""; const e = [], t = this.h.entries(); for (var n = t.next(); !n.done;)n = n.value, e.push(n[0] + ": " + n[1]), n = t.next(); return e.join("\r\n") }, Object.defineProperty(Pt.prototype, "withCredentials", { get: function () { return "include" === this.m }, set: function (e) { this.m = e ? "include" : "same-origin" } }), d(Mt, ne); var Lt = /^https?$/i, Ft = ["POST", "PUT"]; function Ut(e, t) { e.h = !1, e.g && (e.j = !0, e.g.abort(), e.j = !1), e.l = t, e.m = 5, Bt(e), zt(e) } function Bt(e) { e.A || (e.A = !0, re(e, "complete"), re(e, "error")) } function Vt(e) { if (e.h && "undefined" != typeof r && (!e.v[1] || 4 != Ht(e) || 2 != e.Z())) if (e.u && 4 == Ht(e)) se(e.Ea, 0, e); else if (re(e, "readystatechange"), 4 == Ht(e)) { e.h = !1; try { const r = e.Z(); e: switch (r) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var t = !0; break e; default: t = !1 }var n; if (!(n = t)) { var s; if (s = 0 === r) { var o = String(e.D).match(it)[1] || null; !o && i.self && i.self.location && (o = i.self.location.protocol.slice(0, -1)), s = !Lt.test(o ? o.toLowerCase() : "") } n = s } if (n) re(e, "complete"), re(e, "success"); else { e.m = 6; try { var a = 2 < Ht(e) ? e.g.statusText : "" } catch (l) { a = "" } e.l = a + " [" + e.Z() + "]", Bt(e) } } finally { zt(e) } } } function zt(e, t) { if (e.g) { qt(e); const n = e.g, r = e.v[0] ? () => { } : null; e.g = null, e.v = null, t || re(e, "ready"); try { n.onreadystatechange = r } catch (sI) { } } } function qt(e) { e.I && (i.clearTimeout(e.I), e.I = null) } function Ht(e) { return e.g ? e.g.readyState : 0 } function Wt(e) { try { if (!e.g) return null; if ("response" in e.g) return e.g.response; switch (e.H) { case "": case "text": return e.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in e.g) return e.g.mozResponseArrayBuffer }return null } catch (NE) { return null } } function Kt(e, t, n) { return n && n.internalChannelParams && n.internalChannelParams[e] || t } function Gt(e) { this.Aa = 0, this.i = [], this.j = new je, this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null, this.Ya = this.U = 0, this.Va = Kt("failFast", !1, e), this.F = this.C = this.u = this.s = this.l = null, this.X = !0, this.za = this.T = -1, this.Y = this.v = this.B = 0, this.Ta = Kt("baseRetryDelayMs", 5e3, e), this.cb = Kt("retryDelaySeedMs", 1e4, e), this.Wa = Kt("forwardChannelMaxRetries", 2, e), this.wa = Kt("forwardChannelRequestTimeoutMs", 2e4, e), this.pa = e && e.xmlHttpFactory || void 0, this.Xa = e && e.Tb || void 0, this.Ca = e && e.useFetchStreams || !1, this.L = void 0, this.J = e && e.supportsCrossDomainXhr || !1, this.K = "", this.h = new Je(e && e.concurrentRequestLimit), this.Da = new At, this.P = e && e.fastHandshake || !1, this.O = e && e.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.Ua = e && e.Rb || !1, e && e.xa && this.j.xa(), e && e.forceLongPolling && (this.X = !1), this.ba = !this.P && this.X && e && e.detectBufferingProxy || !1, this.ja = void 0, e && e.longPollingTimeout && 0 < e.longPollingTimeout && (this.ja = e.longPollingTimeout), this.ca = void 0, this.R = 0, this.M = !1, this.ka = this.A = null } function Qt(e) { if (Jt(e), 3 == e.G) { var t = e.U++, n = ot(e.I); if (ut(n, "SID", e.K), ut(n, "RID", t), ut(n, "TYPE", "terminate"), $t(e, n), (t = new _e(e, e.j, t)).L = 2, t.v = dt(ot(n)), n = !1, i.navigator && i.navigator.sendBeacon) try { n = i.navigator.sendBeacon(t.v.toString(), "") } catch (r) { } !n && i.Image && ((new Image).src = t.v, n = !0), n || (t.g = hn(t.j, null), t.g.ea(t.v)), t.F = Date.now(), qe(t) } un(e) } function Yt(e) { e.g && (rn(e), e.g.cancel(), e.g = null) } function Jt(e) { Yt(e), e.u && (i.clearTimeout(e.u), e.u = null), on(e), e.h.cancel(), e.s && ("number" === typeof e.s && i.clearTimeout(e.s), e.s = null) } function Xt(e) { if (!Xe(e.h) && !e.s) { e.s = !0; var t = e.Ga; A || P(), k || (A(), k = !0), j.add(t, e), e.B = 0 } } function Zt(e, t) { var n; n = t ? t.l : e.U++; const r = ot(e.I); ut(r, "SID", e.K), ut(r, "RID", n), ut(r, "AID", e.T), $t(e, r), e.m && e.o && _t(r, e.m, e.o), n = new _e(e, e.j, n, e.B + 1), null === e.m && (n.H = e.o), t && (e.i = t.D.concat(e.i)), t = en(e, n, 1e3), n.I = Math.round(.5 * e.wa) + Math.round(.5 * e.wa * Math.random()), et(e.h, n), Ue(n, r, t) } function $t(e, t) { e.H && y(e.H, (function (e, n) { ut(t, n, e) })), e.l && rt({}, (function (e, n) { ut(t, n, e) })) } function en(e, t, n) { n = Math.min(e.i.length, n); var r = e.l ? c(e.l.Na, e.l, e) : null; e: { var i = e.i; let t = -1; for (; ;) { const e = ["count=" + n]; -1 == t ? 0 < n ? (t = i[0].g, e.push("ofs=" + t)) : t = 0 : e.push("ofs=" + t); let o = !0; for (let a = 0; a < n; a++) { let n = i[a].g; const l = i[a].map; if (n -= t, 0 > n) t = Math.max(0, i[a].g - 100), o = !1; else try { kt(l, e, "req" + n + "_") } catch (s) { r && r(l) } } if (o) { r = e.join("&"); break e } } } return e = e.i.splice(0, n), t.D = e, r } function tn(e) { if (!e.g && !e.u) { e.Y = 1; var t = e.Fa; A || P(), k || (A(), k = !0), j.add(t, e), e.v = 0 } } function nn(e) { return !(e.g || e.u || 3 <= e.v) && (e.Y++, e.u = ke(c(e.Fa, e), ln(e, e.v)), e.v++, !0) } function rn(e) { null != e.A && (i.clearTimeout(e.A), e.A = null) } function sn(e) { e.g = new _e(e, e.j, "rpc", e.Y), null === e.m && (e.g.H = e.o), e.g.O = 0; var t = ot(e.qa); ut(t, "RID", "rpc"), ut(t, "SID", e.K), ut(t, "AID", e.T), ut(t, "CI", e.F ? "0" : "1"), !e.F && e.ja && ut(t, "TO", e.ja), ut(t, "TYPE", "xmlhttp"), $t(e, t), e.m && e.o && _t(t, e.m, e.o), e.L && (e.g.I = e.L); var n = e.g; e = e.ia, n.L = 1, n.v = dt(ot(t)), n.m = null, n.P = !0, Be(n, e) } function on(e) { null != e.C && (i.clearTimeout(e.C), e.C = null) } function an(e, t) { var n = null; if (e.g == t) { on(e), rn(e), e.g = null; var r = 2 } else { if (!$e(e.h, t)) return; n = t.D, tt(e.h, t), r = 1 } if (0 != e.G) if (t.o) if (1 == r) { n = t.m ? t.m.length : 0, t = Date.now() - t.F; var i = e.B; re(r = Ee(), new Ae(r, n)), Xt(e) } else tn(e); else if (3 == (i = t.s) || 0 == i && 0 < t.X || !(1 == r && function (e, t) { return !(Ze(e.h) >= e.h.j - (e.s ? 1 : 0)) && (e.s ? (e.i = t.D.concat(e.i), !0) : !(1 == e.G || 2 == e.G || e.B >= (e.Va ? 0 : e.Wa)) && (e.s = ke(c(e.Ga, e, t), ln(e, e.B)), e.B++, !0)) }(e, t) || 2 == r && nn(e))) switch (n && 0 < n.length && (t = e.h, t.i = t.i.concat(n)), i) { case 1: cn(e, 5); break; case 4: cn(e, 10); break; case 3: cn(e, 6); break; default: cn(e, 2) } } function ln(e, t) { let n = e.Ta + Math.floor(Math.random() * e.cb); return e.isActive() || (n *= 2), n * t } function cn(e, t) { if (e.j.info("Error code " + t), 2 == t) { var n = c(e.fb, e), r = e.Xa; const t = !r; r = new st(r || "//www.google.com/images/cleardot.gif"), i.location && "http" == i.location.protocol || at(r, "https"), dt(r), t ? function (e, t) { const n = new je; if (i.Image) { const r = new Image; r.onload = u(Tt, n, "TestLoadImage: loaded", !0, t, r), r.onerror = u(Tt, n, "TestLoadImage: error", !1, t, r), r.onabort = u(Tt, n, "TestLoadImage: abort", !1, t, r), r.ontimeout = u(Tt, n, "TestLoadImage: timeout", !1, t, r), i.setTimeout((function () { r.ontimeout && r.ontimeout() }), 1e4), r.src = e } else t(!1) }(r.toString(), n) : function (e, t) { new je; const n = new AbortController, r = setTimeout((() => { n.abort(), Tt(0, 0, !1, t) }), 1e4); fetch(e, { signal: n.signal }).then((e => { clearTimeout(r), e.ok ? Tt(0, 0, !0, t) : Tt(0, 0, !1, t) })).catch((() => { clearTimeout(r), Tt(0, 0, !1, t) })) }(r.toString(), n) } else Te(2); e.G = 0, e.l && e.l.sa(t), un(e), Jt(e) } function un(e) { if (e.G = 0, e.ka = [], e.l) { const t = nt(e.h); 0 == t.length && 0 == e.i.length || (f(e.ka, t), f(e.ka, e.i), e.h.i.length = 0, h(e.i), e.i.length = 0), e.l.ra() } } function dn(e, t, n) { var r = n instanceof st ? ot(n) : new st(n); if ("" != r.g) t && (r.g = t + "." + r.g), lt(r, r.s); else { var s = i.location; r = s.protocol, t = t ? t + "." + s.hostname : s.hostname, s = +s.port; var o = new st(null); r && at(o, r), t && (o.g = t), s && lt(o, s), n && (o.l = n), r = o } return n = e.D, t = e.ya, n && t && ut(r, n, t), ut(r, "VER", e.la), $t(e, r), r } function hn(e, t, n) { if (t && !e.J) throw Error("Can't create secondary domain capable XhrIo object."); return (t = e.Ca && !e.pa ? new Mt(new jt({ eb: n })) : new Mt(e.pa)).Ha(e.J), t } function fn() { } function pn() { } function mn(e, t) { ne.call(this), this.g = new Gt(t), this.l = e, this.h = t && t.messageUrlParams || null, e = t && t.messageHeaders || null, t && t.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = { "X-Client-Protocol": "webchannel" }), this.g.o = e, e = t && t.initMessageHeaders || null, t && t.messageContentType && (e ? e["X-WebChannel-Content-Type"] = t.messageContentType : e = { "X-WebChannel-Content-Type": t.messageContentType }), t && t.va && (e ? e["X-WebChannel-Client-Profile"] = t.va : e = { "X-WebChannel-Client-Profile": t.va }), this.g.S = e, (e = t && t.Sb) && !p(e) && (this.g.m = e), this.v = t && t.supportsCrossDomainXhr || !1, this.u = t && t.sendRawJson || !1, (t = t && t.httpSessionIdParam) && !p(t) && (this.g.D = t, null !== (e = this.h) && t in e && (t in (e = this.h) && delete e[t])), this.j = new yn(this) } function gn(e) { ye.call(this), e.__headers__ && (this.headers = e.__headers__, this.statusCode = e.__status__, delete e.__headers__, delete e.__status__); var t = e.__sm__; if (t) { e: { for (const n in t) { e = n; break e } e = void 0 } (this.i = e) && (e = this.i, t = null !== t && e in t ? t[e] : void 0), this.data = t } else this.data = e } function vn() { be.call(this), this.status = 1 } function yn(e) { this.g = e } (e = Mt.prototype).Ha = function (e) { this.J = e }, e.ea = function (e, t, n, r) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + e); t = t ? t.toUpperCase() : "GET", this.D = e, this.l = "", this.m = 0, this.A = !1, this.h = !0, this.g = this.o ? this.o.g() : Ie.g(), this.v = this.o ? me(this.o) : me(Ie), this.g.onreadystatechange = c(this.Ea, this); try { this.B = !0, this.g.open(t, String(e), !0), this.B = !1 } catch (o) { return void Ut(this, o) } if (e = n || "", n = new Map(this.headers), r) if (Object.getPrototypeOf(r) === Object.prototype) for (var s in r) n.set(s, r[s]); else { if ("function" !== typeof r.keys || "function" !== typeof r.get) throw Error("Unknown input type for opt_headers: " + String(r)); for (const e of r.keys()) n.set(e, r.get(e)) } r = Array.from(n.keys()).find((e => "content-type" == e.toLowerCase())), s = i.FormData && e instanceof i.FormData, !(0 <= Array.prototype.indexOf.call(Ft, t, void 0)) || r || s || n.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [i, a] of n) this.g.setRequestHeader(i, a); this.H && (this.g.responseType = this.H), "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J); try { qt(this), this.u = !0, this.g.send(e), this.u = !1 } catch (o) { Ut(this, o) } }, e.abort = function (e) { this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.m = e || 7, re(this, "complete"), re(this, "abort"), zt(this)) }, e.N = function () { this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), zt(this, !0)), Mt.aa.N.call(this) }, e.Ea = function () { this.s || (this.B || this.u || this.j ? Vt(this) : this.bb()) }, e.bb = function () { Vt(this) }, e.isActive = function () { return !!this.g }, e.Z = function () { try { return 2 < Ht(this) ? this.g.status : -1 } catch (SP) { return -1 } }, e.oa = function () { try { return this.g ? this.g.responseText : "" } catch (SP) { return "" } }, e.Oa = function (e) { if (this.g) { var t = this.g.responseText; return e && 0 == t.indexOf(e) && (t = t.substring(e.length)), he(t) } }, e.Ba = function () { return this.m }, e.Ka = function () { return "string" === typeof this.l ? this.l : String(this.l) }, (e = Gt.prototype).la = 8, e.G = 1, e.connect = function (e, t, n, r) { Te(0), this.W = e, this.H = t || {}, n && void 0 !== r && (this.H.OSID = n, this.H.OAID = r), this.F = this.X, this.I = dn(this, null, this.W), Xt(this) }, e.Ga = function (e) { if (this.s) if (this.s = null, 1 == this.G) { if (!e) { this.U = Math.floor(1e5 * Math.random()), e = this.U++; const i = new _e(this, this.j, e); let s = this.o; if (this.S && (s ? (s = b(s), x(s, this.S)) : s = this.S), null !== this.m || this.O || (i.H = s, s = null), this.P) e: { for (var t = 0, n = 0; n < this.i.length; n++) { var r = this.i[n]; if (void 0 === (r = "__data__" in r.map && "string" === typeof (r = r.map.__data__) ? r.length : void 0)) break; if (4096 < (t += r)) { t = n; break e } if (4096 === t || n === this.i.length - 1) { t = n + 1; break e } } t = 1e3 } else t = 1e3; t = en(this, i, t), ut(n = ot(this.I), "RID", e), ut(n, "CVER", 22), this.D && ut(n, "X-HTTP-Session-Id", this.D), $t(this, n), s && (this.O ? t = "headers=" + encodeURIComponent(String(Dt(s))) + "&" + t : this.m && _t(n, this.m, s)), et(this.h, i), this.Ua && ut(n, "TYPE", "init"), this.P ? (ut(n, "$req", t), ut(n, "SID", "null"), i.T = !0, Ue(i, n, null)) : Ue(i, n, t), this.G = 2 } } else 3 == this.G && (e ? Zt(this, e) : 0 == this.i.length || Xe(this.h) || Zt(this)) }, e.Fa = function () { if (this.u = null, sn(this), this.ba && !(this.M || null == this.g || 0 >= this.R)) { var e = 2 * this.R; this.j.info("BP detection timer enabled: " + e), this.A = ke(c(this.ab, this), e) } }, e.ab = function () { this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.M = !0, Te(10), Yt(this), sn(this)) }, e.Za = function () { null != this.C && (this.C = null, Yt(this), nn(this), Te(19)) }, e.fb = function (e) { e ? (this.j.info("Successfully pinged google.com"), Te(2)) : (this.j.info("Failed to ping google.com"), Te(1)) }, e.isActive = function () { return !!this.l && this.l.isActive(this) }, (e = fn.prototype).ua = function () { }, e.ta = function () { }, e.sa = function () { }, e.ra = function () { }, e.isActive = function () { return !0 }, e.Na = function () { }, pn.prototype.g = function (e, t) { return new mn(e, t) }, d(mn, ne), mn.prototype.m = function () { this.g.l = this.j, this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0) }, mn.prototype.close = function () { Qt(this.g) }, mn.prototype.o = function (e) { var t = this.g; if ("string" === typeof e) { var n = {}; n.__data__ = e, e = n } else this.u && ((n = {}).__data__ = de(e), e = n); t.i.push(new Ye(t.Ya++, e)), 3 == t.G && Xt(t) }, mn.prototype.N = function () { this.g.l = null, delete this.j, Qt(this.g), delete this.g, mn.aa.N.call(this) }, d(gn, ye), d(vn, be), d(yn, fn), yn.prototype.ua = function () { re(this.g, "a") }, yn.prototype.ta = function (e) { re(this.g, new gn(e)) }, yn.prototype.sa = function (e) { re(this.g, new vn) }, yn.prototype.ra = function () { re(this.g, "b") }, pn.prototype.createWebChannel = pn.prototype.g, mn.prototype.send = mn.prototype.o, mn.prototype.open = mn.prototype.m, mn.prototype.close = mn.prototype.close, bE = xE.createWebChannelTransport = function () { return new pn }, yE = xE.getStatEventTarget = function () { return Ee() }, vE = xE.Event = we, gE = xE.Stat = { mb: 0, pb: 1, qb: 2, Jb: 3, Ob: 4, Lb: 5, Mb: 6, Kb: 7, Ib: 8, Nb: 9, PROXY: 10, NOPROXY: 11, Gb: 12, Cb: 13, Db: 14, Bb: 15, Eb: 16, Fb: 17, ib: 18, hb: 19, jb: 20 }, Re.NO_ERROR = 0, Re.TIMEOUT = 8, Re.HTTP_ERROR = 6, mE = xE.ErrorCode = Re, Oe.COMPLETE = "complete", pE = xE.EventType = Oe, ge.EventType = ve, ve.OPEN = "a", ve.CLOSE = "b", ve.ERROR = "c", ve.MESSAGE = "d", ne.prototype.listen = ne.prototype.K, fE = xE.WebChannel = ge, hE = xE.FetchXmlHttpFactory = jt, Mt.prototype.listenOnce = Mt.prototype.L, Mt.prototype.getLastError = Mt.prototype.Ka, Mt.prototype.getLastErrorCode = Mt.prototype.Ba, Mt.prototype.getStatus = Mt.prototype.Z, Mt.prototype.getResponseJson = Mt.prototype.Oa, Mt.prototype.getResponseText = Mt.prototype.oa, Mt.prototype.send = Mt.prototype.ea, Mt.prototype.setWithCredentials = Mt.prototype.Ha, dE = xE.XhrIo = Mt }).apply("undefined" !== typeof wE ? wE : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {}); const EE = "@firebase/firestore"; class SE { constructor(e) { this.uid = e } isAuthenticated() { return null != this.uid } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(e) { return e.uid === this.uid } } SE.UNAUTHENTICATED = new SE(null), SE.GOOGLE_CREDENTIALS = new SE("google-credentials-uid"), SE.FIRST_PARTY = new SE("first-party-uid"), SE.MOCK_USER = new SE("mock-user"); let NE = "10.12.3"; const CE = new Jv("@firebase/firestore"); function TE() { return CE.logLevel } function AE(e) { if (CE.logLevel <= Wv.DEBUG) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(PE); CE.debug("Firestore (".concat(NE, "): ").concat(e), ...i) } } function kE(e) { if (CE.logLevel <= Wv.ERROR) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(PE); CE.error("Firestore (".concat(NE, "): ").concat(e), ...i) } } function jE(e) { if (CE.logLevel <= Wv.WARN) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(PE); CE.warn("Firestore (".concat(NE, "): ").concat(e), ...i) } } function PE(e) { if ("string" == typeof e) return e; try { return function (e) { return JSON.stringify(e) }(e) } catch (t) { return e } } function IE() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Unexpected state"; const t = "FIRESTORE (".concat(NE, ") INTERNAL ASSERTION FAILED: ") + e; throw kE(t), new Error(t) } function RE(e, t) { e || IE() } function OE(e, t) { return e } const DE = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class _E extends jv { constructor(e, t) { super(e, t), this.code = e, this.message = t, this.toString = () => "".concat(this.name, ": [code=").concat(this.code, "]: ").concat(this.message) } } class ME { constructor() { this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } } class LE { constructor(e, t) { this.user = t, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", "Bearer ".concat(e)) } } class FE { getToken() { return Promise.resolve(null) } invalidateToken() { } start(e, t) { e.enqueueRetryable((() => t(SE.UNAUTHENTICATED))) } shutdown() { } } class UE { constructor(e) { this.token = e, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(e, t) { this.changeListener = t, e.enqueueRetryable((() => t(this.token.user))) } shutdown() { this.changeListener = null } } class BE { constructor(e) { this.t = e, this.currentUser = SE.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(e, t) { let n = this.i; const r = e => this.i !== n ? (n = this.i, t(e)) : Promise.resolve(); let i = new ME; this.o = () => { this.i++, this.currentUser = this.u(), i.resolve(), i = new ME, e.enqueueRetryable((() => r(this.currentUser))) }; const s = () => { const t = i; e.enqueueRetryable((async () => { await t.promise, await r(this.currentUser) })) }, o = e => { AE("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = e, this.auth.addAuthTokenListener(this.o), s() }; this.t.onInit((e => o(e))), setTimeout((() => { if (!this.auth) { const e = this.t.getImmediate({ optional: !0 }); e ? o(e) : (AE("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new ME) } }), 0), s() } getToken() { const e = this.i, t = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then((t => this.i !== e ? (AE("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : t ? (RE("string" == typeof t.accessToken), new LE(t.accessToken, this.currentUser)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const e = this.auth && this.auth.getUid(); return RE(null === e || "string" == typeof e), new SE(e) } } class VE { constructor(e, t, n) { this.l = e, this.h = t, this.P = n, this.type = "FirstParty", this.user = SE.FIRST_PARTY, this.I = new Map } T() { return this.P ? this.P() : null } get headers() { this.I.set("X-Goog-AuthUser", this.l); const e = this.T(); return e && this.I.set("Authorization", e), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I } } class zE { constructor(e, t, n) { this.l = e, this.h = t, this.P = n } getToken() { return Promise.resolve(new VE(this.l, this.h, this.P)) } start(e, t) { e.enqueueRetryable((() => t(SE.FIRST_PARTY))) } shutdown() { } invalidateToken() { } } class qE { constructor(e) { this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class HE { constructor(e) { this.A = e, this.forceRefresh = !1, this.appCheck = null, this.R = null } start(e, t) { const n = e => { null != e.error && AE("FirebaseAppCheckTokenProvider", "Error getting App Check token; using placeholder token instead. Error: ".concat(e.error.message)); const n = e.token !== this.R; return this.R = e.token, AE("FirebaseAppCheckTokenProvider", "Received ".concat(n ? "new" : "existing", " token.")), n ? t(e.token) : Promise.resolve() }; this.o = t => { e.enqueueRetryable((() => n(t))) }; const r = e => { AE("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = e, this.appCheck.addTokenListener(this.o) }; this.A.onInit((e => r(e))), setTimeout((() => { if (!this.appCheck) { const e = this.A.getImmediate({ optional: !0 }); e ? r(e) : AE("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }), 0) } getToken() { const e = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then((e => e ? (RE("string" == typeof e.token), this.R = e.token, new qE(e.token)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } } function WE(e) { const t = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(e); if (t && "function" == typeof t.getRandomValues) t.getRandomValues(n); else for (let r = 0; r < e; r++)n[r] = Math.floor(256 * Math.random()); return n } class KE { static newId() { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = 62 * Math.floor(256 / 62); let n = ""; for (; n.length < 20;) { const r = WE(40); for (let i = 0; i < r.length; ++i)n.length < 20 && r[i] < t && (n += e.charAt(r[i] % 62)) } return n } } function GE(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function QE(e, t, n) { return e.length === t.length && e.every(((e, r) => n(e, t[r]))) } class YE { constructor(e, t) { if (this.seconds = e, this.nanoseconds = t, t < 0) throw new _E(DE.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (t >= 1e9) throw new _E(DE.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (e < -62135596800) throw new _E(DE.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e); if (e >= 253402300800) throw new _E(DE.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e) } static now() { return YE.fromMillis(Date.now()) } static fromDate(e) { return YE.fromMillis(e.getTime()) } static fromMillis(e) { const t = Math.floor(e / 1e3), n = Math.floor(1e6 * (e - 1e3 * t)); return new YE(t, n) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(e) { return this.seconds === e.seconds ? GE(this.nanoseconds, e.nanoseconds) : GE(this.seconds, e.seconds) } isEqual(e) { return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { const e = this.seconds - -62135596800; return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } class JE { constructor(e) { this.timestamp = e } static fromTimestamp(e) { return new JE(e) } static min() { return new JE(new YE(0, 0)) } static max() { return new JE(new YE(253402300799, 999999999)) } compareTo(e) { return this.timestamp._compareTo(e.timestamp) } isEqual(e) { return this.timestamp.isEqual(e.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } class XE { constructor(e, t, n) { void 0 === t ? t = 0 : t > e.length && IE(), void 0 === n ? n = e.length - t : n > e.length - t && IE(), this.segments = e, this.offset = t, this.len = n } get length() { return this.len } isEqual(e) { return 0 === XE.comparator(this, e) } child(e) { const t = this.segments.slice(this.offset, this.limit()); return e instanceof XE ? e.forEach((e => { t.push(e) })) : t.push(e), this.construct(t) } limit() { return this.offset + this.length } popFirst(e) { return e = void 0 === e ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(e) { return this.segments[this.offset + e] } isEmpty() { return 0 === this.length } isPrefixOf(e) { if (e.length < this.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } isImmediateParentOf(e) { if (this.length + 1 !== e.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } forEach(e) { for (let t = this.offset, n = this.limit(); t < n; t++)e(this.segments[t]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(e, t) { const n = Math.min(e.length, t.length); for (let r = 0; r < n; r++) { const n = e.get(r), i = t.get(r); if (n < i) return -1; if (n > i) return 1 } return e.length < t.length ? -1 : e.length > t.length ? 1 : 0 } } class ZE extends XE { construct(e, t, n) { return new ZE(e, t, n) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } toUriEncodedString() { return this.toArray().map(encodeURIComponent).join("/") } static fromString() { const e = []; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) { if (i.indexOf("//") >= 0) throw new _E(DE.INVALID_ARGUMENT, "Invalid segment (".concat(i, "). Paths must not contain // in them.")); e.push(...i.split("/").filter((e => e.length > 0))) } return new ZE(e) } static emptyPath() { return new ZE([]) } } const $E = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class eS extends XE { construct(e, t, n) { return new eS(e, t, n) } static isValidIdentifier(e) { return $E.test(e) } canonicalString() { return this.toArray().map((e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), eS.isValidIdentifier(e) || (e = "`" + e + "`"), e))).join(".") } toString() { return this.canonicalString() } isKeyField() { return 1 === this.length && "__name__" === this.get(0) } static keyField() { return new eS(["__name__"]) } static fromServerFormat(e) { const t = []; let n = "", r = 0; const i = () => { if (0 === n.length) throw new _E(DE.INVALID_ARGUMENT, "Invalid field path (".concat(e, "). Paths must not be empty, begin with '.', end with '.', or contain '..'")); t.push(n), n = "" }; let s = !1; for (; r < e.length;) { const t = e[r]; if ("\\" === t) { if (r + 1 === e.length) throw new _E(DE.INVALID_ARGUMENT, "Path has trailing escape character: " + e); const t = e[r + 1]; if ("\\" !== t && "." !== t && "`" !== t) throw new _E(DE.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e); n += t, r += 2 } else "`" === t ? (s = !s, r++) : "." !== t || s ? (n += t, r++) : (i(), r++) } if (i(), s) throw new _E(DE.INVALID_ARGUMENT, "Unterminated ` in path: " + e); return new eS(t) } static emptyPath() { return new eS([]) } } class tS { constructor(e) { this.path = e } static fromPath(e) { return new tS(ZE.fromString(e)) } static fromName(e) { return new tS(ZE.fromString(e).popFirst(5)) } static empty() { return new tS(ZE.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(e) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === e } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(e) { return null !== e && 0 === ZE.comparator(this.path, e.path) } toString() { return this.path.toString() } static comparator(e, t) { return ZE.comparator(e.path, t.path) } static isDocumentKey(e) { return e.length % 2 == 0 } static fromSegments(e) { return new tS(new ZE(e.slice())) } } class nS { constructor(e, t, n, r) { this.indexId = e, this.collectionGroup = t, this.fields = n, this.indexState = r } } nS.UNKNOWN_ID = -1; function rS(e, t) { const n = e.toTimestamp().seconds, r = e.toTimestamp().nanoseconds + 1, i = JE.fromTimestamp(1e9 === r ? new YE(n + 1, 0) : new YE(n, r)); return new sS(i, tS.empty(), t) } function iS(e) { return new sS(e.readTime, e.key, -1) } class sS { constructor(e, t, n) { this.readTime = e, this.documentKey = t, this.largestBatchId = n } static min() { return new sS(JE.min(), tS.empty(), -1) } static max() { return new sS(JE.max(), tS.empty(), -1) } } function oS(e, t) { let n = e.readTime.compareTo(t.readTime); return 0 !== n ? n : (n = tS.comparator(e.documentKey, t.documentKey), 0 !== n ? n : GE(e.largestBatchId, t.largestBatchId)) } const aS = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class lS { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(e) { this.onCommittedListeners.push(e) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach((e => e())) } } async function cS(e) { if (e.code !== DE.FAILED_PRECONDITION || e.message !== aS) throw e; AE("LocalStore", "Unexpectedly lost primary lease") } class uS { constructor(e) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e((e => { this.isDone = !0, this.result = e, this.nextCallback && this.nextCallback(e) }), (e => { this.isDone = !0, this.error = e, this.catchCallback && this.catchCallback(e) })) } catch(e) { return this.next(void 0, e) } next(e, t) { return this.callbackAttached && IE(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new uS(((n, r) => { this.nextCallback = t => { this.wrapSuccess(e, t).next(n, r) }, this.catchCallback = e => { this.wrapFailure(t, e).next(n, r) } })) } toPromise() { return new Promise(((e, t) => { this.next(e, t) })) } wrapUserFunction(e) { try { const t = e(); return t instanceof uS ? t : uS.resolve(t) } catch (e) { return uS.reject(e) } } wrapSuccess(e, t) { return e ? this.wrapUserFunction((() => e(t))) : uS.resolve(t) } wrapFailure(e, t) { return e ? this.wrapUserFunction((() => e(t))) : uS.reject(t) } static resolve(e) { return new uS(((t, n) => { t(e) })) } static reject(e) { return new uS(((t, n) => { n(e) })) } static waitFor(e) { return new uS(((t, n) => { let r = 0, i = 0, s = !1; e.forEach((e => { ++r, e.next((() => { ++i, s && i === r && t() }), (e => n(e))) })), s = !0, i === r && t() })) } static or(e) { let t = uS.resolve(!1); for (const n of e) t = t.next((e => e ? uS.resolve(e) : n())); return t } static forEach(e, t) { const n = []; return e.forEach(((e, r) => { n.push(t.call(this, e, r)) })), this.waitFor(n) } static mapArray(e, t) { return new uS(((n, r) => { const i = e.length, s = new Array(i); let o = 0; for (let a = 0; a < i; a++) { const l = a; t(e[l]).next((e => { s[l] = e, ++o, o === i && n(s) }), (e => r(e))) } })) } static doWhile(e, t) { return new uS(((n, r) => { const i = () => { !0 === e() ? t().next((() => { i() }), r) : n() }; i() })) } } function dS(e) { const t = e.match(/Android ([\d.]+)/i), n = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(n) } function hS(e) { return "IndexedDbTransactionError" === e.name } class fS { constructor(e, t) { this.previousValue = e, t && (t.sequenceNumberHandler = e => this.ie(e), this.se = e => t.writeSequenceNumber(e)) } ie(e) { return this.previousValue = Math.max(e, this.previousValue), this.previousValue } next() { const e = ++this.previousValue; return this.se && this.se(e), e } } function pS(e) { return null == e } function mS(e) { return 0 === e && 1 / e == -1 / 0 } function gS(e) { return "number" == typeof e && Number.isInteger(e) && !mS(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER } fS.oe = -1; const vS = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"], yS = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"], bS = yS; function wS(e) { let t = 0; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++; return t } function xS(e, t) { for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n]) } function ES(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } class SS { constructor(e, t) { this.comparator = e, this.root = t || CS.EMPTY } insert(e, t) { return new SS(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, CS.BLACK, null, null)) } remove(e) { return new SS(this.comparator, this.root.remove(e, this.comparator).copy(null, null, CS.BLACK, null, null)) } get(e) { let t = this.root; for (; !t.isEmpty();) { const n = this.comparator(e, t.key); if (0 === n) return t.value; n < 0 ? t = t.left : n > 0 && (t = t.right) } return null } indexOf(e) { let t = 0, n = this.root; for (; !n.isEmpty();) { const r = this.comparator(e, n.key); if (0 === r) return t + n.left.size; r < 0 ? n = n.left : (t += n.left.size + 1, n = n.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(e) { return this.root.inorderTraversal(e) } forEach(e) { this.inorderTraversal(((t, n) => (e(t, n), !1))) } toString() { const e = []; return this.inorderTraversal(((t, n) => (e.push("".concat(t, ":").concat(n)), !1))), "{".concat(e.join(", "), "}") } reverseTraversal(e) { return this.root.reverseTraversal(e) } getIterator() { return new NS(this.root, null, this.comparator, !1) } getIteratorFrom(e) { return new NS(this.root, e, this.comparator, !1) } getReverseIterator() { return new NS(this.root, null, this.comparator, !0) } getReverseIteratorFrom(e) { return new NS(this.root, e, this.comparator, !0) } } class NS { constructor(e, t, n, r) { this.isReverse = r, this.nodeStack = []; let i = 1; for (; !e.isEmpty();)if (i = t ? n(e.key, t) : 1, t && r && (i *= -1), i < 0) e = this.isReverse ? e.left : e.right; else { if (0 === i) { this.nodeStack.push(e); break } this.nodeStack.push(e), e = this.isReverse ? e.right : e.left } } getNext() { let e = this.nodeStack.pop(); const t = { key: e.key, value: e.value }; if (this.isReverse) for (e = e.left; !e.isEmpty();)this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack.push(e), e = e.left; return t } hasNext() { return this.nodeStack.length > 0 } peek() { if (0 === this.nodeStack.length) return null; const e = this.nodeStack[this.nodeStack.length - 1]; return { key: e.key, value: e.value } } } class CS { constructor(e, t, n, r, i) { this.key = e, this.value = t, this.color = null != n ? n : CS.RED, this.left = null != r ? r : CS.EMPTY, this.right = null != i ? i : CS.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(e, t, n, r, i) { return new CS(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right) } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, n) { let r = this; const i = n(e, r.key); return r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)), r.fixUp() } removeMin() { if (this.left.isEmpty()) return CS.EMPTY; let e = this; return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp() } remove(e, t) { let n, r = this; if (t(e, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(e, t), null); else { if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === t(e, r.key)) { if (r.right.isEmpty()) return CS.EMPTY; n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin()) } r = r.copy(null, null, null, null, r.right.remove(e, t)) } return r.fixUp() } isRed() { return this.color } fixUp() { let e = this; return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e } moveRedLeft() { let e = this.colorFlip(); return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e } moveRedRight() { let e = this.colorFlip(); return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e } rotateLeft() { const e = this.copy(null, null, CS.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight() { const e = this.copy(null, null, CS.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip() { const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth() { const e = this.check(); return Math.pow(2, e) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed()) throw IE(); if (this.right.isRed()) throw IE(); const e = this.left.check(); if (e !== this.right.check()) throw IE(); return e + (this.isRed() ? 0 : 1) } } CS.EMPTY = null, CS.RED = !0, CS.BLACK = !1, CS.EMPTY = new class { constructor() { this.size = 0 } get key() { throw IE() } get value() { throw IE() } get color() { throw IE() } get left() { throw IE() } get right() { throw IE() } copy(e, t, n, r, i) { return this } insert(e, t, n) { return new CS(e, t) } remove(e, t) { return this } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class TS { constructor(e) { this.comparator = e, this.data = new SS(this.comparator) } has(e) { return null !== this.data.get(e) } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(e) { return this.data.indexOf(e) } forEach(e) { this.data.inorderTraversal(((t, n) => (e(t), !1))) } forEachInRange(e, t) { const n = this.data.getIteratorFrom(e[0]); for (; n.hasNext();) { const r = n.getNext(); if (this.comparator(r.key, e[1]) >= 0) return; t(r.key) } } forEachWhile(e, t) { let n; for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext();)if (!e(n.getNext().key)) return } firstAfterOrEqual(e) { const t = this.data.getIteratorFrom(e); return t.hasNext() ? t.getNext().key : null } getIterator() { return new AS(this.data.getIterator()) } getIteratorFrom(e) { return new AS(this.data.getIteratorFrom(e)) } add(e) { return this.copy(this.data.remove(e).insert(e, !0)) } delete(e) { return this.has(e) ? this.copy(this.data.remove(e)) : this } isEmpty() { return this.data.isEmpty() } unionWith(e) { let t = this; return t.size < e.size && (t = e, e = this), e.forEach((e => { t = t.add(e) })), t } isEqual(e) { if (!(e instanceof TS)) return !1; if (this.size !== e.size) return !1; const t = this.data.getIterator(), n = e.data.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (0 !== this.comparator(e, r)) return !1 } return !0 } toArray() { const e = []; return this.forEach((t => { e.push(t) })), e } toString() { const e = []; return this.forEach((t => e.push(t))), "SortedSet(" + e.toString() + ")" } copy(e) { const t = new TS(this.comparator); return t.data = e, t } } class AS { constructor(e) { this.iter = e } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } class kS { constructor(e) { this.fields = e, e.sort(eS.comparator) } static empty() { return new kS([]) } unionWith(e) { let t = new TS(eS.comparator); for (const n of this.fields) t = t.add(n); for (const n of e) t = t.add(n); return new kS(t.toArray()) } covers(e) { for (const t of this.fields) if (t.isPrefixOf(e)) return !0; return !1 } isEqual(e) { return QE(this.fields, e.fields, ((e, t) => e.isEqual(t))) } } class jS extends Error { constructor() { super(...arguments), this.name = "Base64DecodeError" } } class PS { constructor(e) { this.binaryString = e } static fromBase64String(e) { const t = function (e) { try { return atob(e) } catch (e) { throw "undefined" != typeof DOMException && e instanceof DOMException ? new jS("Invalid base64 string: " + e) : e } }(e); return new PS(t) } static fromUint8Array(e) { const t = function (e) { let t = ""; for (let n = 0; n < e.length; ++n)t += String.fromCharCode(e[n]); return t }(e); return new PS(t) } [Symbol.iterator]() { let e = 0; return { next: () => e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return e = this.binaryString, btoa(e); var e } toUint8Array() { return function (e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(e) { return GE(this.binaryString, e.binaryString) } isEqual(e) { return this.binaryString === e.binaryString } } PS.EMPTY_BYTE_STRING = new PS(""); const IS = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function RS(e) { if (RE(!!e), "string" == typeof e) { let t = 0; const n = IS.exec(e); if (RE(!!n), n[1]) { let e = n[1]; e = (e + "000000000").substr(0, 9), t = Number(e) } const r = new Date(e); return { seconds: Math.floor(r.getTime() / 1e3), nanos: t } } return { seconds: OS(e.seconds), nanos: OS(e.nanos) } } function OS(e) { return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0 } function DS(e) { return "string" == typeof e ? PS.fromBase64String(e) : PS.fromUint8Array(e) } function _S(e) { var t, n; return "server_timestamp" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue) } function MS(e) { const t = e.mapValue.fields.__previous_value__; return _S(t) ? MS(t) : t } function LS(e) { const t = RS(e.mapValue.fields.__local_write_time__.timestampValue); return new YE(t.seconds, t.nanos) } class FS { constructor(e, t, n, r, i, s, o, a, l) { this.databaseId = e, this.appId = t, this.persistenceKey = n, this.host = r, this.ssl = i, this.forceLongPolling = s, this.autoDetectLongPolling = o, this.longPollingOptions = a, this.useFetchStreams = l } } class US { constructor(e, t) { this.projectId = e, this.database = t || "(default)" } static empty() { return new US("", "") } get isDefaultDatabase() { return "(default)" === this.database } isEqual(e) { return e instanceof US && e.projectId === this.projectId && e.database === this.database } } const BS = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }; function VS(e) { return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? _S(e) ? 4 : eN(e) ? 9007199254740991 : 10 : IE() } function zS(e, t) { if (e === t) return !0; const n = VS(e); if (n !== VS(t)) return !1; switch (n) { case 0: case 9007199254740991: return !0; case 1: return e.booleanValue === t.booleanValue; case 4: return LS(e).isEqual(LS(t)); case 3: return function (e, t) { if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length) return e.timestampValue === t.timestampValue; const n = RS(e.timestampValue), r = RS(t.timestampValue); return n.seconds === r.seconds && n.nanos === r.nanos }(e, t); case 5: return e.stringValue === t.stringValue; case 6: return function (e, t) { return DS(e.bytesValue).isEqual(DS(t.bytesValue)) }(e, t); case 7: return e.referenceValue === t.referenceValue; case 8: return function (e, t) { return OS(e.geoPointValue.latitude) === OS(t.geoPointValue.latitude) && OS(e.geoPointValue.longitude) === OS(t.geoPointValue.longitude) }(e, t); case 2: return function (e, t) { if ("integerValue" in e && "integerValue" in t) return OS(e.integerValue) === OS(t.integerValue); if ("doubleValue" in e && "doubleValue" in t) { const n = OS(e.doubleValue), r = OS(t.doubleValue); return n === r ? mS(n) === mS(r) : isNaN(n) && isNaN(r) } return !1 }(e, t); case 9: return QE(e.arrayValue.values || [], t.arrayValue.values || [], zS); case 10: return function (e, t) { const n = e.mapValue.fields || {}, r = t.mapValue.fields || {}; if (wS(n) !== wS(r)) return !1; for (const i in n) if (n.hasOwnProperty(i) && (void 0 === r[i] || !zS(n[i], r[i]))) return !1; return !0 }(e, t); default: return IE() } } function qS(e, t) { return void 0 !== (e.values || []).find((e => zS(e, t))) } function HS(e, t) { if (e === t) return 0; const n = VS(e), r = VS(t); if (n !== r) return GE(n, r); switch (n) { case 0: case 9007199254740991: return 0; case 1: return GE(e.booleanValue, t.booleanValue); case 2: return function (e, t) { const n = OS(e.integerValue || e.doubleValue), r = OS(t.integerValue || t.doubleValue); return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? isNaN(r) ? 0 : -1 : 1 }(e, t); case 3: return WS(e.timestampValue, t.timestampValue); case 4: return WS(LS(e), LS(t)); case 5: return GE(e.stringValue, t.stringValue); case 6: return function (e, t) { const n = DS(e), r = DS(t); return n.compareTo(r) }(e.bytesValue, t.bytesValue); case 7: return function (e, t) { const n = e.split("/"), r = t.split("/"); for (let i = 0; i < n.length && i < r.length; i++) { const e = GE(n[i], r[i]); if (0 !== e) return e } return GE(n.length, r.length) }(e.referenceValue, t.referenceValue); case 8: return function (e, t) { const n = GE(OS(e.latitude), OS(t.latitude)); return 0 !== n ? n : GE(OS(e.longitude), OS(t.longitude)) }(e.geoPointValue, t.geoPointValue); case 9: return function (e, t) { const n = e.values || [], r = t.values || []; for (let i = 0; i < n.length && i < r.length; ++i) { const e = HS(n[i], r[i]); if (e) return e } return GE(n.length, r.length) }(e.arrayValue, t.arrayValue); case 10: return function (e, t) { if (e === BS.mapValue && t === BS.mapValue) return 0; if (e === BS.mapValue) return 1; if (t === BS.mapValue) return -1; const n = e.fields || {}, r = Object.keys(n), i = t.fields || {}, s = Object.keys(i); r.sort(), s.sort(); for (let o = 0; o < r.length && o < s.length; ++o) { const e = GE(r[o], s[o]); if (0 !== e) return e; const t = HS(n[r[o]], i[s[o]]); if (0 !== t) return t } return GE(r.length, s.length) }(e.mapValue, t.mapValue); default: throw IE() } } function WS(e, t) { if ("string" == typeof e && "string" == typeof t && e.length === t.length) return GE(e, t); const n = RS(e), r = RS(t), i = GE(n.seconds, r.seconds); return 0 !== i ? i : GE(n.nanos, r.nanos) } function KS(e) { return GS(e) } function GS(e) { return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function (e) { const t = RS(e); return "time(".concat(t.seconds, ",").concat(t.nanos, ")") }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? function (e) { return DS(e).toBase64() }(e.bytesValue) : "referenceValue" in e ? function (e) { return tS.fromName(e).toString() }(e.referenceValue) : "geoPointValue" in e ? function (e) { return "geo(".concat(e.latitude, ",").concat(e.longitude, ")") }(e.geoPointValue) : "arrayValue" in e ? function (e) { let t = "[", n = !0; for (const r of e.values || []) n ? n = !1 : t += ",", t += GS(r); return t + "]" }(e.arrayValue) : "mapValue" in e ? function (e) { const t = Object.keys(e.fields || {}).sort(); let n = "{", r = !0; for (const i of t) r ? r = !1 : n += ",", n += "".concat(i, ":").concat(GS(e.fields[i])); return n + "}" }(e.mapValue) : IE() } function QS(e) { return !!e && "integerValue" in e } function YS(e) { return !!e && "arrayValue" in e } function JS(e) { return !!e && "nullValue" in e } function XS(e) { return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue)) } function ZS(e) { return !!e && "mapValue" in e } function $S(e) { if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) }; if (e.timestampValue && "object" == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) }; if (e.mapValue) { const t = { mapValue: { fields: {} } }; return xS(e.mapValue.fields, ((e, n) => t.mapValue.fields[e] = $S(n))), t } if (e.arrayValue) { const t = { arrayValue: { values: [] } }; for (let n = 0; n < (e.arrayValue.values || []).length; ++n)t.arrayValue.values[n] = $S(e.arrayValue.values[n]); return t } return Object.assign({}, e) } function eN(e) { return "__max__" === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue } class tN { constructor(e) { this.value = e } static empty() { return new tN({ mapValue: {} }) } field(e) { if (e.isEmpty()) return this.value; { let t = this.value; for (let n = 0; n < e.length - 1; ++n)if (t = (t.mapValue.fields || {})[e.get(n)], !ZS(t)) return null; return t = (t.mapValue.fields || {})[e.lastSegment()], t || null } } set(e, t) { this.getFieldsMap(e.popLast())[e.lastSegment()] = $S(t) } setAll(e) { let t = eS.emptyPath(), n = {}, r = []; e.forEach(((e, i) => { if (!t.isImmediateParentOf(i)) { const e = this.getFieldsMap(t); this.applyChanges(e, n, r), n = {}, r = [], t = i.popLast() } e ? n[i.lastSegment()] = $S(e) : r.push(i.lastSegment()) })); const i = this.getFieldsMap(t); this.applyChanges(i, n, r) } delete(e) { const t = this.field(e.popLast()); ZS(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()] } isEqual(e) { return zS(this.value, e.value) } getFieldsMap(e) { let t = this.value; t.mapValue.fields || (t.mapValue = { fields: {} }); for (let n = 0; n < e.length; ++n) { let r = t.mapValue.fields[e.get(n)]; ZS(r) && r.mapValue.fields || (r = { mapValue: { fields: {} } }, t.mapValue.fields[e.get(n)] = r), t = r } return t.mapValue.fields } applyChanges(e, t, n) { xS(t, ((t, n) => e[t] = n)); for (const r of n) delete e[r] } clone() { return new tN($S(this.value)) } } function nN(e) { const t = []; return xS(e.fields, ((e, n) => { const r = new eS([e]); if (ZS(n)) { const e = nN(n.mapValue).fields; if (0 === e.length) t.push(r); else for (const n of e) t.push(r.child(n)) } else t.push(r) })), new kS(t) } class rN { constructor(e, t, n, r, i, s, o) { this.key = e, this.documentType = t, this.version = n, this.readTime = r, this.createTime = i, this.data = s, this.documentState = o } static newInvalidDocument(e) { return new rN(e, 0, JE.min(), JE.min(), JE.min(), tN.empty(), 0) } static newFoundDocument(e, t, n, r) { return new rN(e, 1, t, JE.min(), n, r, 0) } static newNoDocument(e, t) { return new rN(e, 2, t, JE.min(), JE.min(), tN.empty(), 0) } static newUnknownDocument(e, t) { return new rN(e, 3, t, JE.min(), JE.min(), tN.empty(), 2) } convertToFoundDocument(e, t) { return !this.createTime.isEqual(JE.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this } convertToNoDocument(e) { return this.version = e, this.documentType = 2, this.data = tN.empty(), this.documentState = 0, this } convertToUnknownDocument(e) { return this.version = e, this.documentType = 3, this.data = tN.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = JE.min(), this } setReadTime(e) { return this.readTime = e, this } get hasLocalMutations() { return 1 === this.documentState } get hasCommittedMutations() { return 2 === this.documentState } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return 0 !== this.documentType } isFoundDocument() { return 1 === this.documentType } isNoDocument() { return 2 === this.documentType } isUnknownDocument() { return 3 === this.documentType } isEqual(e) { return e instanceof rN && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data) } mutableCopy() { return new rN(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState) } toString() { return "Document(".concat(this.key, ", ").concat(this.version, ", ").concat(JSON.stringify(this.data.value), ", {createTime: ").concat(this.createTime, "}), {documentType: ").concat(this.documentType, "}), {documentState: ").concat(this.documentState, "})") } } class iN { constructor(e, t) { this.position = e, this.inclusive = t } } function sN(e, t, n) { let r = 0; for (let i = 0; i < e.position.length; i++) { const s = t[i], o = e.position[i]; if (r = s.field.isKeyField() ? tS.comparator(tS.fromName(o.referenceValue), n.key) : HS(o, n.data.field(s.field)), "desc" === s.dir && (r *= -1), 0 !== r) break } return r } function oN(e, t) { if (null === e) return null === t; if (null === t) return !1; if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1; for (let n = 0; n < e.position.length; n++)if (!zS(e.position[n], t.position[n])) return !1; return !0 } class aN { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc"; this.field = e, this.dir = t } } function lN(e, t) { return e.dir === t.dir && e.field.isEqual(t.field) } class cN { } class uN extends cN { constructor(e, t, n) { super(), this.field = e, this.op = t, this.value = n } static create(e, t, n) { return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, n) : new yN(e, t, n) : "array-contains" === t ? new EN(e, n) : "in" === t ? new SN(e, n) : "not-in" === t ? new NN(e, n) : "array-contains-any" === t ? new CN(e, n) : new uN(e, t, n) } static createKeyFieldInFilter(e, t, n) { return "in" === t ? new bN(e, n) : new wN(e, n) } matches(e) { const t = e.data.field(this.field); return "!=" === this.op ? null !== t && this.matchesComparison(HS(t, this.value)) : null !== t && VS(this.value) === VS(t) && this.matchesComparison(HS(t, this.value)) } matchesComparison(e) { switch (this.op) { case "<": return e < 0; case "<=": return e <= 0; case "==": return 0 === e; case "!=": return 0 !== e; case ">": return e > 0; case ">=": return e >= 0; default: return IE() } } isInequality() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } getFlattenedFilters() { return [this] } getFilters() { return [this] } } class dN extends cN { constructor(e, t) { super(), this.filters = e, this.op = t, this.ae = null } static create(e, t) { return new dN(e, t) } matches(e) { return hN(this) ? void 0 === this.filters.find((t => !t.matches(e))) : void 0 !== this.filters.find((t => t.matches(e))) } getFlattenedFilters() { return null !== this.ae || (this.ae = this.filters.reduce(((e, t) => e.concat(t.getFlattenedFilters())), [])), this.ae } getFilters() { return Object.assign([], this.filters) } } function hN(e) { return "and" === e.op } function fN(e) { return pN(e) && hN(e) } function pN(e) { for (const t of e.filters) if (t instanceof dN) return !1; return !0 } function mN(e) { if (e instanceof uN) return e.field.canonicalString() + e.op.toString() + KS(e.value); if (fN(e)) return e.filters.map((e => mN(e))).join(","); { const t = e.filters.map((e => mN(e))).join(","); return "".concat(e.op, "(").concat(t, ")") } } function gN(e, t) { return e instanceof uN ? function (e, t) { return t instanceof uN && e.op === t.op && e.field.isEqual(t.field) && zS(e.value, t.value) }(e, t) : e instanceof dN ? function (e, t) { return t instanceof dN && e.op === t.op && e.filters.length === t.filters.length && e.filters.reduce(((e, n, r) => e && gN(n, t.filters[r])), !0) }(e, t) : void IE() } function vN(e) { return e instanceof uN ? function (e) { return "".concat(e.field.canonicalString(), " ").concat(e.op, " ").concat(KS(e.value)) }(e) : e instanceof dN ? function (e) { return e.op.toString() + " {" + e.getFilters().map(vN).join(" ,") + "}" }(e) : "Filter" } class yN extends uN { constructor(e, t, n) { super(e, t, n), this.key = tS.fromName(n.referenceValue) } matches(e) { const t = tS.comparator(e.key, this.key); return this.matchesComparison(t) } } class bN extends uN { constructor(e, t) { super(e, "in", t), this.keys = xN("in", t) } matches(e) { return this.keys.some((t => t.isEqual(e.key))) } } class wN extends uN { constructor(e, t) { super(e, "not-in", t), this.keys = xN("not-in", t) } matches(e) { return !this.keys.some((t => t.isEqual(e.key))) } } function xN(e, t) { var n; return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((e => tS.fromName(e.referenceValue))) } class EN extends uN { constructor(e, t) { super(e, "array-contains", t) } matches(e) { const t = e.data.field(this.field); return YS(t) && qS(t.arrayValue, this.value) } } class SN extends uN { constructor(e, t) { super(e, "in", t) } matches(e) { const t = e.data.field(this.field); return null !== t && qS(this.value.arrayValue, t) } } class NN extends uN { constructor(e, t) { super(e, "not-in", t) } matches(e) { if (qS(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const t = e.data.field(this.field); return null !== t && !qS(this.value.arrayValue, t) } } class CN extends uN { constructor(e, t) { super(e, "array-contains-any", t) } matches(e) { const t = e.data.field(this.field); return !(!YS(t) || !t.arrayValue.values) && t.arrayValue.values.some((e => qS(this.value.arrayValue, e))) } } class TN { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; this.path = e, this.collectionGroup = t, this.orderBy = n, this.filters = r, this.limit = i, this.startAt = s, this.endAt = o, this.ue = null } } function AN(e) { return new TN(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null) } function kN(e) { const t = OE(e); if (null === t.ue) { let e = t.path.canonicalString(); null !== t.collectionGroup && (e += "|cg:" + t.collectionGroup), e += "|f:", e += t.filters.map((e => mN(e))).join(","), e += "|ob:", e += t.orderBy.map((e => function (e) { return e.field.canonicalString() + e.dir }(e))).join(","), pS(t.limit) || (e += "|l:", e += t.limit), t.startAt && (e += "|lb:", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map((e => KS(e))).join(",")), t.endAt && (e += "|ub:", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map((e => KS(e))).join(",")), t.ue = e } return t.ue } function jN(e, t) { if (e.limit !== t.limit) return !1; if (e.orderBy.length !== t.orderBy.length) return !1; for (let n = 0; n < e.orderBy.length; n++)if (!lN(e.orderBy[n], t.orderBy[n])) return !1; if (e.filters.length !== t.filters.length) return !1; for (let n = 0; n < e.filters.length; n++)if (!gN(e.filters[n], t.filters[n])) return !1; return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!oN(e.startAt, t.startAt) && oN(e.endAt, t.endAt) } function PN(e) { return tS.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length } class IN { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "F", o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; this.path = e, this.collectionGroup = t, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.limitType = s, this.startAt = o, this.endAt = a, this.ce = null, this.le = null, this.he = null, this.startAt, this.endAt } } function RN(e, t, n, r, i, s, o, a) { return new IN(e, t, n, r, i, s, o, a) } function ON(e) { return new IN(e) } function DN(e) { return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField()) } function _N(e) { return null !== e.collectionGroup } function MN(e) { const t = OE(e); if (null === t.ce) { t.ce = []; const e = new Set; for (const i of t.explicitOrderBy) t.ce.push(i), e.add(i.field.canonicalString()); const n = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc", r = function (e) { let t = new TS(eS.comparator); return e.filters.forEach((e => { e.getFlattenedFilters().forEach((e => { e.isInequality() && (t = t.add(e.field)) })) })), t }(t); r.forEach((r => { e.has(r.canonicalString()) || r.isKeyField() || t.ce.push(new aN(r, n)) })), e.has(eS.keyField().canonicalString()) || t.ce.push(new aN(eS.keyField(), n)) } return t.ce } function LN(e) { const t = OE(e); return t.le || (t.le = FN(t, MN(e))), t.le } function FN(e, t) { if ("F" === e.limitType) return AN(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt); { t = t.map((e => { const t = "desc" === e.dir ? "asc" : "desc"; return new aN(e.field, t) })); const n = e.endAt ? new iN(e.endAt.position, e.endAt.inclusive) : null, r = e.startAt ? new iN(e.startAt.position, e.startAt.inclusive) : null; return AN(e.path, e.collectionGroup, t, e.filters, e.limit, n, r) } } function UN(e, t, n) { return new IN(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt) } function BN(e, t) { return jN(LN(e), LN(t)) && e.limitType === t.limitType } function VN(e) { return "".concat(kN(LN(e)), "|lt:").concat(e.limitType) } function zN(e) { return "Query(target=".concat(function (e) { let t = e.path.canonicalString(); return null !== e.collectionGroup && (t += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (t += ", filters: [".concat(e.filters.map((e => vN(e))).join(", "), "]")), pS(e.limit) || (t += ", limit: " + e.limit), e.orderBy.length > 0 && (t += ", orderBy: [".concat(e.orderBy.map((e => function (e) { return "".concat(e.field.canonicalString(), " (").concat(e.dir, ")") }(e))).join(", "), "]")), e.startAt && (t += ", startAt: ", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map((e => KS(e))).join(",")), e.endAt && (t += ", endAt: ", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map((e => KS(e))).join(",")), "Target(".concat(t, ")") }(LN(e)), "; limitType=").concat(e.limitType, ")") } function qN(e, t) { return t.isFoundDocument() && function (e, t) { const n = t.key.path; return null !== e.collectionGroup ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n) : tS.isDocumentKey(e.path) ? e.path.isEqual(n) : e.path.isImmediateParentOf(n) }(e, t) && function (e, t) { for (const n of MN(e)) if (!n.field.isKeyField() && null === t.data.field(n.field)) return !1; return !0 }(e, t) && function (e, t) { for (const n of e.filters) if (!n.matches(t)) return !1; return !0 }(e, t) && function (e, t) { return !(e.startAt && !function (e, t, n) { const r = sN(e, t, n); return e.inclusive ? r <= 0 : r < 0 }(e.startAt, MN(e), t)) && !(e.endAt && !function (e, t, n) { const r = sN(e, t, n); return e.inclusive ? r >= 0 : r > 0 }(e.endAt, MN(e), t)) }(e, t) } function HN(e) { return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2)) } function WN(e) { return (t, n) => { let r = !1; for (const i of MN(e)) { const e = KN(i, t, n); if (0 !== e) return e; r = r || i.field.isKeyField() } return 0 } } function KN(e, t, n) { const r = e.field.isKeyField() ? tS.comparator(t.key, n.key) : function (e, t, n) { const r = t.data.field(e), i = n.data.field(e); return null !== r && null !== i ? HS(r, i) : IE() }(e.field, t, n); switch (e.dir) { case "asc": return r; case "desc": return -1 * r; default: return IE() } } class GN { constructor(e, t) { this.mapKeyFn = e, this.equalsFn = t, this.inner = {}, this.innerSize = 0 } get(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 !== n) for (const [r, i] of n) if (this.equalsFn(r, e)) return i } has(e) { return void 0 !== this.get(e) } set(e, t) { const n = this.mapKeyFn(e), r = this.inner[n]; if (void 0 === r) return this.inner[n] = [[e, t]], void this.innerSize++; for (let i = 0; i < r.length; i++)if (this.equalsFn(r[i][0], e)) return void (r[i] = [e, t]); r.push([e, t]), this.innerSize++ } delete(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 === n) return !1; for (let r = 0; r < n.length; r++)if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, !0; return !1 } forEach(e) { xS(this.inner, ((t, n) => { for (const [r, i] of n) e(r, i) })) } isEmpty() { return ES(this.inner) } size() { return this.innerSize } } const QN = new SS(tS.comparator); function YN() { return QN } const JN = new SS(tS.comparator); function XN() { let e = JN; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) e = e.insert(i.key, i); return e } function ZN(e) { let t = JN; return e.forEach(((e, n) => t = t.insert(e, n.overlayedDocument))), t } function $N() { return tC() } function eC() { return tC() } function tC() { return new GN((e => e.toString()), ((e, t) => e.isEqual(t))) } const nC = new SS(tS.comparator), rC = new TS(tS.comparator); function iC() { let e = rC; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) e = e.add(i); return e } const sC = new TS(GE); function oC() { return sC } function aC(e, t) { if (e.useProto3Json) { if (isNaN(t)) return { doubleValue: "NaN" }; if (t === 1 / 0) return { doubleValue: "Infinity" }; if (t === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: mS(t) ? "-0" : t } } function lC(e) { return { integerValue: "" + e } } function cC(e, t) { return gS(t) ? lC(t) : aC(e, t) } class uC { constructor() { this._ = void 0 } } function dC(e, t, n) { return e instanceof pC ? function (e, t) { const n = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: e.seconds, nanos: e.nanoseconds } } } }; return t && _S(t) && (t = MS(t)), t && (n.fields.__previous_value__ = t), { mapValue: n } }(n, t) : e instanceof mC ? gC(e, t) : e instanceof vC ? yC(e, t) : function (e, t) { const n = fC(e, t), r = wC(n) + wC(e.Pe); return QS(n) && QS(e.Pe) ? lC(r) : aC(e.serializer, r) }(e, t) } function hC(e, t, n) { return e instanceof mC ? gC(e, t) : e instanceof vC ? yC(e, t) : n } function fC(e, t) { return e instanceof bC ? function (e) { return QS(e) || function (e) { return !!e && "doubleValue" in e }(e) }(t) ? t : { integerValue: 0 } : null } class pC extends uC { } class mC extends uC { constructor(e) { super(), this.elements = e } } function gC(e, t) { const n = xC(t); for (const r of e.elements) n.some((e => zS(e, r))) || n.push(r); return { arrayValue: { values: n } } } class vC extends uC { constructor(e) { super(), this.elements = e } } function yC(e, t) { let n = xC(t); for (const r of e.elements) n = n.filter((e => !zS(e, r))); return { arrayValue: { values: n } } } class bC extends uC { constructor(e, t) { super(), this.serializer = e, this.Pe = t } } function wC(e) { return OS(e.integerValue || e.doubleValue) } function xC(e) { return YS(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [] } class EC { constructor(e, t) { this.version = e, this.transformResults = t } } class SC { constructor(e, t) { this.updateTime = e, this.exists = t } static none() { return new SC } static exists(e) { return new SC(void 0, e) } static updateTime(e) { return new SC(e) } get isNone() { return void 0 === this.updateTime && void 0 === this.exists } isEqual(e) { return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime) } } function NC(e, t) { return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument() } class CC { } function TC(e, t) { if (!e.hasLocalMutations || t && 0 === t.fields.length) return null; if (null === t) return e.isNoDocument() ? new MC(e.key, SC.none()) : new IC(e.key, e.data, SC.none()); { const n = e.data, r = tN.empty(); let i = new TS(eS.comparator); for (let e of t.fields) if (!i.has(e)) { let t = n.field(e); null === t && e.length > 1 && (e = e.popLast(), t = n.field(e)), null === t ? r.delete(e) : r.set(e, t), i = i.add(e) } return new RC(e.key, r, new kS(i.toArray()), SC.none()) } } function AC(e, t, n) { e instanceof IC ? function (e, t, n) { const r = e.value.clone(), i = DC(e.fieldTransforms, t, n.transformResults); r.setAll(i), t.convertToFoundDocument(n.version, r).setHasCommittedMutations() }(e, t, n) : e instanceof RC ? function (e, t, n) { if (!NC(e.precondition, t)) return void t.convertToUnknownDocument(n.version); const r = DC(e.fieldTransforms, t, n.transformResults), i = t.data; i.setAll(OC(e)), i.setAll(r), t.convertToFoundDocument(n.version, i).setHasCommittedMutations() }(e, t, n) : function (e, t, n) { t.convertToNoDocument(n.version).setHasCommittedMutations() }(0, t, n) } function kC(e, t, n, r) { return e instanceof IC ? function (e, t, n, r) { if (!NC(e.precondition, t)) return n; const i = e.value.clone(), s = _C(e.fieldTransforms, r, t); return i.setAll(s), t.convertToFoundDocument(t.version, i).setHasLocalMutations(), null }(e, t, n, r) : e instanceof RC ? function (e, t, n, r) { if (!NC(e.precondition, t)) return n; const i = _C(e.fieldTransforms, r, t), s = t.data; return s.setAll(OC(e)), s.setAll(i), t.convertToFoundDocument(t.version, s).setHasLocalMutations(), null === n ? null : n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e => e.field))) }(e, t, n, r) : function (e, t, n) { return NC(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(), null) : n }(e, t, n) } function jC(e, t) { let n = null; for (const r of e.fieldTransforms) { const e = t.data.field(r.field), i = fC(r.transform, e || null); null != i && (null === n && (n = tN.empty()), n.set(r.field, i)) } return n || null } function PC(e, t) { return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && !!function (e, t) { return void 0 === e && void 0 === t || !(!e || !t) && QE(e, t, ((e, t) => function (e, t) { return e.field.isEqual(t.field) && function (e, t) { return e instanceof mC && t instanceof mC || e instanceof vC && t instanceof vC ? QE(e.elements, t.elements, zS) : e instanceof bC && t instanceof bC ? zS(e.Pe, t.Pe) : e instanceof pC && t instanceof pC }(e.transform, t.transform) }(e, t))) }(e.fieldTransforms, t.fieldTransforms) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)) } class IC extends CC { constructor(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []; super(), this.key = e, this.value = t, this.precondition = n, this.fieldTransforms = r, this.type = 0 } getFieldMask() { return null } } class RC extends CC { constructor(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : []; super(), this.key = e, this.data = t, this.fieldMask = n, this.precondition = r, this.fieldTransforms = i, this.type = 1 } getFieldMask() { return this.fieldMask } } function OC(e) { const t = new Map; return e.fieldMask.fields.forEach((n => { if (!n.isEmpty()) { const r = e.data.field(n); t.set(n, r) } })), t } function DC(e, t, n) { const r = new Map; RE(e.length === n.length); for (let i = 0; i < n.length; i++) { const s = e[i], o = s.transform, a = t.data.field(s.field); r.set(s.field, hC(o, a, n[i])) } return r } function _C(e, t, n) { const r = new Map; for (const i of e) { const e = i.transform, s = n.data.field(i.field); r.set(i.field, dC(e, s, t)) } return r } class MC extends CC { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class LC extends CC { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } } class FC { constructor(e, t, n, r) { this.batchId = e, this.localWriteTime = t, this.baseMutations = n, this.mutations = r } applyToRemoteDocument(e, t) { const n = t.mutationResults; for (let r = 0; r < this.mutations.length; r++) { const t = this.mutations[r]; t.key.isEqual(e.key) && AC(t, e, n[r]) } } applyToLocalView(e, t) { for (const n of this.baseMutations) n.key.isEqual(e.key) && (t = kC(n, e, t, this.localWriteTime)); for (const n of this.mutations) n.key.isEqual(e.key) && (t = kC(n, e, t, this.localWriteTime)); return t } applyToLocalDocumentSet(e, t) { const n = eC(); return this.mutations.forEach((r => { const i = e.get(r.key), s = i.overlayedDocument; let o = this.applyToLocalView(s, i.mutatedFields); o = t.has(r.key) ? null : o; const a = TC(s, o); null !== a && n.set(r.key, a), s.isValidDocument() || s.convertToNoDocument(JE.min()) })), n } keys() { return this.mutations.reduce(((e, t) => e.add(t.key)), iC()) } isEqual(e) { return this.batchId === e.batchId && QE(this.mutations, e.mutations, ((e, t) => PC(e, t))) && QE(this.baseMutations, e.baseMutations, ((e, t) => PC(e, t))) } } class UC { constructor(e, t, n, r) { this.batch = e, this.commitVersion = t, this.mutationResults = n, this.docVersions = r } static from(e, t, n) { RE(e.mutations.length === n.length); let r = nC; const i = e.mutations; for (let s = 0; s < i.length; s++)r = r.insert(i[s].key, n[s].version); return new UC(e, t, n, r) } } class BC { constructor(e, t) { this.largestBatchId = e, this.mutation = t } getKey() { return this.mutation.key } isEqual(e) { return null !== e && this.mutation === e.mutation } toString() { return "Overlay{\n      largestBatchId: ".concat(this.largestBatchId, ",\n      mutation: ").concat(this.mutation.toString(), "\n    }") } } class VC { constructor(e, t) { this.count = e, this.unchangedNames = t } } var zC, qC; function HC(e) { switch (e) { default: return IE(); case DE.CANCELLED: case DE.UNKNOWN: case DE.DEADLINE_EXCEEDED: case DE.RESOURCE_EXHAUSTED: case DE.INTERNAL: case DE.UNAVAILABLE: case DE.UNAUTHENTICATED: return !1; case DE.INVALID_ARGUMENT: case DE.NOT_FOUND: case DE.ALREADY_EXISTS: case DE.PERMISSION_DENIED: case DE.FAILED_PRECONDITION: case DE.ABORTED: case DE.OUT_OF_RANGE: case DE.UNIMPLEMENTED: case DE.DATA_LOSS: return !0 } } function WC(e) { if (void 0 === e) return kE("GRPC error has no .code"), DE.UNKNOWN; switch (e) { case zC.OK: return DE.OK; case zC.CANCELLED: return DE.CANCELLED; case zC.UNKNOWN: return DE.UNKNOWN; case zC.DEADLINE_EXCEEDED: return DE.DEADLINE_EXCEEDED; case zC.RESOURCE_EXHAUSTED: return DE.RESOURCE_EXHAUSTED; case zC.INTERNAL: return DE.INTERNAL; case zC.UNAVAILABLE: return DE.UNAVAILABLE; case zC.UNAUTHENTICATED: return DE.UNAUTHENTICATED; case zC.INVALID_ARGUMENT: return DE.INVALID_ARGUMENT; case zC.NOT_FOUND: return DE.NOT_FOUND; case zC.ALREADY_EXISTS: return DE.ALREADY_EXISTS; case zC.PERMISSION_DENIED: return DE.PERMISSION_DENIED; case zC.FAILED_PRECONDITION: return DE.FAILED_PRECONDITION; case zC.ABORTED: return DE.ABORTED; case zC.OUT_OF_RANGE: return DE.OUT_OF_RANGE; case zC.UNIMPLEMENTED: return DE.UNIMPLEMENTED; case zC.DATA_LOSS: return DE.DATA_LOSS; default: return IE() } } (qC = zC || (zC = {}))[qC.OK = 0] = "OK", qC[qC.CANCELLED = 1] = "CANCELLED", qC[qC.UNKNOWN = 2] = "UNKNOWN", qC[qC.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", qC[qC.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", qC[qC.NOT_FOUND = 5] = "NOT_FOUND", qC[qC.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", qC[qC.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", qC[qC.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", qC[qC.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", qC[qC.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", qC[qC.ABORTED = 10] = "ABORTED", qC[qC.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", qC[qC.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", qC[qC.INTERNAL = 13] = "INTERNAL", qC[qC.UNAVAILABLE = 14] = "UNAVAILABLE", qC[qC.DATA_LOSS = 15] = "DATA_LOSS"; let KC = null; function GC() { return new TextEncoder } const QC = new aE([4294967295, 4294967295], 0); function YC(e) { const t = GC().encode(e), n = new lE; return n.update(t), new Uint8Array(n.digest()) } function JC(e) { const t = new DataView(e.buffer), n = t.getUint32(0, !0), r = t.getUint32(4, !0), i = t.getUint32(8, !0), s = t.getUint32(12, !0); return [new aE([n, r], 0), new aE([i, s], 0)] } class XC { constructor(e, t, n) { if (this.bitmap = e, this.padding = t, this.hashCount = n, t < 0 || t >= 8) throw new ZC("Invalid padding: ".concat(t)); if (n < 0) throw new ZC("Invalid hash count: ".concat(n)); if (e.length > 0 && 0 === this.hashCount) throw new ZC("Invalid hash count: ".concat(n)); if (0 === e.length && 0 !== t) throw new ZC("Invalid padding when bitmap length is 0: ".concat(t)); this.Ie = 8 * e.length - t, this.Te = aE.fromNumber(this.Ie) } Ee(e, t, n) { let r = e.add(t.multiply(aE.fromNumber(n))); return 1 === r.compare(QC) && (r = new aE([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Te).toNumber() } de(e) { return 0 != (this.bitmap[Math.floor(e / 8)] & 1 << e % 8) } mightContain(e) { if (0 === this.Ie) return !1; const t = YC(e), [n, r] = JC(t); for (let i = 0; i < this.hashCount; i++) { const e = this.Ee(n, r, i); if (!this.de(e)) return !1 } return !0 } static create(e, t, n) { const r = e % 8 == 0 ? 0 : 8 - e % 8, i = new Uint8Array(Math.ceil(e / 8)), s = new XC(i, r, t); return n.forEach((e => s.insert(e))), s } insert(e) { if (0 === this.Ie) return; const t = YC(e), [n, r] = JC(t); for (let i = 0; i < this.hashCount; i++) { const e = this.Ee(n, r, i); this.Ae(e) } } Ae(e) { const t = Math.floor(e / 8), n = e % 8; this.bitmap[t] |= 1 << n } } class ZC extends Error { constructor() { super(...arguments), this.name = "BloomFilterError" } } class $C { constructor(e, t, n, r, i) { this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i } static createSynthesizedRemoteEventForCurrentChange(e, t, n) { const r = new Map; return r.set(e, eT.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new $C(JE.min(), r, new SS(GE), YN(), iC()) } } class eT { constructor(e, t, n, r, i) { this.resumeToken = e, this.current = t, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i } static createSynthesizedTargetChangeForCurrentChange(e, t, n) { return new eT(n, t, iC(), iC(), iC()) } } class tT { constructor(e, t, n, r) { this.Re = e, this.removedTargetIds = t, this.key = n, this.Ve = r } } class nT { constructor(e, t) { this.targetId = e, this.me = t } } class rT { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PS.EMPTY_BYTE_STRING, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; this.state = e, this.targetIds = t, this.resumeToken = n, this.cause = r } } class iT { constructor() { this.fe = 0, this.ge = aT(), this.pe = PS.EMPTY_BYTE_STRING, this.ye = !1, this.we = !0 } get current() { return this.ye } get resumeToken() { return this.pe } get Se() { return 0 !== this.fe } get be() { return this.we } De(e) { e.approximateByteSize() > 0 && (this.we = !0, this.pe = e) } Ce() { let e = iC(), t = iC(), n = iC(); return this.ge.forEach(((r, i) => { switch (i) { case 0: e = e.add(r); break; case 2: t = t.add(r); break; case 1: n = n.add(r); break; default: IE() } })), new eT(this.pe, this.ye, e, t, n) } ve() { this.we = !1, this.ge = aT() } Fe(e, t) { this.we = !0, this.ge = this.ge.insert(e, t) } Me(e) { this.we = !0, this.ge = this.ge.remove(e) } xe() { this.fe += 1 } Oe() { this.fe -= 1, RE(this.fe >= 0) } Ne() { this.we = !0, this.ye = !0 } } class sT { constructor(e) { this.Le = e, this.Be = new Map, this.ke = YN(), this.qe = oT(), this.Qe = new SS(GE) } Ke(e) { for (const t of e.Re) e.Ve && e.Ve.isFoundDocument() ? this.$e(t, e.Ve) : this.Ue(t, e.key, e.Ve); for (const t of e.removedTargetIds) this.Ue(t, e.key, e.Ve) } We(e) { this.forEachTarget(e, (t => { const n = this.Ge(t); switch (e.state) { case 0: this.ze(t) && n.De(e.resumeToken); break; case 1: n.Oe(), n.Se || n.ve(), n.De(e.resumeToken); break; case 2: n.Oe(), n.Se || this.removeTarget(t); break; case 3: this.ze(t) && (n.Ne(), n.De(e.resumeToken)); break; case 4: this.ze(t) && (this.je(t), n.De(e.resumeToken)); break; default: IE() } })) } forEachTarget(e, t) { e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Be.forEach(((e, n) => { this.ze(n) && t(n) })) } He(e) { const t = e.targetId, n = e.me.count, r = this.Je(t); if (r) { const i = r.target; if (PN(i)) if (0 === n) { const e = new tS(i.path); this.Ue(t, e, rN.newNoDocument(e, JE.min())) } else RE(1 === n); else { const r = this.Ye(t); if (r !== n) { const n = this.Ze(e), i = n ? this.Xe(n, e, r) : 1; if (0 !== i) { this.je(t); const e = 2 === i ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch"; this.Qe = this.Qe.insert(t, e) } null == KC || KC.et(function (e, t, n, r, i) { var s, o, a, l, c, u; const d = { localCacheCount: e, existenceFilterCount: t.count, databaseId: n.database, projectId: n.projectId }, h = t.unchangedNames; return h && (d.bloomFilter = { applied: 0 === i, hashCount: null !== (s = null == h ? void 0 : h.hashCount) && void 0 !== s ? s : 0, bitmapLength: null !== (l = null === (a = null === (o = null == h ? void 0 : h.bits) || void 0 === o ? void 0 : o.bitmap) || void 0 === a ? void 0 : a.length) && void 0 !== l ? l : 0, padding: null !== (u = null === (c = null == h ? void 0 : h.bits) || void 0 === c ? void 0 : c.padding) && void 0 !== u ? u : 0, mightContain: e => { var t; return null !== (t = null == r ? void 0 : r.mightContain(e)) && void 0 !== t && t } }), d }(r, e.me, this.Le.tt(), n, i)) } } } } Ze(e) { const t = e.me.unchangedNames; if (!t || !t.bits) return null; const { bits: { bitmap: n = "", padding: r = 0 }, hashCount: i = 0 } = t; let s, o; try { s = DS(n).toUint8Array() } catch (e) { if (e instanceof jS) return jE("Decoding the base64 bloom filter in existence filter failed (" + e.message + "); ignoring the bloom filter and falling back to full re-query."), null; throw e } try { o = new XC(s, r, i) } catch (e) { return jE(e instanceof ZC ? "BloomFilter error: " : "Applying bloom filter failed: ", e), null } return 0 === o.Ie ? null : o } Xe(e, t, n) { return t.me.count === n - this.nt(e, t.targetId) ? 0 : 2 } nt(e, t) { const n = this.Le.getRemoteKeysForTarget(t); let r = 0; return n.forEach((n => { const i = this.Le.tt(), s = "projects/".concat(i.projectId, "/databases/").concat(i.database, "/documents/").concat(n.path.canonicalString()); e.mightContain(s) || (this.Ue(t, n, null), r++) })), r } rt(e) { const t = new Map; this.Be.forEach(((n, r) => { const i = this.Je(r); if (i) { if (n.current && PN(i.target)) { const t = new tS(i.target.path); null !== this.ke.get(t) || this.it(r, t) || this.Ue(r, t, rN.newNoDocument(t, e)) } n.be && (t.set(r, n.Ce()), n.ve()) } })); let n = iC(); this.qe.forEach(((e, t) => { let r = !0; t.forEachWhile((e => { const t = this.Je(e); return !t || "TargetPurposeLimboResolution" === t.purpose || (r = !1, !1) })), r && (n = n.add(e)) })), this.ke.forEach(((t, n) => n.setReadTime(e))); const r = new $C(e, t, this.Qe, this.ke, n); return this.ke = YN(), this.qe = oT(), this.Qe = new SS(GE), r } $e(e, t) { if (!this.ze(e)) return; const n = this.it(e, t.key) ? 2 : 0; this.Ge(e).Fe(t.key, n), this.ke = this.ke.insert(t.key, t), this.qe = this.qe.insert(t.key, this.st(t.key).add(e)) } Ue(e, t, n) { if (!this.ze(e)) return; const r = this.Ge(e); this.it(e, t) ? r.Fe(t, 1) : r.Me(t), this.qe = this.qe.insert(t, this.st(t).delete(e)), n && (this.ke = this.ke.insert(t, n)) } removeTarget(e) { this.Be.delete(e) } Ye(e) { const t = this.Ge(e).Ce(); return this.Le.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size } xe(e) { this.Ge(e).xe() } Ge(e) { let t = this.Be.get(e); return t || (t = new iT, this.Be.set(e, t)), t } st(e) { let t = this.qe.get(e); return t || (t = new TS(GE), this.qe = this.qe.insert(e, t)), t } ze(e) { const t = null !== this.Je(e); return t || AE("WatchChangeAggregator", "Detected inactive target", e), t } Je(e) { const t = this.Be.get(e); return t && t.Se ? null : this.Le.ot(e) } je(e) { this.Be.set(e, new iT), this.Le.getRemoteKeysForTarget(e).forEach((t => { this.Ue(e, t, null) })) } it(e, t) { return this.Le.getRemoteKeysForTarget(e).has(t) } } function oT() { return new SS(tS.comparator) } function aT() { return new SS(tS.comparator) } const lT = { asc: "ASCENDING", desc: "DESCENDING" }, cT = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }, uT = { and: "AND", or: "OR" }; class dT { constructor(e, t) { this.databaseId = e, this.useProto3Json = t } } function hT(e, t) { return e.useProto3Json || pS(t) ? t : { value: t } } function fT(e, t) { return e.useProto3Json ? "".concat(new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", ""), ".").concat(("000000000" + t.nanoseconds).slice(-9), "Z") : { seconds: "" + t.seconds, nanos: t.nanoseconds } } function pT(e, t) { return e.useProto3Json ? t.toBase64() : t.toUint8Array() } function mT(e, t) { return fT(e, t.toTimestamp()) } function gT(e) { return RE(!!e), JE.fromTimestamp(function (e) { const t = RS(e); return new YE(t.seconds, t.nanos) }(e)) } function vT(e, t) { return yT(e, t).canonicalString() } function yT(e, t) { const n = function (e) { return new ZE(["projects", e.projectId, "databases", e.database]) }(e).child("documents"); return void 0 === t ? n : n.child(t) } function bT(e) { const t = ZE.fromString(e); return RE(UT(t)), t } function wT(e, t) { return vT(e.databaseId, t.path) } function xT(e, t) { const n = bT(t); if (n.get(1) !== e.databaseId.projectId) throw new _E(DE.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId); if (n.get(3) !== e.databaseId.database) throw new _E(DE.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database); return new tS(CT(n)) } function ET(e, t) { return vT(e.databaseId, t) } function ST(e) { const t = bT(e); return 4 === t.length ? ZE.emptyPath() : CT(t) } function NT(e) { return new ZE(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString() } function CT(e) { return RE(e.length > 4 && "documents" === e.get(4)), e.popFirst(5) } function TT(e, t, n) { return { name: wT(e, t), fields: n.value.mapValue.fields } } function AT(e, t) { let n; if (t instanceof IC) n = { update: TT(e, t.key, t.value) }; else if (t instanceof MC) n = { delete: wT(e, t.key) }; else if (t instanceof RC) n = { update: TT(e, t.key, t.data), updateMask: FT(t.fieldMask) }; else { if (!(t instanceof LC)) return IE(); n = { verify: wT(e, t.key) } } return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map((e => function (e, t) { const n = t.transform; if (n instanceof pC) return { fieldPath: t.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (n instanceof mC) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } }; if (n instanceof vC) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } }; if (n instanceof bC) return { fieldPath: t.field.canonicalString(), increment: n.Pe }; throw IE() }(0, e)))), t.precondition.isNone || (n.currentDocument = function (e, t) { return void 0 !== t.updateTime ? { updateTime: mT(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : IE() }(e, t.precondition)), n } function kT(e, t) { return { documents: [ET(e, t.path)] } } function jT(e, t) { const n = { structuredQuery: {} }, r = t.path; let i; null !== t.collectionGroup ? (i = r, n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]) : (i = r.popLast(), n.structuredQuery.from = [{ collectionId: r.lastSegment() }]), n.parent = ET(e, i); const s = function (e) { if (0 !== e.length) return LT(dN.create(e, "and")) }(t.filters); s && (n.structuredQuery.where = s); const o = function (e) { if (0 !== e.length) return e.map((e => function (e) { return { field: _T(e.field), direction: RT(e.dir) } }(e))) }(t.orderBy); o && (n.structuredQuery.orderBy = o); const a = hT(e, t.limit); return null !== a && (n.structuredQuery.limit = a), t.startAt && (n.structuredQuery.startAt = function (e) { return { before: e.inclusive, values: e.position } }(t.startAt)), t.endAt && (n.structuredQuery.endAt = function (e) { return { before: !e.inclusive, values: e.position } }(t.endAt)), { _t: n, parent: i } } function PT(e) { let t = ST(e.parent); const n = e.structuredQuery, r = n.from ? n.from.length : 0; let i = null; if (r > 0) { RE(1 === r); const e = n.from[0]; e.allDescendants ? i = e.collectionId : t = t.child(e.collectionId) } let s = []; n.where && (s = function (e) { const t = IT(e); return t instanceof dN && fN(t) ? t.getFilters() : [t] }(n.where)); let o = []; n.orderBy && (o = function (e) { return e.map((e => function (e) { return new aN(MT(e.field), function (e) { switch (e) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(e.direction)) }(e))) }(n.orderBy)); let a = null; n.limit && (a = function (e) { let t; return t = "object" == typeof e ? e.value : e, pS(t) ? null : t }(n.limit)); let l = null; n.startAt && (l = function (e) { const t = !!e.before, n = e.values || []; return new iN(n, t) }(n.startAt)); let c = null; return n.endAt && (c = function (e) { const t = !e.before, n = e.values || []; return new iN(n, t) }(n.endAt)), RN(t, i, o, s, a, "F", l, c) } function IT(e) { return void 0 !== e.unaryFilter ? function (e) { switch (e.unaryFilter.op) { case "IS_NAN": const t = MT(e.unaryFilter.field); return uN.create(t, "==", { doubleValue: NaN }); case "IS_NULL": const n = MT(e.unaryFilter.field); return uN.create(n, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const r = MT(e.unaryFilter.field); return uN.create(r, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const i = MT(e.unaryFilter.field); return uN.create(i, "!=", { nullValue: "NULL_VALUE" }); default: return IE() } }(e) : void 0 !== e.fieldFilter ? function (e) { return uN.create(MT(e.fieldFilter.field), function (e) { switch (e) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return IE() } }(e.fieldFilter.op), e.fieldFilter.value) }(e) : void 0 !== e.compositeFilter ? function (e) { return dN.create(e.compositeFilter.filters.map((e => IT(e))), function (e) { switch (e) { case "AND": return "and"; case "OR": return "or"; default: return IE() } }(e.compositeFilter.op)) }(e) : IE() } function RT(e) { return lT[e] } function OT(e) { return cT[e] } function DT(e) { return uT[e] } function _T(e) { return { fieldPath: e.canonicalString() } } function MT(e) { return eS.fromServerFormat(e.fieldPath) } function LT(e) { return e instanceof uN ? function (e) { if ("==" === e.op) { if (XS(e.value)) return { unaryFilter: { field: _T(e.field), op: "IS_NAN" } }; if (JS(e.value)) return { unaryFilter: { field: _T(e.field), op: "IS_NULL" } } } else if ("!=" === e.op) { if (XS(e.value)) return { unaryFilter: { field: _T(e.field), op: "IS_NOT_NAN" } }; if (JS(e.value)) return { unaryFilter: { field: _T(e.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: _T(e.field), op: OT(e.op), value: e.value } } }(e) : e instanceof dN ? function (e) { const t = e.getFilters().map((e => LT(e))); return 1 === t.length ? t[0] : { compositeFilter: { op: DT(e.op), filters: t } } }(e) : IE() } function FT(e) { const t = []; return e.fields.forEach((e => t.push(e.canonicalString()))), { fieldPaths: t } } function UT(e) { return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2) } class BT { constructor(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : JE.min(), s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : JE.min(), o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : PS.EMPTY_BYTE_STRING, a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; this.target = e, this.targetId = t, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = s, this.resumeToken = o, this.expectedCount = a } withSequenceNumber(e) { return new BT(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount) } withResumeToken(e, t) { return new BT(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null) } withExpectedCount(e) { return new BT(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e) } withLastLimboFreeSnapshotVersion(e) { return new BT(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount) } } class VT { constructor(e) { this.ct = e } } function zT(e) { const t = PT({ parent: e.parent, structuredQuery: e.structuredQuery }); return "LAST" === e.limitType ? UN(t, t.limit, "L") : t } class qT { constructor() { } Pt(e, t) { this.It(e, t), t.Tt() } It(e, t) { if ("nullValue" in e) this.Et(t, 5); else if ("booleanValue" in e) this.Et(t, 10), t.dt(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.Et(t, 15), t.dt(OS(e.integerValue)); else if ("doubleValue" in e) { const n = OS(e.doubleValue); isNaN(n) ? this.Et(t, 13) : (this.Et(t, 15), mS(n) ? t.dt(0) : t.dt(n)) } else if ("timestampValue" in e) { let n = e.timestampValue; this.Et(t, 20), "string" == typeof n && (n = RS(n)), t.At("".concat(n.seconds || "")), t.dt(n.nanos || 0) } else if ("stringValue" in e) this.Rt(e.stringValue, t), this.Vt(t); else if ("bytesValue" in e) this.Et(t, 30), t.ft(DS(e.bytesValue)), this.Vt(t); else if ("referenceValue" in e) this.gt(e.referenceValue, t); else if ("geoPointValue" in e) { const n = e.geoPointValue; this.Et(t, 45), t.dt(n.latitude || 0), t.dt(n.longitude || 0) } else "mapValue" in e ? eN(e) ? this.Et(t, Number.MAX_SAFE_INTEGER) : (this.yt(e.mapValue, t), this.Vt(t)) : "arrayValue" in e ? (this.wt(e.arrayValue, t), this.Vt(t)) : IE() } Rt(e, t) { this.Et(t, 25), this.St(e, t) } St(e, t) { t.At(e) } yt(e, t) { const n = e.fields || {}; this.Et(t, 55); for (const r of Object.keys(n)) this.Rt(r, t), this.It(n[r], t) } wt(e, t) { const n = e.values || []; this.Et(t, 50); for (const r of n) this.It(r, t) } gt(e, t) { this.Et(t, 37), tS.fromName(e).path.forEach((e => { this.Et(t, 60), this.St(e, t) })) } Et(e, t) { e.dt(t) } Vt(e) { e.dt(2) } } qT.bt = new qT; class HT { constructor() { this._n = new WT } addToCollectionParentIndex(e, t) { return this._n.add(t), uS.resolve() } getCollectionParents(e, t) { return uS.resolve(this._n.getEntries(t)) } addFieldIndex(e, t) { return uS.resolve() } deleteFieldIndex(e, t) { return uS.resolve() } deleteAllFieldIndexes(e) { return uS.resolve() } createTargetIndexes(e, t) { return uS.resolve() } getDocumentsMatchingTarget(e, t) { return uS.resolve(null) } getIndexType(e, t) { return uS.resolve(0) } getFieldIndexes(e, t) { return uS.resolve([]) } getNextCollectionGroupToUpdate(e) { return uS.resolve(null) } getMinOffset(e, t) { return uS.resolve(sS.min()) } getMinOffsetFromCollectionGroup(e, t) { return uS.resolve(sS.min()) } updateCollectionGroup(e, t, n) { return uS.resolve() } updateIndexEntries(e, t) { return uS.resolve() } } class WT { constructor() { this.index = {} } add(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t] || new TS(ZE.comparator), i = !r.has(n); return this.index[t] = r.add(n), i } has(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t]; return r && r.has(n) } getEntries(e) { return (this.index[e] || new TS(ZE.comparator)).toArray() } } new Uint8Array(0); class KT { constructor(e, t, n) { this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = n } static withCacheSize(e) { return new KT(e, KT.DEFAULT_COLLECTION_PERCENTILE, KT.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } } KT.DEFAULT_COLLECTION_PERCENTILE = 10, KT.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, KT.DEFAULT = new KT(41943040, KT.DEFAULT_COLLECTION_PERCENTILE, KT.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), KT.DISABLED = new KT(-1, 0, 0); class GT { constructor(e) { this.On = e } next() { return this.On += 2, this.On } static Nn() { return new GT(0) } static Ln() { return new GT(-1) } } class QT { constructor() { this.changes = new GN((e => e.toString()), ((e, t) => e.isEqual(t))), this.changesApplied = !1 } addEntry(e) { this.assertNotApplied(), this.changes.set(e.key, e) } removeEntry(e, t) { this.assertNotApplied(), this.changes.set(e, rN.newInvalidDocument(e).setReadTime(t)) } getEntry(e, t) { this.assertNotApplied(); const n = this.changes.get(t); return void 0 !== n ? uS.resolve(n) : this.getFromCache(e, t) } getEntries(e, t) { return this.getAllFromCache(e, t) } apply(e) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e) } assertNotApplied() { } } class YT { constructor(e, t) { this.overlayedDocument = e, this.mutatedFields = t } } class JT { constructor(e, t, n, r) { this.remoteDocumentCache = e, this.mutationQueue = t, this.documentOverlayCache = n, this.indexManager = r } getDocument(e, t) { let n = null; return this.documentOverlayCache.getOverlay(e, t).next((r => (n = r, this.remoteDocumentCache.getEntry(e, t)))).next((e => (null !== n && kC(n.mutation, e, kS.empty(), YE.now()), e))) } getDocuments(e, t) { return this.remoteDocumentCache.getEntries(e, t).next((t => this.getLocalViewOfDocuments(e, t, iC()).next((() => t)))) } getLocalViewOfDocuments(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : iC(); const r = $N(); return this.populateOverlays(e, r, t).next((() => this.computeViews(e, t, r, n).next((e => { let t = XN(); return e.forEach(((e, n) => { t = t.insert(e, n.overlayedDocument) })), t })))) } getOverlayedDocuments(e, t) { const n = $N(); return this.populateOverlays(e, n, t).next((() => this.computeViews(e, t, n, iC()))) } populateOverlays(e, t, n) { const r = []; return n.forEach((e => { t.has(e) || r.push(e) })), this.documentOverlayCache.getOverlays(e, r).next((e => { e.forEach(((e, n) => { t.set(e, n) })) })) } computeViews(e, t, n, r) { let i = YN(); const s = tC(), o = tC(); return t.forEach(((e, t) => { const o = n.get(t.key); r.has(t.key) && (void 0 === o || o.mutation instanceof RC) ? i = i.insert(t.key, t) : void 0 !== o ? (s.set(t.key, o.mutation.getFieldMask()), kC(o.mutation, t, o.mutation.getFieldMask(), YE.now())) : s.set(t.key, kS.empty()) })), this.recalculateAndSaveOverlays(e, i).next((e => (e.forEach(((e, t) => s.set(e, t))), t.forEach(((e, t) => { var n; return o.set(e, new YT(t, null !== (n = s.get(e)) && void 0 !== n ? n : null)) })), o))) } recalculateAndSaveOverlays(e, t) { const n = tC(); let r = new SS(((e, t) => e - t)), i = iC(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next((e => { for (const i of e) i.keys().forEach((e => { const s = t.get(e); if (null === s) return; let o = n.get(e) || kS.empty(); o = i.applyToLocalView(s, o), n.set(e, o); const a = (r.get(i.batchId) || iC()).add(e); r = r.insert(i.batchId, a) })) })).next((() => { const s = [], o = r.getReverseIterator(); for (; o.hasNext();) { const r = o.getNext(), a = r.key, l = r.value, c = eC(); l.forEach((e => { if (!i.has(e)) { const r = TC(t.get(e), n.get(e)); null !== r && c.set(e, r), i = i.add(e) } })), s.push(this.documentOverlayCache.saveOverlays(e, a, c)) } return uS.waitFor(s) })).next((() => n)) } recalculateAndSaveOverlaysForDocumentKeys(e, t) { return this.remoteDocumentCache.getEntries(e, t).next((t => this.recalculateAndSaveOverlays(e, t))) } getDocumentsMatchingQuery(e, t, n, r) { return function (e) { return tS.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length }(t) ? this.getDocumentsMatchingDocumentQuery(e, t.path) : _N(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n, r) : this.getDocumentsMatchingCollectionQuery(e, t, n, r) } getNextDocuments(e, t, n, r) { return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next((i => { const s = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : uS.resolve($N()); let o = -1, a = i; return s.next((t => uS.forEach(t, ((t, n) => (o < n.largestBatchId && (o = n.largestBatchId), i.get(t) ? uS.resolve() : this.remoteDocumentCache.getEntry(e, t).next((e => { a = a.insert(t, e) }))))).next((() => this.populateOverlays(e, t, i))).next((() => this.computeViews(e, a, t, iC()))).next((e => ({ batchId: o, changes: ZN(e) }))))) })) } getDocumentsMatchingDocumentQuery(e, t) { return this.getDocument(e, new tS(t)).next((e => { let t = XN(); return e.isFoundDocument() && (t = t.insert(e.key, e)), t })) } getDocumentsMatchingCollectionGroupQuery(e, t, n, r) { const i = t.collectionGroup; let s = XN(); return this.indexManager.getCollectionParents(e, i).next((o => uS.forEach(o, (o => { const a = function (e, t) { return new IN(t, null, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) }(t, o.child(i)); return this.getDocumentsMatchingCollectionQuery(e, a, n, r).next((e => { e.forEach(((e, t) => { s = s.insert(e, t) })) })) })).next((() => s)))) } getDocumentsMatchingCollectionQuery(e, t, n, r) { let i; return this.documentOverlayCache.getOverlaysForCollection(e, t.path, n.largestBatchId).next((s => (i = s, this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, i, r)))).next((e => { i.forEach(((t, n) => { const r = n.getKey(); null === e.get(r) && (e = e.insert(r, rN.newInvalidDocument(r))) })); let n = XN(); return e.forEach(((e, r) => { const s = i.get(e); void 0 !== s && kC(s.mutation, r, kS.empty(), YE.now()), qN(t, r) && (n = n.insert(e, r)) })), n })) } } class XT { constructor(e) { this.serializer = e, this.cr = new Map, this.lr = new Map } getBundleMetadata(e, t) { return uS.resolve(this.cr.get(t)) } saveBundleMetadata(e, t) { return this.cr.set(t.id, function (e) { return { id: e.id, version: e.version, createTime: gT(e.createTime) } }(t)), uS.resolve() } getNamedQuery(e, t) { return uS.resolve(this.lr.get(t)) } saveNamedQuery(e, t) { return this.lr.set(t.name, function (e) { return { name: e.name, query: zT(e.bundledQuery), readTime: gT(e.readTime) } }(t)), uS.resolve() } } class ZT { constructor() { this.overlays = new SS(tS.comparator), this.hr = new Map } getOverlay(e, t) { return uS.resolve(this.overlays.get(t)) } getOverlays(e, t) { const n = $N(); return uS.forEach(t, (t => this.getOverlay(e, t).next((e => { null !== e && n.set(t, e) })))).next((() => n)) } saveOverlays(e, t, n) { return n.forEach(((n, r) => { this.ht(e, t, r) })), uS.resolve() } removeOverlaysForBatchId(e, t, n) { const r = this.hr.get(n); return void 0 !== r && (r.forEach((e => this.overlays = this.overlays.remove(e))), this.hr.delete(n)), uS.resolve() } getOverlaysForCollection(e, t, n) { const r = $N(), i = t.length + 1, s = new tS(t.child("")), o = this.overlays.getIteratorFrom(s); for (; o.hasNext();) { const e = o.getNext().value, s = e.getKey(); if (!t.isPrefixOf(s.path)) break; s.path.length === i && e.largestBatchId > n && r.set(e.getKey(), e) } return uS.resolve(r) } getOverlaysForCollectionGroup(e, t, n, r) { let i = new SS(((e, t) => e - t)); const s = this.overlays.getIterator(); for (; s.hasNext();) { const e = s.getNext().value; if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) { let t = i.get(e.largestBatchId); null === t && (t = $N(), i = i.insert(e.largestBatchId, t)), t.set(e.getKey(), e) } } const o = $N(), a = i.getIterator(); for (; a.hasNext() && (a.getNext().value.forEach(((e, t) => o.set(e, t))), !(o.size() >= r));); return uS.resolve(o) } ht(e, t, n) { const r = this.overlays.get(n.key); if (null !== r) { const e = this.hr.get(r.largestBatchId).delete(n.key); this.hr.set(r.largestBatchId, e) } this.overlays = this.overlays.insert(n.key, new BC(t, n)); let i = this.hr.get(t); void 0 === i && (i = iC(), this.hr.set(t, i)), this.hr.set(t, i.add(n.key)) } } class $T { constructor() { this.Pr = new TS(eA.Ir), this.Tr = new TS(eA.Er) } isEmpty() { return this.Pr.isEmpty() } addReference(e, t) { const n = new eA(e, t); this.Pr = this.Pr.add(n), this.Tr = this.Tr.add(n) } dr(e, t) { e.forEach((e => this.addReference(e, t))) } removeReference(e, t) { this.Ar(new eA(e, t)) } Rr(e, t) { e.forEach((e => this.removeReference(e, t))) } Vr(e) { const t = new tS(new ZE([])), n = new eA(t, e), r = new eA(t, e + 1), i = []; return this.Tr.forEachInRange([n, r], (e => { this.Ar(e), i.push(e.key) })), i } mr() { this.Pr.forEach((e => this.Ar(e))) } Ar(e) { this.Pr = this.Pr.delete(e), this.Tr = this.Tr.delete(e) } gr(e) { const t = new tS(new ZE([])), n = new eA(t, e), r = new eA(t, e + 1); let i = iC(); return this.Tr.forEachInRange([n, r], (e => { i = i.add(e.key) })), i } containsKey(e) { const t = new eA(e, 0), n = this.Pr.firstAfterOrEqual(t); return null !== n && e.isEqual(n.key) } } class eA { constructor(e, t) { this.key = e, this.pr = t } static Ir(e, t) { return tS.comparator(e.key, t.key) || GE(e.pr, t.pr) } static Er(e, t) { return GE(e.pr, t.pr) || tS.comparator(e.key, t.key) } } class tA { constructor(e, t) { this.indexManager = e, this.referenceDelegate = t, this.mutationQueue = [], this.yr = 1, this.wr = new TS(eA.Ir) } checkEmpty(e) { return uS.resolve(0 === this.mutationQueue.length) } addMutationBatch(e, t, n, r) { const i = this.yr; this.yr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]; const s = new FC(i, t, n, r); this.mutationQueue.push(s); for (const o of r) this.wr = this.wr.add(new eA(o.key, i)), this.indexManager.addToCollectionParentIndex(e, o.key.path.popLast()); return uS.resolve(s) } lookupMutationBatch(e, t) { return uS.resolve(this.Sr(t)) } getNextMutationBatchAfterBatchId(e, t) { const n = t + 1, r = this.br(n), i = r < 0 ? 0 : r; return uS.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null) } getHighestUnacknowledgedBatchId() { return uS.resolve(0 === this.mutationQueue.length ? -1 : this.yr - 1) } getAllMutationBatches(e) { return uS.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(e, t) { const n = new eA(t, 0), r = new eA(t, Number.POSITIVE_INFINITY), i = []; return this.wr.forEachInRange([n, r], (e => { const t = this.Sr(e.pr); i.push(t) })), uS.resolve(i) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let n = new TS(GE); return t.forEach((e => { const t = new eA(e, 0), r = new eA(e, Number.POSITIVE_INFINITY); this.wr.forEachInRange([t, r], (e => { n = n.add(e.pr) })) })), uS.resolve(this.Dr(n)) } getAllMutationBatchesAffectingQuery(e, t) { const n = t.path, r = n.length + 1; let i = n; tS.isDocumentKey(i) || (i = i.child("")); const s = new eA(new tS(i), 0); let o = new TS(GE); return this.wr.forEachWhile((e => { const t = e.key.path; return !!n.isPrefixOf(t) && (t.length === r && (o = o.add(e.pr)), !0) }), s), uS.resolve(this.Dr(o)) } Dr(e) { const t = []; return e.forEach((e => { const n = this.Sr(e); null !== n && t.push(n) })), t } removeMutationBatch(e, t) { RE(0 === this.Cr(t.batchId, "removed")), this.mutationQueue.shift(); let n = this.wr; return uS.forEach(t.mutations, (r => { const i = new eA(r.key, t.batchId); return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(e, r.key) })).next((() => { this.wr = n })) } Mn(e) { } containsKey(e, t) { const n = new eA(t, 0), r = this.wr.firstAfterOrEqual(n); return uS.resolve(t.isEqual(r && r.key)) } performConsistencyCheck(e) { return this.mutationQueue.length, uS.resolve() } Cr(e, t) { return this.br(e) } br(e) { return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId } Sr(e) { const t = this.br(e); return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t] } } class nA { constructor(e) { this.vr = e, this.docs = new SS(tS.comparator), this.size = 0 } setIndexManager(e) { this.indexManager = e } addEntry(e, t) { const n = t.key, r = this.docs.get(n), i = r ? r.size : 0, s = this.vr(t); return this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: s }), this.size += s - i, this.indexManager.addToCollectionParentIndex(e, n.path.popLast()) } removeEntry(e) { const t = this.docs.get(e); t && (this.docs = this.docs.remove(e), this.size -= t.size) } getEntry(e, t) { const n = this.docs.get(t); return uS.resolve(n ? n.document.mutableCopy() : rN.newInvalidDocument(t)) } getEntries(e, t) { let n = YN(); return t.forEach((e => { const t = this.docs.get(e); n = n.insert(e, t ? t.document.mutableCopy() : rN.newInvalidDocument(e)) })), uS.resolve(n) } getDocumentsMatchingQuery(e, t, n, r) { let i = YN(); const s = t.path, o = new tS(s.child("")), a = this.docs.getIteratorFrom(o); for (; a.hasNext();) { const { key: e, value: { document: o } } = a.getNext(); if (!s.isPrefixOf(e.path)) break; e.path.length > s.length + 1 || oS(iS(o), n) <= 0 || (r.has(o.key) || qN(t, o)) && (i = i.insert(o.key, o.mutableCopy())) } return uS.resolve(i) } getAllFromCollectionGroup(e, t, n, r) { IE() } Fr(e, t) { return uS.forEach(this.docs, (e => t(e))) } newChangeBuffer(e) { return new rA(this) } getSize(e) { return uS.resolve(this.size) } } class rA extends QT { constructor(e) { super(), this.ar = e } applyChanges(e) { const t = []; return this.changes.forEach(((n, r) => { r.isValidDocument() ? t.push(this.ar.addEntry(e, r)) : this.ar.removeEntry(n) })), uS.waitFor(t) } getFromCache(e, t) { return this.ar.getEntry(e, t) } getAllFromCache(e, t) { return this.ar.getEntries(e, t) } } class iA { constructor(e) { this.persistence = e, this.Mr = new GN((e => kN(e)), jN), this.lastRemoteSnapshotVersion = JE.min(), this.highestTargetId = 0, this.Or = 0, this.Nr = new $T, this.targetCount = 0, this.Lr = GT.Nn() } forEachTarget(e, t) { return this.Mr.forEach(((e, n) => t(n))), uS.resolve() } getLastRemoteSnapshotVersion(e) { return uS.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(e) { return uS.resolve(this.Or) } allocateTargetId(e) { return this.highestTargetId = this.Lr.next(), uS.resolve(this.highestTargetId) } setTargetsMetadata(e, t, n) { return n && (this.lastRemoteSnapshotVersion = n), t > this.Or && (this.Or = t), uS.resolve() } qn(e) { this.Mr.set(e.target, e); const t = e.targetId; t > this.highestTargetId && (this.Lr = new GT(t), this.highestTargetId = t), e.sequenceNumber > this.Or && (this.Or = e.sequenceNumber) } addTargetData(e, t) { return this.qn(t), this.targetCount += 1, uS.resolve() } updateTargetData(e, t) { return this.qn(t), uS.resolve() } removeTargetData(e, t) { return this.Mr.delete(t.target), this.Nr.Vr(t.targetId), this.targetCount -= 1, uS.resolve() } removeTargets(e, t, n) { let r = 0; const i = []; return this.Mr.forEach(((s, o) => { o.sequenceNumber <= t && null === n.get(o.targetId) && (this.Mr.delete(s), i.push(this.removeMatchingKeysForTargetId(e, o.targetId)), r++) })), uS.waitFor(i).next((() => r)) } getTargetCount(e) { return uS.resolve(this.targetCount) } getTargetData(e, t) { const n = this.Mr.get(t) || null; return uS.resolve(n) } addMatchingKeys(e, t, n) { return this.Nr.dr(t, n), uS.resolve() } removeMatchingKeys(e, t, n) { this.Nr.Rr(t, n); const r = this.persistence.referenceDelegate, i = []; return r && t.forEach((t => { i.push(r.markPotentiallyOrphaned(e, t)) })), uS.waitFor(i) } removeMatchingKeysForTargetId(e, t) { return this.Nr.Vr(t), uS.resolve() } getMatchingKeysForTargetId(e, t) { const n = this.Nr.gr(t); return uS.resolve(n) } containsKey(e, t) { return uS.resolve(this.Nr.containsKey(t)) } } class sA { constructor(e, t) { this.Br = {}, this.overlays = {}, this.kr = new fS(0), this.qr = !1, this.qr = !0, this.referenceDelegate = e(this), this.Qr = new iA(this), this.indexManager = new HT, this.remoteDocumentCache = function (e) { return new nA(e) }((e => this.referenceDelegate.Kr(e))), this.serializer = new VT(t), this.$r = new XT(this.serializer) } start() { return Promise.resolve() } shutdown() { return this.qr = !1, Promise.resolve() } get started() { return this.qr } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(e) { return this.indexManager } getDocumentOverlayCache(e) { let t = this.overlays[e.toKey()]; return t || (t = new ZT, this.overlays[e.toKey()] = t), t } getMutationQueue(e, t) { let n = this.Br[e.toKey()]; return n || (n = new tA(t, this.referenceDelegate), this.Br[e.toKey()] = n), n } getTargetCache() { return this.Qr } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.$r } runTransaction(e, t, n) { AE("MemoryPersistence", "Starting transaction:", e); const r = new oA(this.kr.next()); return this.referenceDelegate.Ur(), n(r).next((e => this.referenceDelegate.Wr(r).next((() => e)))).toPromise().then((e => (r.raiseOnCommittedEvent(), e))) } Gr(e, t) { return uS.or(Object.values(this.Br).map((n => () => n.containsKey(e, t)))) } } class oA extends lS { constructor(e) { super(), this.currentSequenceNumber = e } } class aA { constructor(e) { this.persistence = e, this.zr = new $T, this.jr = null } static Hr(e) { return new aA(e) } get Jr() { if (this.jr) return this.jr; throw IE() } addReference(e, t, n) { return this.zr.addReference(n, t), this.Jr.delete(n.toString()), uS.resolve() } removeReference(e, t, n) { return this.zr.removeReference(n, t), this.Jr.add(n.toString()), uS.resolve() } markPotentiallyOrphaned(e, t) { return this.Jr.add(t.toString()), uS.resolve() } removeTarget(e, t) { this.zr.Vr(t.targetId).forEach((e => this.Jr.add(e.toString()))); const n = this.persistence.getTargetCache(); return n.getMatchingKeysForTargetId(e, t.targetId).next((e => { e.forEach((e => this.Jr.add(e.toString()))) })).next((() => n.removeTargetData(e, t))) } Ur() { this.jr = new Set } Wr(e) { const t = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return uS.forEach(this.Jr, (n => { const r = tS.fromPath(n); return this.Yr(e, r).next((e => { e || t.removeEntry(r, JE.min()) })) })).next((() => (this.jr = null, t.apply(e)))) } updateLimboDocument(e, t) { return this.Yr(e, t).next((e => { e ? this.Jr.delete(t.toString()) : this.Jr.add(t.toString()) })) } Kr(e) { return 0 } Yr(e, t) { return uS.or([() => uS.resolve(this.zr.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Gr(e, t)]) } } class lA { constructor(e, t, n, r) { this.targetId = e, this.fromCache = t, this.qi = n, this.Qi = r } static Ki(e, t) { let n = iC(), r = iC(); for (const i of t.docChanges) switch (i.type) { case 0: n = n.add(i.doc.key); break; case 1: r = r.add(i.doc.key) }return new lA(e, t.fromCache, n, r) } } class cA { constructor() { this._documentReadCount = 0 } get documentReadCount() { return this._documentReadCount } incrementDocumentReadCount(e) { this._documentReadCount += e } } class uA { constructor() { this.$i = !1, this.Ui = !1, this.Wi = 100, this.Gi = Av() ? 8 : dS(Tv()) > 0 ? 6 : 4 } initialize(e, t) { this.zi = e, this.indexManager = t, this.$i = !0 } getDocumentsMatchingQuery(e, t, n, r) { const i = { result: null }; return this.ji(e, t).next((e => { i.result = e })).next((() => { if (!i.result) return this.Hi(e, t, r, n).next((e => { i.result = e })) })).next((() => { if (i.result) return; const n = new cA; return this.Ji(e, t, n).next((r => { if (i.result = r, this.Ui) return this.Yi(e, t, n, r.size) })) })).next((() => i.result)) } Yi(e, t, n, r) { return n.documentReadCount < this.Wi ? (TE() <= Wv.DEBUG && AE("QueryEngine", "SDK will not create cache indexes for query:", zN(t), "since it only creates cache indexes for collection contains", "more than or equal to", this.Wi, "documents"), uS.resolve()) : (TE() <= Wv.DEBUG && AE("QueryEngine", "Query:", zN(t), "scans", n.documentReadCount, "local documents and returns", r, "documents as results."), n.documentReadCount > this.Gi * r ? (TE() <= Wv.DEBUG && AE("QueryEngine", "The SDK decides to create cache indexes for query:", zN(t), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(e, LN(t))) : uS.resolve()) } ji(e, t) { if (DN(t)) return uS.resolve(null); let n = LN(t); return this.indexManager.getIndexType(e, n).next((r => 0 === r ? null : (null !== t.limit && 1 === r && (t = UN(t, null, "F"), n = LN(t)), this.indexManager.getDocumentsMatchingTarget(e, n).next((r => { const i = iC(...r); return this.zi.getDocuments(e, i).next((r => this.indexManager.getMinOffset(e, n).next((n => { const s = this.Zi(t, r); return this.Xi(t, s, i, n.readTime) ? this.ji(e, UN(t, null, "F")) : this.es(e, s, t, n) })))) }))))) } Hi(e, t, n, r) { return DN(t) || r.isEqual(JE.min()) ? uS.resolve(null) : this.zi.getDocuments(e, n).next((i => { const s = this.Zi(t, i); return this.Xi(t, s, n, r) ? uS.resolve(null) : (TE() <= Wv.DEBUG && AE("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), zN(t)), this.es(e, s, t, rS(r, -1)).next((e => e))) })) } Zi(e, t) { let n = new TS(WN(e)); return t.forEach(((t, r) => { qN(e, r) && (n = n.add(r)) })), n } Xi(e, t, n, r) { if (null === e.limit) return !1; if (n.size !== t.size) return !0; const i = "F" === e.limitType ? t.last() : t.first(); return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0) } Ji(e, t, n) { return TE() <= Wv.DEBUG && AE("QueryEngine", "Using full collection scan to execute query:", zN(t)), this.zi.getDocumentsMatchingQuery(e, t, sS.min(), n) } es(e, t, n, r) { return this.zi.getDocumentsMatchingQuery(e, n, r).next((e => (t.forEach((t => { e = e.insert(t.key, t) })), e))) } } class dA { constructor(e, t, n, r) { this.persistence = e, this.ts = t, this.serializer = r, this.ns = new SS(GE), this.rs = new GN((e => kN(e)), jN), this.ss = new Map, this.os = e.getRemoteDocumentCache(), this.Qr = e.getTargetCache(), this.$r = e.getBundleCache(), this._s(n) } _s(e) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new JT(this.os, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.os.setIndexManager(this.indexManager), this.ts.initialize(this.localDocuments, this.indexManager) } collectGarbage(e) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (t => e.collect(t, this.ns))) } } function hA(e, t, n, r) { return new dA(e, t, n, r) } async function fA(e, t) { const n = OE(e); return await n.persistence.runTransaction("Handle user change", "readonly", (e => { let r; return n.mutationQueue.getAllMutationBatches(e).next((i => (r = i, n._s(t), n.mutationQueue.getAllMutationBatches(e)))).next((t => { const i = [], s = []; let o = iC(); for (const e of r) { i.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } for (const e of t) { s.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } return n.localDocuments.getDocuments(e, o).next((e => ({ us: e, removedBatchIds: i, addedBatchIds: s }))) })) })) } function pA(e) { const t = OE(e); return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (e => t.Qr.getLastRemoteSnapshotVersion(e))) } function mA(e, t, n) { let r = iC(), i = iC(); return n.forEach((e => r = r.add(e))), t.getEntries(e, r).next((e => { let r = YN(); return n.forEach(((n, s) => { const o = e.get(n); s.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n)), s.isNoDocument() && s.version.isEqual(JE.min()) ? (t.removeEntry(n, s.readTime), r = r.insert(n, s)) : !o.isValidDocument() || s.version.compareTo(o.version) > 0 || 0 === s.version.compareTo(o.version) && o.hasPendingWrites ? (t.addEntry(s), r = r.insert(n, s)) : AE("LocalStore", "Ignoring outdated watch update for ", n, ". Current version:", o.version, " Watch version:", s.version) })), { cs: r, ls: i } })) } function gA(e, t) { const n = OE(e); return n.persistence.runTransaction("Get next mutation batch", "readonly", (e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t)))) } function vA(e, t) { const n = OE(e); return n.persistence.runTransaction("Allocate target", "readwrite", (e => { let r; return n.Qr.getTargetData(e, t).next((i => i ? (r = i, uS.resolve(r)) : n.Qr.allocateTargetId(e).next((i => (r = new BT(t, i, "TargetPurposeListen", e.currentSequenceNumber), n.Qr.addTargetData(e, r).next((() => r))))))) })).then((e => { const r = n.ns.get(e.targetId); return (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (n.ns = n.ns.insert(e.targetId, e), n.rs.set(t, e.targetId)), e })) } async function yA(e, t, n) { const r = OE(e), i = r.ns.get(t), s = n ? "readwrite" : "readwrite-primary"; try { n || await r.persistence.runTransaction("Release target", s, (e => r.persistence.referenceDelegate.removeTarget(e, i))) } catch (e) { if (!hS(e)) throw e; AE("LocalStore", "Failed to update sequence numbers for target ".concat(t, ": ").concat(e)) } r.ns = r.ns.remove(t), r.rs.delete(i.target) } function bA(e, t, n) { const r = OE(e); let i = JE.min(), s = iC(); return r.persistence.runTransaction("Execute query", "readwrite", (e => function (e, t, n) { const r = OE(e), i = r.rs.get(n); return void 0 !== i ? uS.resolve(r.ns.get(i)) : r.Qr.getTargetData(t, n) }(r, e, LN(t)).next((t => { if (t) return i = t.lastLimboFreeSnapshotVersion, r.Qr.getMatchingKeysForTargetId(e, t.targetId).next((e => { s = e })) })).next((() => r.ts.getDocumentsMatchingQuery(e, t, n ? i : JE.min(), n ? s : iC()))).next((e => (wA(r, HN(t), e), { documents: e, hs: s }))))) } function wA(e, t, n) { let r = e.ss.get(t) || JE.min(); n.forEach(((e, t) => { t.readTime.compareTo(r) > 0 && (r = t.readTime) })), e.ss.set(t, r) } class xA { constructor() { this.activeTargetIds = oC() } As(e) { this.activeTargetIds = this.activeTargetIds.add(e) } Rs(e) { this.activeTargetIds = this.activeTargetIds.delete(e) } ds() { const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(e) } } class EA { constructor() { this.no = new xA, this.ro = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(e) { } updateMutationState(e, t, n) { } addLocalQueryTarget(e) { return this.no.As(e), this.ro[e] || "not-current" } updateQueryState(e, t, n) { this.ro[e] = t } removeLocalQueryTarget(e) { this.no.Rs(e) } isLocalQueryTarget(e) { return this.no.activeTargetIds.has(e) } clearQueryState(e) { delete this.ro[e] } getAllActiveQueryTargets() { return this.no.activeTargetIds } isActiveQueryTarget(e) { return this.no.activeTargetIds.has(e) } start() { return this.no = new xA, Promise.resolve() } handleUserChange(e, t, n) { } setOnlineState(e) { } shutdown() { } writeSequenceNumber(e) { } notifyBundleLoaded(e) { } } class SA { io(e) { } shutdown() { } } class NA { constructor() { this.so = () => this.oo(), this._o = () => this.ao(), this.uo = [], this.co() } io(e) { this.uo.push(e) } shutdown() { window.removeEventListener("online", this.so), window.removeEventListener("offline", this._o) } co() { window.addEventListener("online", this.so), window.addEventListener("offline", this._o) } oo() { AE("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const e of this.uo) e(0) } ao() { AE("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const e of this.uo) e(1) } static D() { return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener } } let CA = null; function TA() { return null === CA ? CA = 268435456 + Math.round(2147483648 * Math.random()) : CA++, "0x" + CA.toString(16) } const AA = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery" }; class kA { constructor(e) { this.lo = e.lo, this.ho = e.ho } Po(e) { this.Io = e } To(e) { this.Eo = e } Ao(e) { this.Ro = e } onMessage(e) { this.Vo = e } close() { this.ho() } send(e) { this.lo(e) } mo() { this.Io() } fo() { this.Eo() } po(e) { this.Ro(e) } yo(e) { this.Vo(e) } } const jA = "WebChannelConnection"; class PA extends class { constructor(e) { this.databaseInfo = e, this.databaseId = e.databaseId; const t = e.ssl ? "https" : "http", n = encodeURIComponent(this.databaseId.projectId), r = encodeURIComponent(this.databaseId.database); this.wo = t + "://" + e.host, this.So = "projects/".concat(n, "/databases/").concat(r), this.bo = "(default)" === this.databaseId.database ? "project_id=".concat(n) : "project_id=".concat(n, "&database_id=").concat(r) } get Do() { return !1 } Co(e, t, n, r, i) { const s = TA(), o = this.vo(e, t.toUriEncodedString()); AE("RestConnection", "Sending RPC '".concat(e, "' ").concat(s, ":"), o, n); const a = { "google-cloud-resource-prefix": this.So, "x-goog-request-params": this.bo }; return this.Fo(a, r, i), this.Mo(e, o, a, n).then((t => (AE("RestConnection", "Received RPC '".concat(e, "' ").concat(s, ": "), t), t)), (t => { throw jE("RestConnection", "RPC '".concat(e, "' ").concat(s, " failed with error: "), t, "url: ", o, "request:", n), t })) } xo(e, t, n, r, i, s) { return this.Co(e, t, n, r, i) } Fo(e, t, n) { e["X-Goog-Api-Client"] = "gl-js/ fire/" + NE, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach(((t, n) => e[n] = t)), n && n.headers.forEach(((t, n) => e[n] = t)) } vo(e, t) { const n = AA[e]; return "".concat(this.wo, "/v1/").concat(t, ":").concat(n) } terminate() { } }{ constructor(e) { super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions } Mo(e, t, n, r) { const i = TA(); return new Promise(((s, o) => { const a = new dE; a.setWithCredentials(!0), a.listenOnce(pE.COMPLETE, (() => { try { switch (a.getLastErrorCode()) { case mE.NO_ERROR: const t = a.getResponseJson(); AE(jA, "XHR for RPC '".concat(e, "' ").concat(i, " received:"), JSON.stringify(t)), s(t); break; case mE.TIMEOUT: AE(jA, "RPC '".concat(e, "' ").concat(i, " timed out")), o(new _E(DE.DEADLINE_EXCEEDED, "Request time out")); break; case mE.HTTP_ERROR: const n = a.getStatus(); if (AE(jA, "RPC '".concat(e, "' ").concat(i, " failed with status:"), n, "response text:", a.getResponseText()), n > 0) { let e = a.getResponseJson(); Array.isArray(e) && (e = e[0]); const t = null == e ? void 0 : e.error; if (t && t.status && t.message) { const e = function (e) { const t = e.toLowerCase().replace(/_/g, "-"); return Object.values(DE).indexOf(t) >= 0 ? t : DE.UNKNOWN }(t.status); o(new _E(e, t.message)) } else o(new _E(DE.UNKNOWN, "Server responded with status " + a.getStatus())) } else o(new _E(DE.UNAVAILABLE, "Connection failed.")); break; default: IE() } } finally { AE(jA, "RPC '".concat(e, "' ").concat(i, " completed.")) } })); const l = JSON.stringify(r); AE(jA, "RPC '".concat(e, "' ").concat(i, " sending request:"), r), a.send(t, "POST", l, n, 15) })) } Oo(e, t, n) { const r = TA(), i = [this.wo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], s = bE(), o = yE(), a = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: "projects/".concat(this.databaseId.projectId, "/databases/").concat(this.databaseId.database) }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }, l = this.longPollingOptions.timeoutSeconds; void 0 !== l && (a.longPollingTimeout = Math.round(1e3 * l)), this.useFetchStreams && (a.xmlHttpFactory = new hE({})), this.Fo(a.initMessageHeaders, t, n), a.encodeInitMessageHeaders = !0; const c = i.join(""); AE(jA, "Creating RPC '".concat(e, "' stream ").concat(r, ": ").concat(c), a); const u = s.createWebChannel(c, a); let d = !1, h = !1; const f = new kA({ lo: t => { h ? AE(jA, "Not sending because RPC '".concat(e, "' stream ").concat(r, " is closed:"), t) : (d || (AE(jA, "Opening RPC '".concat(e, "' stream ").concat(r, " transport.")), u.open(), d = !0), AE(jA, "RPC '".concat(e, "' stream ").concat(r, " sending:"), t), u.send(t)) }, ho: () => u.close() }), p = (e, t, n) => { e.listen(t, (e => { try { n(e) } catch (e) { setTimeout((() => { throw e }), 0) } })) }; return p(u, fE.EventType.OPEN, (() => { h || (AE(jA, "RPC '".concat(e, "' stream ").concat(r, " transport opened.")), f.mo()) })), p(u, fE.EventType.CLOSE, (() => { h || (h = !0, AE(jA, "RPC '".concat(e, "' stream ").concat(r, " transport closed")), f.po()) })), p(u, fE.EventType.ERROR, (t => { h || (h = !0, jE(jA, "RPC '".concat(e, "' stream ").concat(r, " transport errored:"), t), f.po(new _E(DE.UNAVAILABLE, "The operation could not be completed"))) })), p(u, fE.EventType.MESSAGE, (t => { var n; if (!h) { const i = t.data[0]; RE(!!i); const s = i, o = s.error || (null === (n = s[0]) || void 0 === n ? void 0 : n.error); if (o) { AE(jA, "RPC '".concat(e, "' stream ").concat(r, " received error:"), o); const t = o.status; let n = function (e) { const t = zC[e]; if (void 0 !== t) return WC(t) }(t), i = o.message; void 0 === n && (n = DE.INTERNAL, i = "Unknown error status: " + t + " with message " + o.message), h = !0, f.po(new _E(n, i)), u.close() } else AE(jA, "RPC '".concat(e, "' stream ").concat(r, " received:"), i), f.yo(i) } })), p(o, vE.STAT_EVENT, (t => { t.stat === gE.PROXY ? AE(jA, "RPC '".concat(e, "' stream ").concat(r, " detected buffering proxy")) : t.stat === gE.NOPROXY && AE(jA, "RPC '".concat(e, "' stream ").concat(r, " detected no buffering proxy")) })), setTimeout((() => { f.fo() }), 0), f } } function IA() { return "undefined" != typeof document ? document : null } function RA(e) { return new dT(e, !0) } class OA { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1.5, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 6e4; this.oi = e, this.timerId = t, this.No = n, this.Lo = r, this.Bo = i, this.ko = 0, this.qo = null, this.Qo = Date.now(), this.reset() } reset() { this.ko = 0 } Ko() { this.ko = this.Bo } $o(e) { this.cancel(); const t = Math.floor(this.ko + this.Uo()), n = Math.max(0, Date.now() - this.Qo), r = Math.max(0, t - n); r > 0 && AE("ExponentialBackoff", "Backing off for ".concat(r, " ms (base delay: ").concat(this.ko, " ms, delay with jitter: ").concat(t, " ms, last attempt: ").concat(n, " ms ago)")), this.qo = this.oi.enqueueAfterDelay(this.timerId, r, (() => (this.Qo = Date.now(), e()))), this.ko *= this.Lo, this.ko < this.No && (this.ko = this.No), this.ko > this.Bo && (this.ko = this.Bo) } Wo() { null !== this.qo && (this.qo.skipDelay(), this.qo = null) } cancel() { null !== this.qo && (this.qo.cancel(), this.qo = null) } Uo() { return (Math.random() - .5) * this.ko } } class DA { constructor(e, t, n, r, i, s, o, a) { this.oi = e, this.Go = n, this.zo = r, this.connection = i, this.authCredentialsProvider = s, this.appCheckCredentialsProvider = o, this.listener = a, this.state = 0, this.jo = 0, this.Ho = null, this.Jo = null, this.stream = null, this.Yo = new OA(e, t) } Zo() { return 1 === this.state || 5 === this.state || this.Xo() } Xo() { return 2 === this.state || 3 === this.state } start() { 4 !== this.state ? this.auth() : this.e_() } async stop() { this.Zo() && await this.close(0) } t_() { this.state = 0, this.Yo.reset() } n_() { this.Xo() && null === this.Ho && (this.Ho = this.oi.enqueueAfterDelay(this.Go, 6e4, (() => this.r_()))) } i_(e) { this.s_(), this.stream.send(e) } async r_() { if (this.Xo()) return this.close(0) } s_() { this.Ho && (this.Ho.cancel(), this.Ho = null) } o_() { this.Jo && (this.Jo.cancel(), this.Jo = null) } async close(e, t) { this.s_(), this.o_(), this.Yo.cancel(), this.jo++, 4 !== e ? this.Yo.reset() : t && t.code === DE.RESOURCE_EXHAUSTED ? (kE(t.toString()), kE("Using maximum backoff delay to prevent overloading the backend."), this.Yo.Ko()) : t && t.code === DE.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.__(), this.stream.close(), this.stream = null), this.state = e, await this.listener.Ao(t) } __() { } auth() { this.state = 1; const e = this.a_(this.jo), t = this.jo; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then((e => { let [n, r] = e; this.jo === t && this.u_(n, r) }), (t => { e((() => { const e = new _E(DE.UNKNOWN, "Fetching auth token failed: " + t.message); return this.c_(e) })) })) } u_(e, t) { const n = this.a_(this.jo); this.stream = this.l_(e, t), this.stream.Po((() => { n((() => this.listener.Po())) })), this.stream.To((() => { n((() => (this.state = 2, this.Jo = this.oi.enqueueAfterDelay(this.zo, 1e4, (() => (this.Xo() && (this.state = 3), Promise.resolve()))), this.listener.To()))) })), this.stream.Ao((e => { n((() => this.c_(e))) })), this.stream.onMessage((e => { n((() => this.onMessage(e))) })) } e_() { this.state = 5, this.Yo.$o((async () => { this.state = 0, this.start() })) } c_(e) { return AE("PersistentStream", "close with error: ".concat(e)), this.stream = null, this.close(4, e) } a_(e) { return t => { this.oi.enqueueAndForget((() => this.jo === e ? t() : (AE("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))) } } } class _A extends DA { constructor(e, t, n, r, i, s) { super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i } l_(e, t) { return this.connection.Oo("Listen", e, t) } onMessage(e) { this.Yo.reset(); const t = function (e, t) { let n; if ("targetChange" in t) { t.targetChange; const r = function (e) { return "NO_CHANGE" === e ? 0 : "ADD" === e ? 1 : "REMOVE" === e ? 2 : "CURRENT" === e ? 3 : "RESET" === e ? 4 : IE() }(t.targetChange.targetChangeType || "NO_CHANGE"), i = t.targetChange.targetIds || [], s = function (e, t) { return e.useProto3Json ? (RE(void 0 === t || "string" == typeof t), PS.fromBase64String(t || "")) : (RE(void 0 === t || t instanceof Buffer || t instanceof Uint8Array), PS.fromUint8Array(t || new Uint8Array)) }(e, t.targetChange.resumeToken), o = t.targetChange.cause, a = o && function (e) { const t = void 0 === e.code ? DE.UNKNOWN : WC(e.code); return new _E(t, e.message || "") }(o); n = new rT(r, i, s, a || null) } else if ("documentChange" in t) { t.documentChange; const r = t.documentChange; r.document, r.document.name, r.document.updateTime; const i = xT(e, r.document.name), s = gT(r.document.updateTime), o = r.document.createTime ? gT(r.document.createTime) : JE.min(), a = new tN({ mapValue: { fields: r.document.fields } }), l = rN.newFoundDocument(i, s, o, a), c = r.targetIds || [], u = r.removedTargetIds || []; n = new tT(c, u, l.key, l) } else if ("documentDelete" in t) { t.documentDelete; const r = t.documentDelete; r.document; const i = xT(e, r.document), s = r.readTime ? gT(r.readTime) : JE.min(), o = rN.newNoDocument(i, s), a = r.removedTargetIds || []; n = new tT([], a, o.key, o) } else if ("documentRemove" in t) { t.documentRemove; const r = t.documentRemove; r.document; const i = xT(e, r.document), s = r.removedTargetIds || []; n = new tT([], s, i, null) } else { if (!("filter" in t)) return IE(); { t.filter; const e = t.filter; e.targetId; const { count: r = 0, unchangedNames: i } = e, s = new VC(r, i), o = e.targetId; n = new nT(o, s) } } return n }(this.serializer, e), n = function (e) { if (!("targetChange" in e)) return JE.min(); const t = e.targetChange; return t.targetIds && t.targetIds.length ? JE.min() : t.readTime ? gT(t.readTime) : JE.min() }(e); return this.listener.h_(t, n) } P_(e) { const t = {}; t.database = NT(this.serializer), t.addTarget = function (e, t) { let n; const r = t.target; if (n = PN(r) ? { documents: kT(e, r) } : { query: jT(e, r)._t }, n.targetId = t.targetId, t.resumeToken.approximateByteSize() > 0) { n.resumeToken = pT(e, t.resumeToken); const r = hT(e, t.expectedCount); null !== r && (n.expectedCount = r) } else if (t.snapshotVersion.compareTo(JE.min()) > 0) { n.readTime = fT(e, t.snapshotVersion.toTimestamp()); const r = hT(e, t.expectedCount); null !== r && (n.expectedCount = r) } return n }(this.serializer, e); const n = function (e, t) { const n = function (e) { switch (e) { case "TargetPurposeListen": return null; case "TargetPurposeExistenceFilterMismatch": return "existence-filter-mismatch"; case "TargetPurposeExistenceFilterMismatchBloom": return "existence-filter-mismatch-bloom"; case "TargetPurposeLimboResolution": return "limbo-document"; default: return IE() } }(t.purpose); return null == n ? null : { "goog-listen-tags": n } }(this.serializer, e); n && (t.labels = n), this.i_(t) } I_(e) { const t = {}; t.database = NT(this.serializer), t.removeTarget = e, this.i_(t) } } class MA extends DA { constructor(e, t, n, r, i, s) { super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i, this.T_ = !1 } get E_() { return this.T_ } start() { this.T_ = !1, this.lastStreamToken = void 0, super.start() } __() { this.T_ && this.d_([]) } l_(e, t) { return this.connection.Oo("Write", e, t) } onMessage(e) { if (RE(!!e.streamToken), this.lastStreamToken = e.streamToken, this.T_) { this.Yo.reset(); const t = function (e, t) { return e && e.length > 0 ? (RE(void 0 !== t), e.map((e => function (e, t) { let n = e.updateTime ? gT(e.updateTime) : gT(t); return n.isEqual(JE.min()) && (n = gT(t)), new EC(n, e.transformResults || []) }(e, t)))) : [] }(e.writeResults, e.commitTime), n = gT(e.commitTime); return this.listener.A_(n, t) } return RE(!e.writeResults || 0 === e.writeResults.length), this.T_ = !0, this.listener.R_() } V_() { const e = {}; e.database = NT(this.serializer), this.i_(e) } d_(e) { const t = { streamToken: this.lastStreamToken, writes: e.map((e => AT(this.serializer, e))) }; this.i_(t) } } class LA extends class { }{ constructor(e, t, n, r) { super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = n, this.serializer = r, this.m_ = !1 } f_() { if (this.m_) throw new _E(DE.FAILED_PRECONDITION, "The client has already been terminated.") } Co(e, t, n, r) { return this.f_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((i => { let [s, o] = i; return this.connection.Co(e, yT(t, n), r, s, o) })).catch((e => { throw "FirebaseError" === e.name ? (e.code === DE.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new _E(DE.UNKNOWN, e.toString()) })) } xo(e, t, n, r, i) { return this.f_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((s => { let [o, a] = s; return this.connection.xo(e, yT(t, n), r, o, a, i) })).catch((e => { throw "FirebaseError" === e.name ? (e.code === DE.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new _E(DE.UNKNOWN, e.toString()) })) } terminate() { this.m_ = !0, this.connection.terminate() } } class FA { constructor(e, t) { this.asyncQueue = e, this.onlineStateHandler = t, this.state = "Unknown", this.g_ = 0, this.p_ = null, this.y_ = !0 } w_() { 0 === this.g_ && (this.S_("Unknown"), this.p_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, (() => (this.p_ = null, this.b_("Backend didn't respond within 10 seconds."), this.S_("Offline"), Promise.resolve())))) } D_(e) { "Online" === this.state ? this.S_("Unknown") : (this.g_++, this.g_ >= 1 && (this.C_(), this.b_("Connection failed 1 times. Most recent error: ".concat(e.toString())), this.S_("Offline"))) } set(e) { this.C_(), this.g_ = 0, "Online" === e && (this.y_ = !1), this.S_(e) } S_(e) { e !== this.state && (this.state = e, this.onlineStateHandler(e)) } b_(e) { const t = "Could not reach Cloud Firestore backend. ".concat(e, "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend."); this.y_ ? (kE(t), this.y_ = !1) : AE("OnlineStateTracker", t) } C_() { null !== this.p_ && (this.p_.cancel(), this.p_ = null) } } class UA { constructor(e, t, n, r, i) { this.localStore = e, this.datastore = t, this.asyncQueue = n, this.remoteSyncer = {}, this.v_ = [], this.F_ = new Map, this.M_ = new Set, this.x_ = [], this.O_ = i, this.O_.io((e => { n.enqueueAndForget((async () => { QA(this) && (AE("RemoteStore", "Restarting streams for network reachability change."), await async function (e) { const t = OE(e); t.M_.add(4), await VA(t), t.N_.set("Unknown"), t.M_.delete(4), await BA(t) }(this)) })) })), this.N_ = new FA(n, r) } } async function BA(e) { if (QA(e)) for (const t of e.x_) await t(!0) } async function VA(e) { for (const t of e.x_) await t(!1) } function zA(e, t) { const n = OE(e); n.F_.has(t.targetId) || (n.F_.set(t.targetId, t), GA(n) ? KA(n) : fk(n).Xo() && HA(n, t)) } function qA(e, t) { const n = OE(e), r = fk(n); n.F_.delete(t), r.Xo() && WA(n, t), 0 === n.F_.size && (r.Xo() ? r.n_() : QA(n) && n.N_.set("Unknown")) } function HA(e, t) { if (e.L_.xe(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(JE.min()) > 0) { const n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size; t = t.withExpectedCount(n) } fk(e).P_(t) } function WA(e, t) { e.L_.xe(t), fk(e).I_(t) } function KA(e) { e.L_ = new sT({ getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t), ot: t => e.F_.get(t) || null, tt: () => e.datastore.serializer.databaseId }), fk(e).start(), e.N_.w_() } function GA(e) { return QA(e) && !fk(e).Zo() && e.F_.size > 0 } function QA(e) { return 0 === OE(e).M_.size } function YA(e) { e.L_ = void 0 } async function JA(e) { e.N_.set("Online") } async function XA(e) { e.F_.forEach(((t, n) => { HA(e, t) })) } async function ZA(e, t) { YA(e), GA(e) ? (e.N_.D_(t), KA(e)) : e.N_.set("Unknown") } async function $A(e, t, n) { if (e.N_.set("Online"), t instanceof rT && 2 === t.state && t.cause) try { await async function (e, t) { const n = t.cause; for (const r of t.targetIds) e.F_.has(r) && (await e.remoteSyncer.rejectListen(r, n), e.F_.delete(r), e.L_.removeTarget(r)) }(e, t) } catch (n) { AE("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), n), await ek(e, n) } else if (t instanceof tT ? e.L_.Ke(t) : t instanceof nT ? e.L_.He(t) : e.L_.We(t), !n.isEqual(JE.min())) try { const t = await pA(e.localStore); n.compareTo(t) >= 0 && await function (e, t) { const n = e.L_.rt(t); return n.targetChanges.forEach(((n, r) => { if (n.resumeToken.approximateByteSize() > 0) { const i = e.F_.get(r); i && e.F_.set(r, i.withResumeToken(n.resumeToken, t)) } })), n.targetMismatches.forEach(((t, n) => { const r = e.F_.get(t); if (!r) return; e.F_.set(t, r.withResumeToken(PS.EMPTY_BYTE_STRING, r.snapshotVersion)), WA(e, t); const i = new BT(r.target, t, n, r.sequenceNumber); HA(e, i) })), e.remoteSyncer.applyRemoteEvent(n) }(e, n) } catch (t) { AE("RemoteStore", "Failed to raise snapshot:", t), await ek(e, t) } } async function ek(e, t, n) { if (!hS(t)) throw t; e.M_.add(1), await VA(e), e.N_.set("Offline"), n || (n = () => pA(e.localStore)), e.asyncQueue.enqueueRetryable((async () => { AE("RemoteStore", "Retrying IndexedDB access"), await n(), e.M_.delete(1), await BA(e) })) } function tk(e, t) { return t().catch((n => ek(e, n, t))) } async function nk(e) { const t = OE(e), n = pk(t); let r = t.v_.length > 0 ? t.v_[t.v_.length - 1].batchId : -1; for (; rk(t);)try { const e = await gA(t.localStore, r); if (null === e) { 0 === t.v_.length && n.n_(); break } r = e.batchId, ik(t, e) } catch (e) { await ek(t, e) } sk(t) && ok(t) } function rk(e) { return QA(e) && e.v_.length < 10 } function ik(e, t) { e.v_.push(t); const n = pk(e); n.Xo() && n.E_ && n.d_(t.mutations) } function sk(e) { return QA(e) && !pk(e).Zo() && e.v_.length > 0 } function ok(e) { pk(e).start() } async function ak(e) { pk(e).V_() } async function lk(e) { const t = pk(e); for (const n of e.v_) t.d_(n.mutations) } async function ck(e, t, n) { const r = e.v_.shift(), i = UC.from(r, t, n); await tk(e, (() => e.remoteSyncer.applySuccessfulWrite(i))), await nk(e) } async function uk(e, t) { t && pk(e).E_ && await async function (e, t) { if (function (e) { return HC(e) && e !== DE.ABORTED }(t.code)) { const n = e.v_.shift(); pk(e).t_(), await tk(e, (() => e.remoteSyncer.rejectFailedWrite(n.batchId, t))), await nk(e) } }(e, t), sk(e) && ok(e) } async function dk(e, t) { const n = OE(e); n.asyncQueue.verifyOperationInProgress(), AE("RemoteStore", "RemoteStore received new credentials"); const r = QA(n); n.M_.add(3), await VA(n), r && n.N_.set("Unknown"), await n.remoteSyncer.handleCredentialChange(t), n.M_.delete(3), await BA(n) } async function hk(e, t) { const n = OE(e); t ? (n.M_.delete(2), await BA(n)) : t || (n.M_.add(2), await VA(n), n.N_.set("Unknown")) } function fk(e) { return e.B_ || (e.B_ = function (e, t, n) { const r = OE(e); return r.f_(), new _A(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n) }(e.datastore, e.asyncQueue, { Po: JA.bind(null, e), To: XA.bind(null, e), Ao: ZA.bind(null, e), h_: $A.bind(null, e) }), e.x_.push((async t => { t ? (e.B_.t_(), GA(e) ? KA(e) : e.N_.set("Unknown")) : (await e.B_.stop(), YA(e)) }))), e.B_ } function pk(e) { return e.k_ || (e.k_ = function (e, t, n) { const r = OE(e); return r.f_(), new MA(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n) }(e.datastore, e.asyncQueue, { Po: () => Promise.resolve(), To: ak.bind(null, e), Ao: uk.bind(null, e), R_: lk.bind(null, e), A_: ck.bind(null, e) }), e.x_.push((async t => { t ? (e.k_.t_(), await nk(e)) : (await e.k_.stop(), e.v_.length > 0 && (AE("RemoteStore", "Stopping write stream with ".concat(e.v_.length, " pending writes")), e.v_ = [])) }))), e.k_ } class mk { constructor(e, t, n, r, i) { this.asyncQueue = e, this.timerId = t, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new ME, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((e => { })) } get promise() { return this.deferred.promise } static createAndSchedule(e, t, n, r, i) { const s = Date.now() + n, o = new mk(e, t, s, r, i); return o.start(n), o } start(e) { this.timerHandle = setTimeout((() => this.handleDelayElapsed()), e) } skipDelay() { return this.handleDelayElapsed() } cancel(e) { null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new _E(DE.CANCELLED, "Operation cancelled" + (e ? ": " + e : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget((() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((e => this.deferred.resolve(e)))) : Promise.resolve())) } clearTimeout() { null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function gk(e, t) { if (kE("AsyncQueue", "".concat(t, ": ").concat(e)), hS(e)) return new _E(DE.UNAVAILABLE, "".concat(t, ": ").concat(e)); throw e } class vk { constructor(e) { this.comparator = e ? (t, n) => e(t, n) || tS.comparator(t.key, n.key) : (e, t) => tS.comparator(e.key, t.key), this.keyedMap = XN(), this.sortedSet = new SS(this.comparator) } static emptySet(e) { return new vk(e.comparator) } has(e) { return null != this.keyedMap.get(e) } get(e) { return this.keyedMap.get(e) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(e) { const t = this.keyedMap.get(e); return t ? this.sortedSet.indexOf(t) : -1 } get size() { return this.sortedSet.size } forEach(e) { this.sortedSet.inorderTraversal(((t, n) => (e(t), !1))) } add(e) { const t = this.delete(e.key); return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null)) } delete(e) { const t = this.get(e); return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this } isEqual(e) { if (!(e instanceof vk)) return !1; if (this.size !== e.size) return !1; const t = this.sortedSet.getIterator(), n = e.sortedSet.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (!e.isEqual(r)) return !1 } return !0 } toString() { const e = []; return this.forEach((t => { e.push(t.toString()) })), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)" } copy(e, t) { const n = new vk; return n.comparator = this.comparator, n.keyedMap = e, n.sortedSet = t, n } } class yk { constructor() { this.q_ = new SS(tS.comparator) } track(e) { const t = e.doc.key, n = this.q_.get(t); n ? 0 !== e.type && 3 === n.type ? this.q_ = this.q_.insert(t, e) : 3 === e.type && 1 !== n.type ? this.q_ = this.q_.insert(t, { type: n.type, doc: e.doc }) : 2 === e.type && 2 === n.type ? this.q_ = this.q_.insert(t, { type: 2, doc: e.doc }) : 2 === e.type && 0 === n.type ? this.q_ = this.q_.insert(t, { type: 0, doc: e.doc }) : 1 === e.type && 0 === n.type ? this.q_ = this.q_.remove(t) : 1 === e.type && 2 === n.type ? this.q_ = this.q_.insert(t, { type: 1, doc: n.doc }) : 0 === e.type && 1 === n.type ? this.q_ = this.q_.insert(t, { type: 2, doc: e.doc }) : IE() : this.q_ = this.q_.insert(t, e) } Q_() { const e = []; return this.q_.inorderTraversal(((t, n) => { e.push(n) })), e } } class bk { constructor(e, t, n, r, i, s, o, a, l) { this.query = e, this.docs = t, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = s, this.syncStateChanged = o, this.excludesMetadataChanges = a, this.hasCachedResults = l } static fromInitialDocuments(e, t, n, r, i) { const s = []; return t.forEach((e => { s.push({ type: 0, doc: e }) })), new bk(e, t, vk.emptySet(t), s, n, r, !0, !1, i) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(e) { if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && BN(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1; const t = this.docChanges, n = e.docChanges; if (t.length !== n.length) return !1; for (let r = 0; r < t.length; r++)if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1; return !0 } } class wk { constructor() { this.K_ = void 0, this.U_ = [] } W_() { return this.U_.some((e => e.G_())) } } class xk { constructor() { this.queries = new GN((e => VN(e)), BN), this.onlineState = "Unknown", this.z_ = new Set } } async function Ek(e, t) { const n = OE(e); let r = 3; const i = t.query; let s = n.queries.get(i); s ? !s.W_() && t.G_() && (r = 2) : (s = new wk, r = t.G_() ? 0 : 1); try { switch (r) { case 0: s.K_ = await n.onListen(i, !0); break; case 1: s.K_ = await n.onListen(i, !1); break; case 2: await n.onFirstRemoteStoreListen(i) } } catch (e) { const n = gk(e, "Initialization of query '".concat(zN(t.query), "' failed")); return void t.onError(n) } n.queries.set(i, s), s.U_.push(t), t.j_(n.onlineState), s.K_ && t.H_(s.K_) && Tk(n) } async function Sk(e, t) { const n = OE(e), r = t.query; let i = 3; const s = n.queries.get(r); if (s) { const e = s.U_.indexOf(t); e >= 0 && (s.U_.splice(e, 1), 0 === s.U_.length ? i = t.G_() ? 0 : 1 : !s.W_() && t.G_() && (i = 2)) } switch (i) { case 0: return n.queries.delete(r), n.onUnlisten(r, !0); case 1: return n.queries.delete(r), n.onUnlisten(r, !1); case 2: return n.onLastRemoteStoreUnlisten(r); default: return } } function Nk(e, t) { const n = OE(e); let r = !1; for (const i of t) { const e = i.query, t = n.queries.get(e); if (t) { for (const e of t.U_) e.H_(i) && (r = !0); t.K_ = i } } r && Tk(n) } function Ck(e, t, n) { const r = OE(e), i = r.queries.get(t); if (i) for (const s of i.U_) s.onError(n); r.queries.delete(t) } function Tk(e) { e.z_.forEach((e => { e.next() })) } var Ak, kk; (kk = Ak || (Ak = {})).J_ = "default", kk.Cache = "cache"; class jk { constructor(e, t, n) { this.query = e, this.Y_ = t, this.Z_ = !1, this.X_ = null, this.onlineState = "Unknown", this.options = n || {} } H_(e) { if (!this.options.includeMetadataChanges) { const t = []; for (const n of e.docChanges) 3 !== n.type && t.push(n); e = new bk(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults) } let t = !1; return this.Z_ ? this.ea(e) && (this.Y_.next(e), t = !0) : this.ta(e, this.onlineState) && (this.na(e), t = !0), this.X_ = e, t } onError(e) { this.Y_.error(e) } j_(e) { this.onlineState = e; let t = !1; return this.X_ && !this.Z_ && this.ta(this.X_, e) && (this.na(this.X_), t = !0), t } ta(e, t) { if (!e.fromCache) return !0; if (!this.G_()) return !0; const n = "Offline" !== t; return (!this.options.ra || !n) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t) } ea(e) { if (e.docChanges.length > 0) return !0; const t = this.X_ && this.X_.hasPendingWrites !== e.hasPendingWrites; return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges } na(e) { e = bk.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.Z_ = !0, this.Y_.next(e) } G_() { return this.options.source !== Ak.Cache } } class Pk { constructor(e) { this.key = e } } class Ik { constructor(e) { this.key = e } } class Rk { constructor(e, t) { this.query = e, this.la = t, this.ha = null, this.hasCachedResults = !1, this.current = !1, this.Pa = iC(), this.mutatedKeys = iC(), this.Ia = WN(e), this.Ta = new vk(this.Ia) } get Ea() { return this.la } da(e, t) { const n = t ? t.Aa : new yk, r = t ? t.Ta : this.Ta; let i = t ? t.mutatedKeys : this.mutatedKeys, s = r, o = !1; const a = "F" === this.query.limitType && r.size === this.query.limit ? r.last() : null, l = "L" === this.query.limitType && r.size === this.query.limit ? r.first() : null; if (e.inorderTraversal(((e, t) => { const c = r.get(e), u = qN(this.query, t) ? t : null, d = !!c && this.mutatedKeys.has(c.key), h = !!u && (u.hasLocalMutations || this.mutatedKeys.has(u.key) && u.hasCommittedMutations); let f = !1; c && u ? c.data.isEqual(u.data) ? d !== h && (n.track({ type: 3, doc: u }), f = !0) : this.Ra(c, u) || (n.track({ type: 2, doc: u }), f = !0, (a && this.Ia(u, a) > 0 || l && this.Ia(u, l) < 0) && (o = !0)) : !c && u ? (n.track({ type: 0, doc: u }), f = !0) : c && !u && (n.track({ type: 1, doc: c }), f = !0, (a || l) && (o = !0)), f && (u ? (s = s.add(u), i = h ? i.add(e) : i.delete(e)) : (s = s.delete(e), i = i.delete(e))) })), null !== this.query.limit) for (; s.size > this.query.limit;) { const e = "F" === this.query.limitType ? s.last() : s.first(); s = s.delete(e.key), i = i.delete(e.key), n.track({ type: 1, doc: e }) } return { Ta: s, Aa: n, Xi: o, mutatedKeys: i } } Ra(e, t) { return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations } applyChanges(e, t, n, r) { const i = this.Ta; this.Ta = e.Ta, this.mutatedKeys = e.mutatedKeys; const s = e.Aa.Q_(); s.sort(((e, t) => function (e, t) { const n = e => { switch (e) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return IE() } }; return n(e) - n(t) }(e.type, t.type) || this.Ia(e.doc, t.doc))), this.Va(n), r = null != r && r; const o = t && !r ? this.ma() : [], a = 0 === this.Pa.size && this.current && !r ? 1 : 0, l = a !== this.ha; return this.ha = a, 0 !== s.length || l ? { snapshot: new bk(this.query, e.Ta, i, s, e.mutatedKeys, 0 === a, l, !1, !!n && n.resumeToken.approximateByteSize() > 0), fa: o } : { fa: o } } j_(e) { return this.current && "Offline" === e ? (this.current = !1, this.applyChanges({ Ta: this.Ta, Aa: new yk, mutatedKeys: this.mutatedKeys, Xi: !1 }, !1)) : { fa: [] } } ga(e) { return !this.la.has(e) && !!this.Ta.has(e) && !this.Ta.get(e).hasLocalMutations } Va(e) { e && (e.addedDocuments.forEach((e => this.la = this.la.add(e))), e.modifiedDocuments.forEach((e => { })), e.removedDocuments.forEach((e => this.la = this.la.delete(e))), this.current = e.current) } ma() { if (!this.current) return []; const e = this.Pa; this.Pa = iC(), this.Ta.forEach((e => { this.ga(e.key) && (this.Pa = this.Pa.add(e.key)) })); const t = []; return e.forEach((e => { this.Pa.has(e) || t.push(new Ik(e)) })), this.Pa.forEach((n => { e.has(n) || t.push(new Pk(n)) })), t } pa(e) { this.la = e.hs, this.Pa = iC(); const t = this.da(e.documents); return this.applyChanges(t, !0) } ya() { return bk.fromInitialDocuments(this.query, this.Ta, this.mutatedKeys, 0 === this.ha, this.hasCachedResults) } } class Ok { constructor(e, t, n) { this.query = e, this.targetId = t, this.view = n } } class Dk { constructor(e) { this.key = e, this.wa = !1 } } class _k { constructor(e, t, n, r, i, s) { this.localStore = e, this.remoteStore = t, this.eventManager = n, this.sharedClientState = r, this.currentUser = i, this.maxConcurrentLimboResolutions = s, this.Sa = {}, this.ba = new GN((e => VN(e)), BN), this.Da = new Map, this.Ca = new Set, this.va = new SS(tS.comparator), this.Fa = new Map, this.Ma = new $T, this.xa = {}, this.Oa = new Map, this.Na = GT.Ln(), this.onlineState = "Unknown", this.La = void 0 } get isPrimaryClient() { return !0 === this.La } } async function Mk(e, t) { let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const r = rj(e); let i; const s = r.ba.get(t); return s ? (r.sharedClientState.addLocalQueryTarget(s.targetId), i = s.view.ya()) : i = await Fk(r, t, n, !0), i } async function Lk(e, t) { const n = rj(e); await Fk(n, t, !0, !1) } async function Fk(e, t, n, r) { const i = await vA(e.localStore, LN(t)), s = i.targetId, o = n ? e.sharedClientState.addLocalQueryTarget(s) : "not-current"; let a; return r && (a = await Uk(e, t, s, "current" === o, i.resumeToken)), e.isPrimaryClient && n && zA(e.remoteStore, i), a } async function Uk(e, t, n, r, i) { e.Ba = (t, n, r) => async function (e, t, n, r) { let i = t.view.da(n); i.Xi && (i = await bA(e.localStore, t.query, !1).then((e => { let { documents: n } = e; return t.view.da(n, i) }))); const s = r && r.targetChanges.get(t.targetId), o = r && null != r.targetMismatches.get(t.targetId), a = t.view.applyChanges(i, e.isPrimaryClient, s, o); return Xk(e, t.targetId, a.fa), a.snapshot }(e, t, n, r); const s = await bA(e.localStore, t, !0), o = new Rk(t, s.hs), a = o.da(s.documents), l = eT.createSynthesizedTargetChangeForCurrentChange(n, r && "Offline" !== e.onlineState, i), c = o.applyChanges(a, e.isPrimaryClient, l); Xk(e, n, c.fa); const u = new Ok(t, n, o); return e.ba.set(t, u), e.Da.has(n) ? e.Da.get(n).push(t) : e.Da.set(n, [t]), c.snapshot } async function Bk(e, t, n) { const r = OE(e), i = r.ba.get(t), s = r.Da.get(i.targetId); if (s.length > 1) return r.Da.set(i.targetId, s.filter((e => !BN(e, t)))), void r.ba.delete(t); r.isPrimaryClient ? (r.sharedClientState.removeLocalQueryTarget(i.targetId), r.sharedClientState.isActiveQueryTarget(i.targetId) || await yA(r.localStore, i.targetId, !1).then((() => { r.sharedClientState.clearQueryState(i.targetId), n && qA(r.remoteStore, i.targetId), Yk(r, i.targetId) })).catch(cS)) : (Yk(r, i.targetId), await yA(r.localStore, i.targetId, !0)) } async function Vk(e, t) { const n = OE(e), r = n.ba.get(t), i = n.Da.get(r.targetId); n.isPrimaryClient && 1 === i.length && (n.sharedClientState.removeLocalQueryTarget(r.targetId), qA(n.remoteStore, r.targetId)) } async function zk(e, t) { const n = OE(e); try { const e = await function (e, t) { const n = OE(e), r = t.snapshotVersion; let i = n.ns; return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (e => { const s = n.os.newChangeBuffer({ trackRemovals: !0 }); i = n.ns; const o = []; t.targetChanges.forEach(((s, a) => { const l = i.get(a); if (!l) return; o.push(n.Qr.removeMatchingKeys(e, s.removedDocuments, a).next((() => n.Qr.addMatchingKeys(e, s.addedDocuments, a)))); let c = l.withSequenceNumber(e.currentSequenceNumber); null !== t.targetMismatches.get(a) ? c = c.withResumeToken(PS.EMPTY_BYTE_STRING, JE.min()).withLastLimboFreeSnapshotVersion(JE.min()) : s.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(s.resumeToken, r)), i = i.insert(a, c), function (e, t, n) { return 0 === e.resumeToken.approximateByteSize() || t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 || n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0 }(l, c, s) && o.push(n.Qr.updateTargetData(e, c)) })); let a = YN(), l = iC(); if (t.documentUpdates.forEach((r => { t.resolvedLimboDocuments.has(r) && o.push(n.persistence.referenceDelegate.updateLimboDocument(e, r)) })), o.push(mA(e, s, t.documentUpdates).next((e => { a = e.cs, l = e.ls }))), !r.isEqual(JE.min())) { const t = n.Qr.getLastRemoteSnapshotVersion(e).next((t => n.Qr.setTargetsMetadata(e, e.currentSequenceNumber, r))); o.push(t) } return uS.waitFor(o).next((() => s.apply(e))).next((() => n.localDocuments.getLocalViewOfDocuments(e, a, l))).next((() => a)) })).then((e => (n.ns = i, e))) }(n.localStore, t); t.targetChanges.forEach(((e, t) => { const r = n.Fa.get(t); r && (RE(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1), e.addedDocuments.size > 0 ? r.wa = !0 : e.modifiedDocuments.size > 0 ? RE(r.wa) : e.removedDocuments.size > 0 && (RE(r.wa), r.wa = !1)) })), await ej(n, e, t) } catch (e) { await cS(e) } } function qk(e, t, n) { const r = OE(e); if (r.isPrimaryClient && 0 === n || !r.isPrimaryClient && 1 === n) { const e = []; r.ba.forEach(((n, r) => { const i = r.view.j_(t); i.snapshot && e.push(i.snapshot) })), function (e, t) { const n = OE(e); n.onlineState = t; let r = !1; n.queries.forEach(((e, n) => { for (const i of n.U_) i.j_(t) && (r = !0) })), r && Tk(n) }(r.eventManager, t), e.length && r.Sa.h_(e), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t) } } async function Hk(e, t, n) { const r = OE(e); r.sharedClientState.updateQueryState(t, "rejected", n); const i = r.Fa.get(t), s = i && i.key; if (s) { let e = new SS(tS.comparator); e = e.insert(s, rN.newNoDocument(s, JE.min())); const n = iC().add(s), i = new $C(JE.min(), new Map, new SS(GE), e, n); await zk(r, i), r.va = r.va.remove(s), r.Fa.delete(t), $k(r) } else await yA(r.localStore, t, !1).then((() => Yk(r, t, n))).catch(cS) } async function Wk(e, t) { const n = OE(e), r = t.batch.batchId; try { const e = await function (e, t) { const n = OE(e); return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (e => { const r = t.batch.keys(), i = n.os.newChangeBuffer({ trackRemovals: !0 }); return function (e, t, n, r) { const i = n.batch, s = i.keys(); let o = uS.resolve(); return s.forEach((e => { o = o.next((() => r.getEntry(t, e))).next((t => { const s = n.docVersions.get(e); RE(null !== s), t.version.compareTo(s) < 0 && (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t))) })) })), o.next((() => e.mutationQueue.removeMutationBatch(t, i))) }(n, e, t, i).next((() => i.apply(e))).next((() => n.mutationQueue.performConsistencyCheck(e))).next((() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))).next((() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, function (e) { let t = iC(); for (let n = 0; n < e.mutationResults.length; ++n)e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key)); return t }(t)))).next((() => n.localDocuments.getDocuments(e, r))) })) }(n.localStore, t); Qk(n, r, null), Gk(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await ej(n, e) } catch (e) { await cS(e) } } async function Kk(e, t, n) { const r = OE(e); try { const e = await function (e, t) { const n = OE(e); return n.persistence.runTransaction("Reject batch", "readwrite-primary", (e => { let r; return n.mutationQueue.lookupMutationBatch(e, t).next((t => (RE(null !== t), r = t.keys(), n.mutationQueue.removeMutationBatch(e, t)))).next((() => n.mutationQueue.performConsistencyCheck(e))).next((() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t))).next((() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, r))).next((() => n.localDocuments.getDocuments(e, r))) })) }(r.localStore, t); Qk(r, t, n), Gk(r, t), r.sharedClientState.updateMutationState(t, "rejected", n), await ej(r, e) } catch (n) { await cS(n) } } function Gk(e, t) { (e.Oa.get(t) || []).forEach((e => { e.resolve() })), e.Oa.delete(t) } function Qk(e, t, n) { const r = OE(e); let i = r.xa[r.currentUser.toKey()]; if (i) { const e = i.get(t); e && (n ? e.reject(n) : e.resolve(), i = i.remove(t)), r.xa[r.currentUser.toKey()] = i } } function Yk(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; e.sharedClientState.removeLocalQueryTarget(t); for (const r of e.Da.get(t)) e.ba.delete(r), n && e.Sa.ka(r, n); e.Da.delete(t), e.isPrimaryClient && e.Ma.Vr(t).forEach((t => { e.Ma.containsKey(t) || Jk(e, t) })) } function Jk(e, t) { e.Ca.delete(t.path.canonicalString()); const n = e.va.get(t); null !== n && (qA(e.remoteStore, n), e.va = e.va.remove(t), e.Fa.delete(n), $k(e)) } function Xk(e, t, n) { for (const r of n) r instanceof Pk ? (e.Ma.addReference(r.key, t), Zk(e, r)) : r instanceof Ik ? (AE("SyncEngine", "Document no longer in limbo: " + r.key), e.Ma.removeReference(r.key, t), e.Ma.containsKey(r.key) || Jk(e, r.key)) : IE() } function Zk(e, t) { const n = t.key, r = n.path.canonicalString(); e.va.get(n) || e.Ca.has(r) || (AE("SyncEngine", "New document in limbo: " + n), e.Ca.add(r), $k(e)) } function $k(e) { for (; e.Ca.size > 0 && e.va.size < e.maxConcurrentLimboResolutions;) { const t = e.Ca.values().next().value; e.Ca.delete(t); const n = new tS(ZE.fromString(t)), r = e.Na.next(); e.Fa.set(r, new Dk(n)), e.va = e.va.insert(n, r), zA(e.remoteStore, new BT(LN(ON(n.path)), r, "TargetPurposeLimboResolution", fS.oe)) } } async function ej(e, t, n) { const r = OE(e), i = [], s = [], o = []; r.ba.isEmpty() || (r.ba.forEach(((e, a) => { o.push(r.Ba(a, t, n).then((e => { var t; if ((e || n) && r.isPrimaryClient) { const i = e ? !e.fromCache : null === (t = null == n ? void 0 : n.targetChanges.get(a.targetId)) || void 0 === t ? void 0 : t.current; r.sharedClientState.updateQueryState(a.targetId, i ? "current" : "not-current") } if (e) { i.push(e); const t = lA.Ki(a.targetId, e); s.push(t) } }))) })), await Promise.all(o), r.Sa.h_(i), await async function (e, t) { const n = OE(e); try { await n.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (e => uS.forEach(t, (t => uS.forEach(t.qi, (r => n.persistence.referenceDelegate.addReference(e, t.targetId, r))).next((() => uS.forEach(t.Qi, (r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r))))))))) } catch (e) { if (!hS(e)) throw e; AE("LocalStore", "Failed to update sequence numbers: " + e) } for (const r of t) { const e = r.targetId; if (!r.fromCache) { const t = n.ns.get(e), r = t.snapshotVersion, i = t.withLastLimboFreeSnapshotVersion(r); n.ns = n.ns.insert(e, i) } } }(r.localStore, s)) } async function tj(e, t) { const n = OE(e); if (!n.currentUser.isEqual(t)) { AE("SyncEngine", "User change. New user:", t.toKey()); const e = await fA(n.localStore, t); n.currentUser = t, function (e, t) { e.Oa.forEach((e => { e.forEach((e => { e.reject(new _E(DE.CANCELLED, t)) })) })), e.Oa.clear() }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(t, e.removedBatchIds, e.addedBatchIds), await ej(n, e.us) } } function nj(e, t) { const n = OE(e), r = n.Fa.get(t); if (r && r.wa) return iC().add(r.key); { let e = iC(); const r = n.Da.get(t); if (!r) return e; for (const t of r) { const r = n.ba.get(t); e = e.unionWith(r.view.Ea) } return e } } function rj(e) { const t = OE(e); return t.remoteStore.remoteSyncer.applyRemoteEvent = zk.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = nj.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = Hk.bind(null, t), t.Sa.h_ = Nk.bind(null, t.eventManager), t.Sa.ka = Ck.bind(null, t.eventManager), t } function ij(e) { const t = OE(e); return t.remoteStore.remoteSyncer.applySuccessfulWrite = Wk.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = Kk.bind(null, t), t } class sj { constructor() { this.synchronizeTabs = !1 } async initialize(e) { this.serializer = RA(e.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(e), this.persistence = this.createPersistence(e), await this.persistence.start(), this.localStore = this.createLocalStore(e), this.gcScheduler = this.createGarbageCollectionScheduler(e, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(e, this.localStore) } createGarbageCollectionScheduler(e, t) { return null } createIndexBackfillerScheduler(e, t) { return null } createLocalStore(e) { return hA(this.persistence, new uA, e.initialUser, this.serializer) } createPersistence(e) { return new sA(aA.Hr, this.serializer) } createSharedClientState(e) { return new EA } async terminate() { var e, t; null === (e = this.gcScheduler) || void 0 === e || e.stop(), null === (t = this.indexBackfillerScheduler) || void 0 === t || t.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown() } } class oj { async initialize(e, t) { this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(t), this.remoteStore = this.createRemoteStore(t), this.eventManager = this.createEventManager(t), this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs), this.sharedClientState.onlineStateHandler = e => qk(this.syncEngine, e, 1), this.remoteStore.remoteSyncer.handleCredentialChange = tj.bind(null, this.syncEngine), await hk(this.remoteStore, this.syncEngine.isPrimaryClient)) } createEventManager(e) { return new xk } createDatastore(e) { const t = RA(e.databaseInfo.databaseId), n = function (e) { return new PA(e) }(e.databaseInfo); return function (e, t, n, r) { return new LA(e, t, n, r) }(e.authCredentials, e.appCheckCredentials, n, t) } createRemoteStore(e) { return function (e, t, n, r, i) { return new UA(e, t, n, r, i) }(this.localStore, this.datastore, e.asyncQueue, (e => qk(this.syncEngine, e, 0)), NA.D() ? new NA : new SA) } createSyncEngine(e, t) { return function (e, t, n, r, i, s, o) { const a = new _k(e, t, n, r, i, s); return o && (a.La = !0), a }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t) } async terminate() { var e; await async function (e) { const t = OE(e); AE("RemoteStore", "RemoteStore shutting down."), t.M_.add(5), await VA(t), t.O_.shutdown(), t.N_.set("Unknown") }(this.remoteStore), null === (e = this.datastore) || void 0 === e || e.terminate() } } class aj { constructor(e) { this.observer = e, this.muted = !1 } next(e) { this.observer.next && this.Ka(this.observer.next, e) } error(e) { this.observer.error ? this.Ka(this.observer.error, e) : kE("Uncaught Error in snapshot listener:", e.toString()) } $a() { this.muted = !0 } Ka(e, t) { this.muted || setTimeout((() => { this.muted || e(t) }), 0) } } class lj { constructor(e, t, n, r) { this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = n, this.databaseInfo = r, this.user = SE.UNAUTHENTICATED, this.clientId = KE.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, (async e => { AE("FirestoreClient", "Received user=", e.uid), await this.authCredentialListener(e), this.user = e })), this.appCheckCredentials.start(n, (e => (AE("FirestoreClient", "Received new app check token=", e), this.appCheckCredentialListener(e, this.user)))) } get configuration() { return { asyncQueue: this.asyncQueue, databaseInfo: this.databaseInfo, clientId: this.clientId, authCredentials: this.authCredentials, appCheckCredentials: this.appCheckCredentials, initialUser: this.user, maxConcurrentLimboResolutions: 100 } } setCredentialChangeListener(e) { this.authCredentialListener = e } setAppCheckTokenChangeListener(e) { this.appCheckCredentialListener = e } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new _E(DE.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { this.asyncQueue.enterRestrictedMode(); const e = new ME; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async () => { try { this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve() } catch (t) { const n = gk(t, "Failed to shutdown persistence"); e.reject(n) } })), e.promise } } async function cj(e, t) { e.asyncQueue.verifyOperationInProgress(), AE("FirestoreClient", "Initializing OfflineComponentProvider"); const n = e.configuration; await t.initialize(n); let r = n.initialUser; e.setCredentialChangeListener((async e => { r.isEqual(e) || (await fA(t.localStore, e), r = e) })), t.persistence.setDatabaseDeletedListener((() => e.terminate())), e._offlineComponents = t } async function uj(e, t) { e.asyncQueue.verifyOperationInProgress(); const n = await hj(e); AE("FirestoreClient", "Initializing OnlineComponentProvider"), await t.initialize(n, e.configuration), e.setCredentialChangeListener((e => dk(t.remoteStore, e))), e.setAppCheckTokenChangeListener(((e, n) => dk(t.remoteStore, n))), e._onlineComponents = t } function dj(e) { return "FirebaseError" === e.name ? e.code === DE.FAILED_PRECONDITION || e.code === DE.UNIMPLEMENTED : !("undefined" != typeof DOMException && e instanceof DOMException) || 22 === e.code || 20 === e.code || 11 === e.code } async function hj(e) { if (!e._offlineComponents) if (e._uninitializedComponentsProvider) { AE("FirestoreClient", "Using user provided OfflineComponentProvider"); try { await cj(e, e._uninitializedComponentsProvider._offline) } catch (t) { const n = t; if (!dj(n)) throw n; jE("Error using user provided cache. Falling back to memory cache: " + n), await cj(e, new sj) } } else AE("FirestoreClient", "Using default OfflineComponentProvider"), await cj(e, new sj); return e._offlineComponents } async function fj(e) { return e._onlineComponents || (e._uninitializedComponentsProvider ? (AE("FirestoreClient", "Using user provided OnlineComponentProvider"), await uj(e, e._uninitializedComponentsProvider._online)) : (AE("FirestoreClient", "Using default OnlineComponentProvider"), await uj(e, new oj))), e._onlineComponents } function pj(e) { return fj(e).then((e => e.syncEngine)) } async function mj(e) { const t = await fj(e), n = t.eventManager; return n.onListen = Mk.bind(null, t.syncEngine), n.onUnlisten = Bk.bind(null, t.syncEngine), n.onFirstRemoteStoreListen = Lk.bind(null, t.syncEngine), n.onLastRemoteStoreUnlisten = Vk.bind(null, t.syncEngine), n } function gj(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = new ME; return e.asyncQueue.enqueueAndForget((async () => function (e, t, n, r, i) { const s = new aj({ next: s => { t.enqueueAndForget((() => Sk(e, o))); const a = s.docs.has(n); !a && s.fromCache ? i.reject(new _E(DE.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && s.fromCache && r && "server" === r.source ? i.reject(new _E(DE.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(s) }, error: e => i.reject(e) }), o = new jk(ON(n.path), s, { includeMetadataChanges: !0, ra: !0 }); return Ek(e, o) }(await mj(e), e.asyncQueue, t, n, r))), r.promise } function vj(e) { const t = {}; return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds), t } const yj = new Map; function bj(e, t, n) { if (!n) throw new _E(DE.INVALID_ARGUMENT, "Function ".concat(e, "() cannot be called with an empty ").concat(t, ".")) } function wj(e) { if (!tS.isDocumentKey(e)) throw new _E(DE.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but ".concat(e, " has ").concat(e.length, ".")) } function xj(e) { if (void 0 === e) return "undefined"; if (null === e) return "null"; if ("string" == typeof e) return e.length > 20 && (e = "".concat(e.substring(0, 20), "...")), JSON.stringify(e); if ("number" == typeof e || "boolean" == typeof e) return "" + e; if ("object" == typeof e) { if (e instanceof Array) return "an array"; { const t = function (e) { return e.constructor ? e.constructor.name : null }(e); return t ? "a custom ".concat(t, " object") : "an object" } } return "function" == typeof e ? "a function" : IE() } function Ej(e, t) { if ("_delegate" in e && (e = e._delegate), !(e instanceof t)) { if (t.name === e.constructor.name) throw new _E(DE.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const n = xj(e); throw new _E(DE.INVALID_ARGUMENT, "Expected type '".concat(t.name, "', but it was: ").concat(n)) } } return e } class Sj { constructor(e) { var t, n; if (void 0 === e.host) { if (void 0 !== e.ssl) throw new _E(DE.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = e.host, this.ssl = null === (t = e.ssl) || void 0 === t || t; if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.localCache = e.localCache, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = 41943040; else { if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new _E(DE.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = e.cacheSizeBytes } (function (e, t, n, r) { if (!0 === t && !0 === r) throw new _E(DE.INVALID_ARGUMENT, "".concat(e, " and ").concat(n, " cannot be used together.")) })("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = vj(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {}), function (e) { if (void 0 !== e.timeoutSeconds) { if (isNaN(e.timeoutSeconds)) throw new _E(DE.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (must not be NaN)")); if (e.timeoutSeconds < 5) throw new _E(DE.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (minimum allowed value is 5)")); if (e.timeoutSeconds > 30) throw new _E(DE.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (maximum allowed value is 30)")) } }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams } isEqual(e) { return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function (e, t) { return e.timeoutSeconds === t.timeoutSeconds }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams } } class Nj { constructor(e, t, n, r) { this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = n, this._app = r, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Sj({}), this._settingsFrozen = !1 } get app() { if (!this._app) throw new _E(DE.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return void 0 !== this._terminateTask } _setSettings(e) { if (this._settingsFrozen) throw new _E(DE.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new Sj(e), void 0 !== e.credentials && (this._authCredentials = function (e) { if (!e) return new FE; switch (e.type) { case "firstParty": return new zE(e.sessionIndex || "0", e.iamToken || null, e.authTokenFactory || null); case "provider": return e.client; default: throw new _E(DE.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(e.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (e) { const t = yj.get(e); t && (AE("ComponentProvider", "Removing Datastore"), yj.delete(e), t.terminate()) }(this), Promise.resolve() } } function Cj(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; var i; const s = (e = Ej(e, Nj))._getSettings(), o = "".concat(t, ":").concat(n); if ("firestore.googleapis.com" !== s.host && s.host !== o && jE("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), e._setSettings(Object.assign(Object.assign({}, s), { host: o, ssl: !1 })), r.mockUserToken) { let t, n; if ("string" == typeof r.mockUserToken) t = r.mockUserToken, n = SE.MOCK_USER; else { t = function (e, t) { if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const n = t || "demo-project", r = e.iat || 0, i = e.sub || e.user_id; if (!i) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const s = Object.assign({ iss: "https://securetoken.google.com/".concat(n), aud: n, iat: r, exp: r + 3600, auth_time: r, sub: i, user_id: i, firebase: { sign_in_provider: "custom", identities: {} } }, e); return [yv(JSON.stringify({ alg: "none", type: "JWT" })), yv(JSON.stringify(s)), ""].join(".") }(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId); const s = r.mockUserToken.sub || r.mockUserToken.user_id; if (!s) throw new _E(DE.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); n = new SE(s) } e._authCredentials = new UE(new LE(t, n)) } } class Tj { constructor(e, t, n) { this.converter = t, this._query = n, this.type = "query", this.firestore = e } withConverter(e) { return new Tj(this.firestore, e, this._query) } } class Aj { constructor(e, t, n) { this.converter = t, this._key = n, this.type = "document", this.firestore = e } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new kj(this.firestore, this.converter, this._key.path.popLast()) } withConverter(e) { return new Aj(this.firestore, e, this._key) } } class kj extends Tj { constructor(e, t, n) { super(e, t, ON(n)), this._path = n, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const e = this._path.popLast(); return e.isEmpty() ? null : new Aj(this.firestore, null, new tS(e)) } withConverter(e) { return new kj(this.firestore, e, this._path) } } function jj(e, t) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; if (e = Uv(e), 1 === arguments.length && (t = KE.newId()), bj("doc", "path", t), e instanceof Nj) { const n = ZE.fromString(t, ...r); return wj(n), new Aj(e, null, new tS(n)) } { if (!(e instanceof Aj || e instanceof kj)) throw new _E(DE.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const n = e._path.child(ZE.fromString(t, ...r)); return wj(n), new Aj(e.firestore, e instanceof kj ? e.converter : null, new tS(n)) } } class Pj { constructor() { this.iu = Promise.resolve(), this.su = [], this.ou = !1, this._u = [], this.au = null, this.uu = !1, this.cu = !1, this.lu = [], this.Yo = new OA(this, "async_queue_retry"), this.hu = () => { const e = IA(); e && AE("AsyncQueue", "Visibility state changed to " + e.visibilityState), this.Yo.Wo() }; const e = IA(); e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.hu) } get isShuttingDown() { return this.ou } enqueueAndForget(e) { this.enqueue(e) } enqueueAndForgetEvenWhileRestricted(e) { this.Pu(), this.Iu(e) } enterRestrictedMode(e) { if (!this.ou) { this.ou = !0, this.cu = e || !1; const t = IA(); t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.hu) } } enqueue(e) { if (this.Pu(), this.ou) return new Promise((() => { })); const t = new ME; return this.Iu((() => this.ou && this.cu ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise))).then((() => t.promise)) } enqueueRetryable(e) { this.enqueueAndForget((() => (this.su.push(e), this.Tu()))) } async Tu() { if (0 !== this.su.length) { try { await this.su[0](), this.su.shift(), this.Yo.reset() } catch (sI) { if (!hS(sI)) throw sI; AE("AsyncQueue", "Operation failed with retryable error: " + sI) } this.su.length > 0 && this.Yo.$o((() => this.Tu())) } } Iu(e) { const t = this.iu.then((() => (this.uu = !0, e().catch((e => { this.au = e, this.uu = !1; const t = function (e) { let t = e.message || ""; return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack), t }(e); throw kE("INTERNAL UNHANDLED ERROR: ", t), e })).then((e => (this.uu = !1, e)))))); return this.iu = t, t } enqueueAfterDelay(e, t, n) { this.Pu(), this.lu.indexOf(e) > -1 && (t = 0); const r = mk.createAndSchedule(this, e, t, n, (e => this.Eu(e))); return this._u.push(r), r } Pu() { this.au && IE() } verifyOperationInProgress() { } async du() { let e; do { e = this.iu, await e } while (e !== this.iu) } Au(e) { for (const t of this._u) if (t.timerId === e) return !0; return !1 } Ru(e) { return this.du().then((() => { this._u.sort(((e, t) => e.targetTimeMs - t.targetTimeMs)); for (const t of this._u) if (t.skipDelay(), "all" !== e && t.timerId === e) break; return this.du() })) } Vu(e) { this.lu.push(e) } Eu(e) { const t = this._u.indexOf(e); this._u.splice(t, 1) } } class Ij extends Nj { constructor(e, t, n, r) { super(e, t, n, r), this.type = "firestore", this._queue = new Pj, this._persistenceKey = (null == r ? void 0 : r.name) || "[DEFAULT]" } _terminate() { return this._firestoreClient || Oj(this), this._firestoreClient.terminate() } } function Rj(e) { return e._firestoreClient || Oj(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient } function Oj(e) { var t, n, r; const i = e._freezeSettings(), s = function (e, t, n, r) { return new FS(e, t, n, r.host, r.ssl, r.experimentalForceLongPolling, r.experimentalAutoDetectLongPolling, vj(r.experimentalLongPollingOptions), r.useFetchStreams) }(e._databaseId, (null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || "", e._persistenceKey, i); e._firestoreClient = new lj(e._authCredentials, e._appCheckCredentials, e._queue, s), (null === (n = i.localCache) || void 0 === n ? void 0 : n._offlineComponentProvider) && (null === (r = i.localCache) || void 0 === r ? void 0 : r._onlineComponentProvider) && (e._firestoreClient._uninitializedComponentsProvider = { _offlineKind: i.localCache.kind, _offline: i.localCache._offlineComponentProvider, _online: i.localCache._onlineComponentProvider }) } class Dj { constructor(e) { this._byteString = e } static fromBase64String(e) { try { return new Dj(PS.fromBase64String(e)) } catch (e) { throw new _E(DE.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e) } } static fromUint8Array(e) { return new Dj(PS.fromUint8Array(e)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(e) { return this._byteString.isEqual(e._byteString) } } class _j { constructor() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; for (let r = 0; r < t.length; ++r)if (0 === t[r].length) throw new _E(DE.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new eS(t) } isEqual(e) { return this._internalPath.isEqual(e._internalPath) } } class Mj { constructor(e) { this._methodName = e } } class Lj { constructor(e, t) { if (!isFinite(e) || e < -90 || e > 90) throw new _E(DE.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e); if (!isFinite(t) || t < -180 || t > 180) throw new _E(DE.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t); this._lat = e, this._long = t } get latitude() { return this._lat } get longitude() { return this._long } isEqual(e) { return this._lat === e._lat && this._long === e._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(e) { return GE(this._lat, e._lat) || GE(this._long, e._long) } } const Fj = /^__.*__$/; class Uj { constructor(e, t, n) { this.data = e, this.fieldMask = t, this.fieldTransforms = n } toMutation(e, t) { return null !== this.fieldMask ? new RC(e, this.data, this.fieldMask, t, this.fieldTransforms) : new IC(e, this.data, t, this.fieldTransforms) } } function Bj(e) { switch (e) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw IE() } } class Vj { constructor(e, t, n, r, i, s) { this.settings = e, this.databaseId = t, this.serializer = n, this.ignoreUndefinedProperties = r, void 0 === i && this.mu(), this.fieldTransforms = i || [], this.fieldMask = s || [] } get path() { return this.settings.path } get fu() { return this.settings.fu } gu(e) { return new Vj(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } pu(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.gu({ path: n, yu: !1 }); return r.wu(e), r } Su(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.gu({ path: n, yu: !1 }); return r.mu(), r } bu(e) { return this.gu({ path: void 0, yu: !0 }) } Du(e) { return Zj(e, this.settings.methodName, this.settings.Cu || !1, this.path, this.settings.vu) } contains(e) { return void 0 !== this.fieldMask.find((t => e.isPrefixOf(t))) || void 0 !== this.fieldTransforms.find((t => e.isPrefixOf(t.field))) } mu() { if (this.path) for (let e = 0; e < this.path.length; e++)this.wu(this.path.get(e)) } wu(e) { if (0 === e.length) throw this.Du("Document fields must not be empty"); if (Bj(this.fu) && Fj.test(e)) throw this.Du('Document fields cannot begin and end with "__"') } } class zj { constructor(e, t, n) { this.databaseId = e, this.ignoreUndefinedProperties = t, this.serializer = n || RA(e) } Fu(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return new Vj({ fu: e, methodName: t, vu: n, path: eS.emptyPath(), yu: !1, Cu: r }, this.databaseId, this.serializer, this.ignoreUndefinedProperties) } } function qj(e) { const t = e._freezeSettings(), n = RA(e._databaseId); return new zj(e._databaseId, !!t.ignoreUndefinedProperties, n) } function Hj(e, t, n, r, i) { let s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; const o = e.Fu(s.merge || s.mergeFields ? 2 : 0, t, n, i); Qj("Data must be an object, but it was:", o, r); const a = Kj(r, o); let l, c; if (s.merge) l = new kS(o.fieldMask), c = o.fieldTransforms; else if (s.mergeFields) { const e = []; for (const r of s.mergeFields) { const i = Yj(t, r, n); if (!o.contains(i)) throw new _E(DE.INVALID_ARGUMENT, "Field '".concat(i, "' is specified in your field mask but missing from your input data.")); $j(e, i) || e.push(i) } l = new kS(e), c = o.fieldTransforms.filter((e => l.covers(e.field))) } else l = null, c = o.fieldTransforms; return new Uj(new tN(a), l, c) } function Wj(e, t) { if (Gj(e = Uv(e))) return Qj("Unsupported field value:", t, e), Kj(e, t); if (e instanceof Mj) return function (e, t) { if (!Bj(t.fu)) throw t.Du("".concat(e._methodName, "() can only be used with update() and set()")); if (!t.path) throw t.Du("".concat(e._methodName, "() is not currently supported inside arrays")); const n = e._toFieldTransform(t); n && t.fieldTransforms.push(n) }(e, t), null; if (void 0 === e && t.ignoreUndefinedProperties) return null; if (t.path && t.fieldMask.push(t.path), e instanceof Array) { if (t.settings.yu && 4 !== t.fu) throw t.Du("Nested arrays are not supported"); return function (e, t) { const n = []; let r = 0; for (const i of e) { let e = Wj(i, t.bu(r)); null == e && (e = { nullValue: "NULL_VALUE" }), n.push(e), r++ } return { arrayValue: { values: n } } }(e, t) } return function (e, t) { if (null === (e = Uv(e))) return { nullValue: "NULL_VALUE" }; if ("number" == typeof e) return cC(t.serializer, e); if ("boolean" == typeof e) return { booleanValue: e }; if ("string" == typeof e) return { stringValue: e }; if (e instanceof Date) { const n = YE.fromDate(e); return { timestampValue: fT(t.serializer, n) } } if (e instanceof YE) { const n = new YE(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3)); return { timestampValue: fT(t.serializer, n) } } if (e instanceof Lj) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } }; if (e instanceof Dj) return { bytesValue: pT(t.serializer, e._byteString) }; if (e instanceof Aj) { const n = t.databaseId, r = e.firestore._databaseId; if (!r.isEqual(n)) throw t.Du("Document reference is for database ".concat(r.projectId, "/").concat(r.database, " but should be for database ").concat(n.projectId, "/").concat(n.database)); return { referenceValue: vT(e.firestore._databaseId || t.databaseId, e._key.path) } } throw t.Du("Unsupported field value: ".concat(xj(e))) }(e, t) } function Kj(e, t) { const n = {}; return ES(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : xS(e, ((e, r) => { const i = Wj(r, t.pu(e)); null != i && (n[e] = i) })), { mapValue: { fields: n } } } function Gj(e) { return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof YE || e instanceof Lj || e instanceof Dj || e instanceof Aj || e instanceof Mj) } function Qj(e, t, n) { if (!Gj(n) || !function (e) { return "object" == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e)) }(n)) { const r = xj(n); throw "an object" === r ? t.Du(e + " a custom object") : t.Du(e + " " + r) } } function Yj(e, t, n) { if ((t = Uv(t)) instanceof _j) return t._internalPath; if ("string" == typeof t) return Xj(e, t); throw Zj("Field path arguments must be of type string or ", e, !1, void 0, n) } const Jj = new RegExp("[~\\*/\\[\\]]"); function Xj(e, t, n) { if (t.search(Jj) >= 0) throw Zj("Invalid field path (".concat(t, "). Paths must not contain '~', '*', '/', '[', or ']'"), e, !1, void 0, n); try { return new _j(...t.split("."))._internalPath } catch (EP) { throw Zj("Invalid field path (".concat(t, "). Paths must not be empty, begin with '.', end with '.', or contain '..'"), e, !1, void 0, n) } } function Zj(e, t, n, r, i) { const s = r && !r.isEmpty(), o = void 0 !== i; let a = "Function ".concat(t, "() called with invalid data"); n && (a += " (via `toFirestore()`)"), a += ". "; let l = ""; return (s || o) && (l += " (found", s && (l += " in field ".concat(r)), o && (l += " in document ".concat(i)), l += ")"), new _E(DE.INVALID_ARGUMENT, a + e + l) } function $j(e, t) { return e.some((e => e.isEqual(t))) } class eP { constructor(e, t, n, r, i) { this._firestore = e, this._userDataWriter = t, this._key = n, this._document = r, this._converter = i } get id() { return this._key.path.lastSegment() } get ref() { return new Aj(this._firestore, this._converter, this._key) } exists() { return null !== this._document } data() { if (this._document) { if (this._converter) { const e = new tP(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(e) } return this._userDataWriter.convertValue(this._document.data.value) } } get(e) { if (this._document) { const t = this._document.data.field(nP("DocumentSnapshot.get", e)); if (null !== t) return this._userDataWriter.convertValue(t) } } } class tP extends eP { data() { return super.data() } } function nP(e, t) { return "string" == typeof t ? Xj(e, t) : t instanceof _j ? t._internalPath : t._delegate._internalPath } class rP { convertValue(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none"; switch (VS(e)) { case 0: return null; case 1: return e.booleanValue; case 2: return OS(e.integerValue || e.doubleValue); case 3: return this.convertTimestamp(e.timestampValue); case 4: return this.convertServerTimestamp(e, t); case 5: return e.stringValue; case 6: return this.convertBytes(DS(e.bytesValue)); case 7: return this.convertReference(e.referenceValue); case 8: return this.convertGeoPoint(e.geoPointValue); case 9: return this.convertArray(e.arrayValue, t); case 10: return this.convertObject(e.mapValue, t); default: throw IE() } } convertObject(e, t) { return this.convertObjectMap(e.fields, t) } convertObjectMap(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none"; const n = {}; return xS(e, ((e, r) => { n[e] = this.convertValue(r, t) })), n } convertGeoPoint(e) { return new Lj(OS(e.latitude), OS(e.longitude)) } convertArray(e, t) { return (e.values || []).map((e => this.convertValue(e, t))) } convertServerTimestamp(e, t) { switch (t) { case "previous": const n = MS(e); return null == n ? null : this.convertValue(n, t); case "estimate": return this.convertTimestamp(LS(e)); default: return null } } convertTimestamp(e) { const t = RS(e); return new YE(t.seconds, t.nanos) } convertDocumentKey(e, t) { const n = ZE.fromString(e); RE(UT(n)); const r = new US(n.get(1), n.get(3)), i = new tS(n.popFirst(5)); return r.isEqual(t) || kE("Document ".concat(i, " contains a document reference within a different database (").concat(r.projectId, "/").concat(r.database, ") which is not supported. It will be treated as a reference in the current database (").concat(t.projectId, "/").concat(t.database, ") instead.")), i } } function iP(e, t, n) { let r; return r = e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t, r } class sP { constructor(e, t) { this.hasPendingWrites = e, this.fromCache = t } isEqual(e) { return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache } } class oP extends eP { constructor(e, t, n, r, i, s) { super(e, t, n, r, s), this._firestore = e, this._firestoreImpl = e, this.metadata = i } exists() { return super.exists() } data() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (this._document) { if (this._converter) { const t = new aP(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(t, e) } return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps) } } get(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this._document) { const n = this._document.data.field(nP("DocumentSnapshot.get", e)); if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps) } } } class aP extends oP { data() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return super.data(e) } } class lP extends rP { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Dj(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new Aj(this.firestore, null, t) } } function cP(e, t, n) { e = Ej(e, Aj); const r = Ej(e.firestore, Ij), i = iP(e.converter, t, n); return uP(r, [Hj(qj(r), "setDoc", e._key, i, null !== e.converter, n).toMutation(e._key, SC.none())]) } function uP(e, t) { return function (e, t) { const n = new ME; return e.asyncQueue.enqueueAndForget((async () => async function (e, t, n) { const r = ij(e); try { const e = await function (e, t) { const n = OE(e), r = YE.now(), i = t.reduce(((e, t) => e.add(t.key)), iC()); let s, o; return n.persistence.runTransaction("Locally write mutations", "readwrite", (e => { let a = YN(), l = iC(); return n.os.getEntries(e, i).next((e => { a = e, a.forEach(((e, t) => { t.isValidDocument() || (l = l.add(e)) })) })).next((() => n.localDocuments.getOverlayedDocuments(e, a))).next((i => { s = i; const o = []; for (const e of t) { const t = jC(e, s.get(e.key).overlayedDocument); null != t && o.push(new RC(e.key, t, nN(t.value.mapValue), SC.exists(!0))) } return n.mutationQueue.addMutationBatch(e, r, o, t) })).next((t => { o = t; const r = t.applyToLocalDocumentSet(s, l); return n.documentOverlayCache.saveOverlays(e, t.batchId, r) })) })).then((() => ({ batchId: o.batchId, changes: ZN(s) }))) }(r.localStore, t); r.sharedClientState.addPendingMutation(e.batchId), function (e, t, n) { let r = e.xa[e.currentUser.toKey()]; r || (r = new SS(GE)), r = r.insert(t, n), e.xa[e.currentUser.toKey()] = r }(r, e.batchId, n), await ej(r, e.changes), await nk(r.remoteStore) } catch (e) { const t = gk(e, "Failed to persist write"); n.reject(t) } }(await pj(e), t, n))), n.promise }(Rj(e), t) } function dP(e, t, n) { const r = n.docs.get(t._key), i = new lP(e); return new oP(e, i, t._key, r, new sP(n.hasPendingWrites, n.fromCache), t.converter) } new WeakMap; !function (e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; !function (e) { NE = e }(jy), Ny(new Bv("firestore", ((e, n) => { let { instanceIdentifier: r, options: i } = n; const s = e.getProvider("app").getImmediate(), o = new Ij(new BE(e.getProvider("auth-internal")), new HE(e.getProvider("app-check-internal")), function (e, t) { if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"])) throw new _E(DE.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new US(e.options.projectId, t) }(s, r), s); return i = Object.assign({ useFetchStreams: t }, i), o._setSettings(i), o }), "PUBLIC").setMultipleInstances(!0)), Ry(EE, "4.6.4", e), Ry(EE, "4.6.4", "esm2017") }(); const hP = Py({ apiKey: "AIzaSyCAcMKQIWGwcpTZfDfYamOc1TtTsoqDmA0", authDomain: "auth-web-3b1e9.firebaseapp.com", projectId: "auth-web-3b1e9", storageBucket: "auth-web-3b1e9.appspot.com", messagingSenderId: "234384132534", appId: "1:234384132534:web:eecf01823c9eb638b81917" }), fP = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Iy(); const t = Cy(e, "auth"); if (t.isInitialized()) return t.getImmediate(); const n = function (e, t) { const n = Cy(e, "auth"); if (n.isInitialized()) { const e = n.getImmediate(); if (Rv(n.getOptions(), null !== t && void 0 !== t ? t : {})) return e; Xy(e, "already-initialized") } return n.initialize({ options: t }) }(e, { popupRedirectResolver: eE, persistence: [cx, Kw, Qw] }), r = Nv("authTokenSyncURL"); if (r && "boolean" === typeof isSecureContext && isSecureContext) { const e = new URL(r, location.origin); if (location.origin === e.origin) { const t = (i = e.toString(), async e => { const t = e && await e.getIdTokenResult(), n = t && ((new Date).getTime() - Date.parse(t.issuedAtTime)) / 1e3; if (n && n > iE) return; const r = null === t || void 0 === t ? void 0 : t.token; sE !== r && (sE = r, await fetch(i, { method: r ? "POST" : "DELETE", headers: r ? { Authorization: "Bearer ".concat(r) } : {} })) }); !function (e, t, n) { Uv(e).beforeAuthStateChanged(t, n) }(n, t, (() => t(n.currentUser))), function (e, t, n, r) { Uv(e).onIdTokenChanged(t, n, r) }(n, (e => t(e))) } } var i; const s = Ev("auth"); return s && pw(n, "http://".concat(s)), n }(hP), pP = function (e, t) { const n = "string" == typeof e ? e : t || "(default)", r = Cy("object" == typeof e ? e : Iy(), "firestore").getImmediate({ identifier: n }); if (!r._initialized) { const e = (e => { const t = Ev(e); if (!t) return; const n = t.lastIndexOf(":"); if (n <= 0 || n + 1 === t.length) throw new Error("Invalid host ".concat(t, " with no separate hostname and port!")); const r = parseInt(t.substring(n + 1), 10); return "[" === t[0] ? [t.substring(1, n - 1), r] : [t.substring(0, n), r] })("firestore"); e && Cj(r, ...e) } return r }(hP), mP = new Pw, gP = e => { let { handleClose: t, handleFormSubmit: n } = e; const [i, s] = (0, r.useState)(""), [o, a] = (0, r.useState)(""), [l, c] = (0, r.useState)(""), [u, d] = (0, r.useState)({}), [h, f] = (0, r.useState)(!0); return (0, Ve.jsx)("div", { className: "main-popup", children: (0, Ve.jsx)("div", { className: "popup", children: (0, Ve.jsx)("div", { className: "popup-inner", children: (0, Ve.jsxs)(pv, { onSubmit: async e => { e.preventDefault(); const r = (() => { const e = {}; return o || (e.email = "Email is required"), /\S+@\S+\.\S+/.test(o) || (e.email = "Email address is invalid"), l || (e.password = "Password is required"), l.length < 6 && (e.password = "Password must be at least 6 characters"), h || i || (e.username = "Username is required"), e })(); if (Object.keys(r).length > 0) d(r); else { d({}); try { if (h) await function (e, t, n) { return Ty(e.app) ? Promise.reject(eb(e)) : Vw(Uv(e), Tw.credential(t, n)).catch((async t => { throw t.code === "auth/".concat("password-does-not-meet-requirements") && zw(e), t })) }(fP, o, l), console.log("Logged in successfully"); else { const e = await async function (e, t, n) { if (Ty(e.app)) return Promise.reject(eb(e)); const r = ow(e), i = fw(r, { returnSecureToken: !0, email: t, password: n, clientType: "CLIENT_TYPE_WEB" }, "signUpPassword", Ow), s = await i.catch((t => { throw t.code === "auth/".concat("password-does-not-meet-requirements") && zw(e), t })), o = await Dw._fromIdTokenResponse(r, "signIn", s); return await r._updateCurrentUser(o.user), o }(fP, o, l), t = e.user; t && await cP(jj(pP, "Users", t.uid), { email: t.email, username: i }), console.log("Registered successfully") } n(), t() } catch (No) { console.error("Error: ", No.message), d({ firebase: No.message }) } } }, children: [h ? (0, Ve.jsxs)(Ve.Fragment, { children: [(0, Ve.jsx)("h2", { className: "popup-h2", children: "Login" }), (0, Ve.jsxs)("div", { className: "form-sign", children: [(0, Ve.jsx)("input", { type: "email", value: o, onChange: e => a(e.target.value), placeholder: "Enter your email", className: u.email ? "is-invalid" : "" }), u.email && (0, Ve.jsx)("div", { className: "invalid-feedback", children: u.email })] }), (0, Ve.jsxs)("div", { className: "form-sign", children: [(0, Ve.jsx)("input", { type: "password", value: l, onChange: e => c(e.target.value), placeholder: "Enter your password", className: u.password ? "is-invalid" : "" }), u.password && (0, Ve.jsx)("div", { className: "invalid-feedback", children: u.password })] }), (0, Ve.jsxs)("div", { className: "register-link", children: [(0, Ve.jsx)("span", { className: "mr-2", children: "Don't have an account?" }), (0, Ve.jsx)("button", { type: "button", className: "register-Link", onClick: () => f(!1), children: "Sign In" })] }), (0, Ve.jsx)("div", { className: "sign-in", children: (0, Ve.jsx)(mo, { variant: "primary", type: "submit", children: "Login" }) })] }) : (0, Ve.jsxs)(Ve.Fragment, { children: [(0, Ve.jsx)("h2", { className: "popup-h2", children: "Sign In" }), (0, Ve.jsxs)("div", { className: "form-sign", children: [(0, Ve.jsx)("input", { type: "text", value: i, onChange: e => s(e.target.value), placeholder: "Enter your username", className: u.username ? "is-invalid" : "" }), u.username && (0, Ve.jsx)("div", { className: "invalid-feedback", children: u.username })] }), (0, Ve.jsxs)("div", { className: "form-sign", children: [(0, Ve.jsx)("input", { type: "email", value: o, onChange: e => a(e.target.value), placeholder: "Enter your email", className: u.email ? "is-invalid" : "" }), u.email && (0, Ve.jsx)("div", { className: "invalid-feedback", children: u.email })] }), (0, Ve.jsxs)("div", { className: "form-sign", children: [(0, Ve.jsx)("input", { type: "password", value: l, onChange: e => c(e.target.value), placeholder: "Enter your password", className: u.password ? "is-invalid" : "" }), u.password && (0, Ve.jsx)("div", { className: "invalid-feedback", children: u.password })] }), (0, Ve.jsxs)("div", { className: "login-link", children: [(0, Ve.jsx)("span", { className: "mr-2", children: "Already have an account?" }), (0, Ve.jsx)("button", { type: "button", className: "login-Link", onClick: () => f(!0), children: "Login" })] }), (0, Ve.jsx)("div", { className: "sign-in", children: (0, Ve.jsx)(mo, { variant: "primary", type: "submit", children: "Sign In" }) })] }), (0, Ve.jsx)("div", { className: "google-signin", children: (0, Ve.jsx)("button", { type: "button", onClick: async () => { try { const e = await async function (e, t, n) { if (Ty(e.app)) return Promise.reject(Zy(e, "operation-not-supported-in-this-environment")); const r = ow(e); tb(e, t, Aw); const i = fx(r, n); return new wx(r, "signInViaPopup", t, i).executeNotNull() }(fP, mP), r = e.user; if (r) { const e = jj(pP, "Users", r.uid), t = await function (e) { e = Ej(e, Aj); const t = Ej(e.firestore, Ij); return gj(Rj(t), e._key).then((n => dP(t, e, n))) }(e); t.exists() || await cP(e, { email: r.email, username: r.displayName || "" }) } console.log("Logged in with Google successfully"), n(), t() } catch (No) { console.error("Error signing in with Google:", No.message), d({ firebase: No.message }) } }, children: (0, Ve.jsx)("img", { className: "google-img", src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGVklEQVR4nN2be2wUVRSHh8cAFZSXoKCiIYohiOFxTgsiBebwiIgi3lRBCYFElIrhD0FJQEUjIxFJfQFqkMi7l6cBBWwZBEVJwCBIYnxGQCUEDgUCA0in6TW33W2WZtvuzs4+uif5/dk7830zc++5s1PDSHIxYXMm7M+EhUy4lAl3MeGvTFjGhOVMWMmEFUx4kQmPM+F+JlzLhHOZ8CEmbG80tmLCG5lwIhNuYsILTKgSiJZzkAlfYcIeRqbWOWuABu/DhMuZ0E0Quq7ou2UfEz7JlNvcyJRiQmDCHaETVCnKH6G7rGk6wW9hwlUpBq+dA3qOSSn46aG5Rsh+WRrBI+Mx4XwmNJMOz4StmXB1BkBHy/dMeFsy4bsx4ZEMAK0vJ5mwXzLgezHhvxkAGEs2nx6JgcL3ZsIzGQAWS7YzYasg4bsz4akMAIslW5mwZZDw7UJtq2oE2RjoKsCETZnwy4BPsjy0bn/EhLOYcBITPsGETzHhdCZcyIQ7mfB8nOOu03uOwOB1MeHMgKB1k1QSgmxrxFA8vGoDNYQJlzHh5QbGX8nDoZkRZDFhTya8GgD8Fj2BJngunZiwKHT31B5/WeCtMBM2YcK9CYKfYMJRAZ/X/bV6kCX6XIM8RlUxYUGC8PoZ7mAkoZgwhwmLmfDdpMB7jtns3Pjeicz6eiuc1G1q6A5NzuCeY44v39FSXXjhHj/wK9K6NU20PKe5FnDAc0yl4y7oqngExAq/JyU7sWSW55h9w/DhXF3RTpWN7dMQvG6RbzUae3mOWVRbgE751hx1fkrP+gRMMBp7VThmE88xj0cTUJXSFuri3Dujwe9jKwmzcarLc8z76oSPyJUlN6uzo/tFCiAjG8pzzBmxCNC5tqGNOje+t4Y/ylaSlqNUl+eYxbEKqJoXdrZUl17tNsvIlvIc85d4BIRybxDHtmx3vGW7Z9KQtWF403PM8jjhT+q+ISABky3bVWnIP9b8S1UC7vJx9bcFQp9eAZWW7bbWAvJ8CFiUBQJ0emgBI30IeDFLBAzUAh7xIeC5LBFAWsAYHwKmZYmAUVrAcB8CZmeJgOFaQH8fAhZniYBBWkAXHwK+zhIBvQxvt9nUc8zLcQq46Dlm8ywQ0KnqJDzHPOTjLhgcYCt8OoCUxwl/2bLd6q2855jL4oE/UdJWzdjy4HtGhtQw29Uij8Up4GjNAJ5jTo4Vfu+O25W1/lEFUpwBKYL7FTaBsmy3a6i1jUfAupoBPMfs5jlmZX3g15wWavG23grl4xo+nKlGBpRlu9N8PP8zawZQP96hJRyuC55LW6vCzfmR4OEcByly0glP1bf/Dz4E5F03kOeYc6LBH/6qsxq9YXQ0+HDeSPPVH+ED/pxlu9evYqHHoCISvviLHmqgHFcfvE45SJGWd2OW7ZqW7f7kQ0D1y5Da5TnmVg1+cVeOmvP5gIbAI3MMpOhspLgs233d5/o/NuqAnmPm/1nSXhVsHBkPfDgHQYq2KYQfY9luhQ943TO0qEuAkb9+7B4f8JESOqUAfqhlu67Pq2/XOzhIkQdSVCYg4S+QIimfrg6ZpzT8BMt2r/iE13/XpcEDgRSfJSBA5xpIMS/IRgmkaJ+7ZuqnQ9/5zQ94OEWxHqwjSHEqQQnhyfEZkML3p2sgxU0gxUsgBesxcd3TavD7u/3Al1m22zGeAz+c4KMQGX3yH4IUFEvjFLoA40CKlSDFpWhjPvDJx8p660I8AuLvWkGKhQEJqP14HAEpNoEUS0GKIpDiA5BiBUhREppDYhKft2K2Gvr237HAl9bs/OIU0Ayk2J4ECYEF105R+UUH64M/FdPEV1eBFG1Cy5vK3BSoQUuLlWVfqg3/X9Vrr0QLpOgAUhxKP2j9GbB8vhq24EwYXjdJBQnDhwukaAdSfJtuyIaSu7pQDVn0s2fZ7kQj6AIpWoEUq9IN2UAugyyI3usHIqFYaBHTQYqrGQBbO3oFCf6/RaIVSNErwybHNfoxNVJZUL1MPh/u0tKU30GK0SkFr6NdfQ2kOJtCcP06rhCkiL61TUeBFDfoF6UgxYEA2+jIVIAUpSBFAUiR2V+mghR3gxSzQIpd1TOzb2j9+n0zSPEsSNE4v0gFKUyQoi9IMQmkeDPU9+sW+xuQYj9I8V1I1EaQYjFI8TJI8RhI0R2kSOqHmP8DJd+m2qtTLUgAAAAASUVORK5CYII=", alt: "Sign in with Google" }) }) })] }) }) }) }) }, vP = () => { const [e, t] = (0, r.useState)(""), [n, i] = (0, r.useState)([]), [s, o] = (0, r.useState)([]), [a, l] = (0, r.useState)(!0), [c, u] = (0, r.useState)(!1); (0, r.useEffect)((() => { (async () => { if (c) try { const e = await Dg.get("http://localhost:5001/api/freelance/projects"); i(e.data.projects), o(e.data.projects) } catch (No) { console.error("Error fetching projects:", No) } })() }), [c]); const d = e => "http://localhost:5001/".concat(e); return (0, Ve.jsx)("div", { className: "mainsearch", children: (0, Ve.jsxs)("div", { className: "search-container", children: [a && !c && (0, Ve.jsx)(gP, { handleClose: () => l(!1), handleFormSubmit: () => { u(!0), l(!1) } }), !a && c && (0, Ve.jsxs)(Ve.Fragment, { children: [(0, Ve.jsxs)("div", { className: "search-input", children: [(0, Ve.jsx)("input", { type: "text", value: e, onChange: e => t(e.target.value), placeholder: "Search anything" }), (0, Ve.jsx)("button", { onClick: async () => { if (c) try { const t = await Dg.get("http://localhost:5001/api/freelance/search?searchTerm=".concat(e)); o(t.data.projects) } catch (No) { console.error("Error searching projects:", No) } else alert("You must be logged in to search for projects.") }, children: "Search" })] }), (0, Ve.jsx)("div", { className: "search-result", children: s.map((e => (0, Ve.jsxs)("div", { className: "project-item", children: [(0, Ve.jsx)("div", { className: "slider-container", children: (0, Ve.jsx)("div", { className: "slide-img", children: e.images && e.images.length > 0 && e.images.map(((t, n) => (0, Ve.jsx)("img", { src: d(t), width: "50", height: "60", alt: e.title, className: "slider-image", onError: e => e.target.style.display = "none" }, n))) }) }), (0, Ve.jsxs)("div", { className: "content-search", children: [(0, Ve.jsxs)("h3", { children: ["Title: ", e.title] }), (0, Ve.jsxs)("p", { children: ["Domain: ", e.domainname] }), (0, Ve.jsx)("h1", { children: "Project Detail:" }), (0, Ve.jsxs)("p", { className: "para44", children: [" ", e.projectdetail] }), (0, Ve.jsx)(Ce, { className: "link-search", to: "/freelance/".concat(e.title), children: "View Details" })] })] }, e.id))) })] })] }) }) }; function yP(e) { return e && e.stopPropagation && e.stopPropagation(), e && e.preventDefault && e.preventDefault(), !1 } function bP(e) { return null == e ? [] : Array.isArray(e) ? e.slice() : [e] } function wP(e) { return null !== e && 1 === e.length ? e[0] : e.slice() } function xP(e) { Object.keys(e).forEach((t => { "undefined" != typeof document && document.addEventListener(t, e[t], !1) })) } function EP(e, t) { return SP(function (e, t) { let n = e; return n <= t.min && (n = t.min), n >= t.max && (n = t.max), n }(e, t), t) } function SP(e, t) { const n = (e - t.min) % t.step; let r = e - n; return 2 * Math.abs(n) >= t.step && (r += n > 0 ? t.step : -t.step), parseFloat(r.toFixed(5)) } let NP = function (e) { function t(t) { var n; (n = e.call(this, t) || this).onKeyUp = () => { n.onEnd() }, n.onMouseUp = () => { n.onEnd(n.getMouseEventMap()) }, n.onTouchEnd = e => { e.preventDefault(), n.onEnd(n.getTouchEventMap()) }, n.onBlur = () => { n.setState({ index: -1 }, n.onEnd(n.getKeyDownEventMap())) }, n.onMouseMove = e => { n.setState({ pending: !0 }); const t = n.getMousePosition(e), r = n.getDiffPosition(t[0]), i = n.getValueFromPosition(r); n.move(i) }, n.onTouchMove = e => { if (e.touches.length > 1) return; n.setState({ pending: !0 }); const t = n.getTouchPosition(e); if (void 0 === n.isScrolling) { const e = t[0] - n.startPosition[0], r = t[1] - n.startPosition[1]; n.isScrolling = Math.abs(r) > Math.abs(e) } if (n.isScrolling) return void n.setState({ index: -1 }); const r = n.getDiffPosition(t[0]), i = n.getValueFromPosition(r); n.move(i) }, n.onKeyDown = e => { if (!(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey)) switch (n.setState({ pending: !0 }), e.key) { case "ArrowLeft": case "ArrowDown": case "Left": case "Down": e.preventDefault(), n.moveDownByStep(); break; case "ArrowRight": case "ArrowUp": case "Right": case "Up": e.preventDefault(), n.moveUpByStep(); break; case "Home": e.preventDefault(), n.move(n.props.min); break; case "End": e.preventDefault(), n.move(n.props.max); break; case "PageDown": e.preventDefault(), n.moveDownByStep(n.props.pageFn(n.props.step)); break; case "PageUp": e.preventDefault(), n.moveUpByStep(n.props.pageFn(n.props.step)) } }, n.onSliderMouseDown = e => { if (!n.props.disabled && 2 !== e.button) { if (n.setState({ pending: !0 }), !n.props.snapDragDisabled) { const t = n.getMousePosition(e); n.forceValueFromPosition(t[0], (e => { n.start(e, t[0]), xP(n.getMouseEventMap()) })) } yP(e) } }, n.onSliderClick = e => { if (!n.props.disabled && n.props.onSliderClick && !n.hasMoved) { const t = n.getMousePosition(e), r = EP(n.calcValue(n.calcOffsetFromPosition(t[0])), n.props); n.props.onSliderClick(r) } }, n.createOnKeyDown = e => t => { n.props.disabled || (n.start(e), xP(n.getKeyDownEventMap()), yP(t)) }, n.createOnMouseDown = e => t => { if (n.props.disabled || 2 === t.button) return; n.setState({ pending: !0 }); const r = n.getMousePosition(t); n.start(e, r[0]), xP(n.getMouseEventMap()), yP(t) }, n.createOnTouchStart = e => t => { if (n.props.disabled || t.touches.length > 1) return; n.setState({ pending: !0 }); const r = n.getTouchPosition(t); n.startPosition = r, n.isScrolling = void 0, n.start(e, r[0]), xP(n.getTouchEventMap()), function (e) { e.stopPropagation && e.stopPropagation() }(t) }, n.handleResize = () => { const e = window.setTimeout((() => { n.pendingResizeTimeouts.shift(), n.resize() }), 0); n.pendingResizeTimeouts.push(e) }, n.renderThumb = (e, t) => { const r = n.props.thumbClassName + " " + n.props.thumbClassName + "-" + t + " " + (n.state.index === t ? n.props.thumbActiveClassName : ""), i = { ref: e => { n["thumb" + t] = e }, key: n.props.thumbClassName + "-" + t, className: r, style: e, onMouseDown: n.createOnMouseDown(t), onTouchStart: n.createOnTouchStart(t), onFocus: n.createOnKeyDown(t), tabIndex: 0, role: "slider", "aria-orientation": n.props.orientation, "aria-valuenow": n.state.value[t], "aria-valuemin": n.props.min, "aria-valuemax": n.props.max, "aria-label": Array.isArray(n.props.ariaLabel) ? n.props.ariaLabel[t] : n.props.ariaLabel, "aria-labelledby": Array.isArray(n.props.ariaLabelledby) ? n.props.ariaLabelledby[t] : n.props.ariaLabelledby, "aria-disabled": n.props.disabled }, s = { index: t, value: wP(n.state.value), valueNow: n.state.value[t] }; return n.props.ariaValuetext && (i["aria-valuetext"] = "string" == typeof n.props.ariaValuetext ? n.props.ariaValuetext : n.props.ariaValuetext(s)), n.props.renderThumb(i, s) }, n.renderTrack = (e, t, r) => { const i = { key: n.props.trackClassName + "-" + e, className: n.props.trackClassName + " " + n.props.trackClassName + "-" + e, style: n.buildTrackStyle(t, n.state.upperBound - r) }, s = { index: e, value: wP(n.state.value) }; return n.props.renderTrack(i, s) }; let i = bP(t.value); i.length || (i = bP(t.defaultValue)), n.pendingResizeTimeouts = []; const s = []; for (let e = 0; e < i.length; e += 1)i[e] = EP(i[e], t), s.push(e); return n.resizeObserver = null, n.resizeElementRef = r.createRef(), n.state = { index: -1, upperBound: 0, sliderLength: 0, value: i, zIndices: s }, n } it(t, e); var n = t.prototype; return n.componentDidMount = function () { "undefined" != typeof window && (this.resizeObserver = new ResizeObserver(this.handleResize), this.resizeObserver.observe(this.resizeElementRef.current), this.resize()) }, t.getDerivedStateFromProps = function (e, t) { const n = bP(e.value); return n.length ? t.pending ? null : { value: n.map((t => EP(t, e))) } : null }, n.componentDidUpdate = function () { 0 === this.state.upperBound && this.resize() }, n.componentWillUnmount = function () { this.clearPendingResizeTimeouts(), this.resizeObserver && this.resizeObserver.disconnect() }, n.onEnd = function (e) { e && function (e) { Object.keys(e).forEach((t => { "undefined" != typeof document && document.removeEventListener(t, e[t], !1) })) }(e), this.hasMoved && this.fireChangeEvent("onAfterChange"), this.setState({ pending: !1 }), this.hasMoved = !1 }, n.getValue = function () { return wP(this.state.value) }, n.getClosestIndex = function (e) { let t = Number.MAX_VALUE, n = -1; const { value: r } = this.state, i = r.length; for (let s = 0; s < i; s += 1) { const i = this.calcOffset(r[s]), o = Math.abs(e - i); o < t && (t = o, n = s) } return n }, n.getMousePosition = function (e) { return [e["page" + this.axisKey()], e["page" + this.orthogonalAxisKey()]] }, n.getTouchPosition = function (e) { const t = e.touches[0]; return [t["page" + this.axisKey()], t["page" + this.orthogonalAxisKey()]] }, n.getKeyDownEventMap = function () { return { keydown: this.onKeyDown, keyup: this.onKeyUp, focusout: this.onBlur } }, n.getMouseEventMap = function () { return { mousemove: this.onMouseMove, mouseup: this.onMouseUp } }, n.getTouchEventMap = function () { return { touchmove: this.onTouchMove, touchend: this.onTouchEnd } }, n.getValueFromPosition = function (e) { const t = e / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min); return EP(this.state.startValue + t, this.props) }, n.getDiffPosition = function (e) { let t = e - this.state.startPosition; return this.props.invert && (t *= -1), t }, n.resize = function () { const { slider: e, thumb0: t } = this; if (!e || !t) return; const n = this.sizeKey(), r = e.getBoundingClientRect(), i = e[n], s = r[this.posMaxKey()], o = r[this.posMinKey()], a = t.getBoundingClientRect()[n.replace("client", "").toLowerCase()], l = i - a, c = Math.abs(s - o); this.state.upperBound === l && this.state.sliderLength === c && this.state.thumbSize === a || this.setState({ upperBound: l, sliderLength: c, thumbSize: a }) }, n.calcOffset = function (e) { const t = this.props.max - this.props.min; return 0 === t ? 0 : (e - this.props.min) / t * this.state.upperBound }, n.calcValue = function (e) { return e / this.state.upperBound * (this.props.max - this.props.min) + this.props.min }, n.calcOffsetFromPosition = function (e) { const { slider: t } = this, n = t.getBoundingClientRect(), r = n[this.posMaxKey()], i = n[this.posMinKey()]; let s = e - (window["page" + this.axisKey() + "Offset"] + (this.props.invert ? r : i)); return this.props.invert && (s = this.state.sliderLength - s), s -= this.state.thumbSize / 2, s }, n.forceValueFromPosition = function (e, t) { const n = this.calcOffsetFromPosition(e), r = this.getClosestIndex(n), i = EP(this.calcValue(n), this.props), s = this.state.value.slice(); s[r] = i; for (let o = 0; o < s.length - 1; o += 1)if (s[o + 1] - s[o] < this.props.minDistance) return; this.fireChangeEvent("onBeforeChange"), this.hasMoved = !0, this.setState({ value: s }, (() => { t(r), this.fireChangeEvent("onChange") })) }, n.clearPendingResizeTimeouts = function () { do { const e = this.pendingResizeTimeouts.shift(); clearTimeout(e) } while (this.pendingResizeTimeouts.length) }, n.start = function (e, t) { const n = this["thumb" + e]; n && n.focus(); const { zIndices: r } = this.state; r.splice(r.indexOf(e), 1), r.push(e), this.setState((n => ({ startValue: n.value[e], startPosition: void 0 !== t ? t : n.startPosition, index: e, zIndices: r }))) }, n.moveUpByStep = function (e) { void 0 === e && (e = this.props.step); const t = this.state.value[this.state.index], n = EP(this.props.invert && "horizontal" === this.props.orientation ? t - e : t + e, this.props); this.move(Math.min(n, this.props.max)) }, n.moveDownByStep = function (e) { void 0 === e && (e = this.props.step); const t = this.state.value[this.state.index], n = EP(this.props.invert && "horizontal" === this.props.orientation ? t + e : t - e, this.props); this.move(Math.max(n, this.props.min)) }, n.move = function (e) { const t = this.state.value.slice(), { index: n } = this.state, { length: r } = t, i = t[n]; if (e === i) return; this.hasMoved || this.fireChangeEvent("onBeforeChange"), this.hasMoved = !0; const { pearling: s, max: o, min: a, minDistance: l } = this.props; if (!s) { if (n > 0) { const r = t[n - 1]; e < r + l && (e = r + l) } if (n < r - 1) { const r = t[n + 1]; e > r - l && (e = r - l) } } t[n] = e, s && r > 1 && (e > i ? (this.pushSucceeding(t, l, n), function (e, t, n, r) { for (let i = 0; i < e; i += 1) { const s = r - i * n; t[e - 1 - i] > s && (t[e - 1 - i] = s) } }(r, t, l, o)) : e < i && (this.pushPreceding(t, l, n), function (e, t, n, r) { for (let i = 0; i < e; i += 1) { const e = r + i * n; t[i] < e && (t[i] = e) } }(r, t, l, a))), this.setState({ value: t }, this.fireChangeEvent.bind(this, "onChange")) }, n.pushSucceeding = function (e, t, n) { let r, i; for (r = n, i = e[r] + t; null !== e[r + 1] && i > e[r + 1]; r += 1, i = e[r] + t)e[r + 1] = SP(i, this.props) }, n.pushPreceding = function (e, t, n) { for (let r = n, i = e[r] - t; null !== e[r - 1] && i < e[r - 1]; r -= 1, i = e[r] - t)e[r - 1] = SP(i, this.props) }, n.axisKey = function () { return "vertical" === this.props.orientation ? "Y" : "X" }, n.orthogonalAxisKey = function () { return "vertical" === this.props.orientation ? "X" : "Y" }, n.posMinKey = function () { return "vertical" === this.props.orientation ? this.props.invert ? "bottom" : "top" : this.props.invert ? "right" : "left" }, n.posMaxKey = function () { return "vertical" === this.props.orientation ? this.props.invert ? "top" : "bottom" : this.props.invert ? "left" : "right" }, n.sizeKey = function () { return "vertical" === this.props.orientation ? "clientHeight" : "clientWidth" }, n.fireChangeEvent = function (e) { this.props[e] && this.props[e](wP(this.state.value), this.state.index) }, n.buildThumbStyle = function (e, t) { const n = { position: "absolute", touchAction: "none", willChange: this.state.index >= 0 ? this.posMinKey() : void 0, zIndex: this.state.zIndices.indexOf(t) + 1 }; return n[this.posMinKey()] = e + "px", n }, n.buildTrackStyle = function (e, t) { const n = { position: "absolute", willChange: this.state.index >= 0 ? this.posMinKey() + "," + this.posMaxKey() : void 0 }; return n[this.posMinKey()] = e, n[this.posMaxKey()] = t, n }, n.buildMarkStyle = function (e) { var t; return (t = { position: "absolute" })[this.posMinKey()] = e, t }, n.renderThumbs = function (e) { const { length: t } = e, n = []; for (let i = 0; i < t; i += 1)n[i] = this.buildThumbStyle(e[i], i); const r = []; for (let i = 0; i < t; i += 1)r[i] = this.renderThumb(n[i], i); return r }, n.renderTracks = function (e) { const t = [], n = e.length - 1; t.push(this.renderTrack(0, 0, e[0])); for (let r = 0; r < n; r += 1)t.push(this.renderTrack(r + 1, e[r], e[r + 1])); return t.push(this.renderTrack(n + 1, e[n], this.state.upperBound)), t }, n.renderMarks = function () { let { marks: e } = this.props; const t = this.props.max - this.props.min + 1; return "boolean" == typeof e ? e = Array.from({ length: t }).map(((e, t) => t)) : "number" == typeof e && (e = Array.from({ length: t }).map(((e, t) => t)).filter((t => t % e == 0))), e.map(parseFloat).sort(((e, t) => e - t)).map((e => { const t = this.calcOffset(e), n = { key: e, className: this.props.markClassName, style: this.buildMarkStyle(t) }; return this.props.renderMark(n) })) }, n.render = function () { const e = [], { value: t } = this.state, n = t.length; for (let r = 0; r < n; r += 1)e[r] = this.calcOffset(t[r], r); const i = this.props.withTracks ? this.renderTracks(e) : null, s = this.renderThumbs(e), o = this.props.marks ? this.renderMarks() : null; return r.createElement("div", { ref: e => { this.slider = e, this.resizeElementRef.current = e }, style: { position: "relative" }, className: this.props.className + (this.props.disabled ? " disabled" : ""), onMouseDown: this.onSliderMouseDown, onClick: this.onSliderClick }, i, s, o) }, t }(r.Component); NP.displayName = "ReactSlider", NP.defaultProps = { min: 0, max: 100, step: 1, pageFn: e => 10 * e, minDistance: 0, defaultValue: 0, orientation: "horizontal", className: "slider", thumbClassName: "thumb", thumbActiveClassName: "active", trackClassName: "track", markClassName: "mark", withTracks: !0, pearling: !1, disabled: !1, snapDragDisabled: !1, invert: !1, marks: [], renderThumb: e => r.createElement("div", e), renderTrack: e => r.createElement("div", e), renderMark: e => r.createElement("span", e) }; var CP = NP; const TP = e => { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1), [s, o] = (0, r.useState)(!0), [a, l] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [c, u] = (0, r.useState)({ Name: "", projectname: "", mobileNumber: "", gmail: "", price: "", message: "" }), [d, h] = (0, r.useState)([]), [f, p] = (0, r.useState)([]), [m, g] = (0, r.useState)([0, 5e4]), [v, y] = (0, r.useState)(0), [b, w] = (0, r.useState)(5e4), x = e => { const { name: t, value: n } = e.target; u({ ...c, [t]: n }) }, E = () => { l(!0), o(!1) }; return (0, Ve.jsxs)("div", { className: "allsell", children: [(0, Ve.jsx)("div", { className: "head-sell text-nowrap", children: "PROJECT SELLING FORM" }), (0, Ve.jsx)("div", { className: "container contsell", children: (0, Ve.jsx)("div", { className: "body-sell", children: a ? (0, Ve.jsxs)("form", { onSubmit: e => { e.preventDefault(), a ? (console.log("Form Data:", c), console.log("ZIP Files:", d), console.log("Image Files:", f), console.log("Price Range:", m), i(!0)) : alert("You must be logged in to submit the form.") }, children: [(0, Ve.jsxs)("div", { className: "row sell-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-sm-2 col-md-3 col-2 sell", children: [(0, Ve.jsx)("input", { className: "input-sell", type: "text", id: "Name", name: "Name", value: c.Name, onChange: x, required: !0 }), (0, Ve.jsx)("label", { className: "label-sell", htmlFor: "Name", children: "Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-sm-3 col-md-3 col-3 sell", children: [(0, Ve.jsx)("input", { className: "input-sell", type: "text", id: "projectname", name: "projectname", value: c.projectname, onChange: x, required: !0 }), (0, Ve.jsx)("label", { className: "label-sell", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-sm-2 col-md-3 col-2 sell", children: [(0, Ve.jsx)("input", { className: "input-sell", type: "text", id: "mobileNumber", name: "mobileNumber", value: c.mobileNumber, onChange: x, required: !0 }), (0, Ve.jsx)("label", { className: "label-sell", htmlFor: "mobileNumber", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-sm-3 col-md-3 col-3 sell", children: [(0, Ve.jsx)("input", { className: "input-sell", type: "email", id: "gmail", name: "gmail", value: c.gmail, onChange: x, required: !0 }), (0, Ve.jsx)("label", { className: "label-sell", htmlFor: "gmail", children: "Email" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-12 col-12 sell", children: [(0, Ve.jsx)(CP, { min: 0, max: 5e4, value: m, onChange: e => { g(e), y(e[0]), w(e[1]) }, className: "slider", pearling: !0 }), (0, Ve.jsxs)("div", { className: "price-range-labels", children: [(0, Ve.jsx)("h6", { children: "Min-Price:" }), (0, Ve.jsx)("input", { className: "input-h6", type: "number", value: v, onChange: e => { const t = parseInt(e.target.value, 10); t <= m[1] && (y(t), g([t, m[1]])) }, onBlur: () => { v < 0 && (y(0), g([0, m[1]])) }, min: 0 }), (0, Ve.jsx)("h7", { children: "Max-Price:" }), (0, Ve.jsx)("input", { className: "input-h7", type: "number", value: b, onChange: e => { const t = parseInt(e.target.value, 10); t >= m[0] && (w(t), g([m[0], t])) }, onBlur: () => { b > 5e4 && (w(5e4), g([m[0], 5e4])) }, min: 0 })] })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-12 col-12 sell-zip", children: [(0, Ve.jsx)("label", { className: "label-file1", htmlFor: "zipFileInput", children: "Upload only ZIP files" }), (0, Ve.jsx)("input", { type: "file", accept: ".zip", id: "zipFileInput", multiple: !0, onChange: e => { const t = Array.from(e.target.files).filter((e => e.name.endsWith(".zip"))); t.length !== Array.from(e.target.files).length && alert("Some files are not ZIP files and will not be uploaded."), h([...d, ...t]) }, placeholder: "Upload ZIP files" }), d.map(((e, t) => (0, Ve.jsx)("div", { className: "file-itemzip", children: (0, Ve.jsxs)("span", { children: [e.name, (0, Ve.jsx)("button", { type: "button", onClick: () => (e => { h(d.filter(((t, n) => n !== e))) })(t), children: "x" })] }) }, t)))] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-12 col-12 sell", children: [(0, Ve.jsx)("label", { className: "label-file", htmlFor: "imageFileInput", children: "Upload Image files" }), (0, Ve.jsx)("input", { type: "file", accept: "image/*", id: "imageFileInput", multiple: !0, onChange: e => { const t = Array.from(e.target.files).filter((e => !!(e.type.startsWith("image/") && e.size <= 10485760) || (alert("".concat(e.name, " is not a valid image file or exceeds the 10MB size limit.")), !1))); p([...f, ...t]) } }), f.map(((e, t) => (0, Ve.jsx)("div", { className: "file-item", children: (0, Ve.jsxs)("span", { children: [e.name, (0, Ve.jsx)("button", { type: "button", onClick: () => (e => { p(f.filter(((t, n) => n !== e))) })(t), children: "x" })] }) }, t)))] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-12 col-12 sell", children: [(0, Ve.jsx)("textarea", { id: "message", name: "message", value: c.message, onChange: x, rows: 4, required: !0 }), (0, Ve.jsx)("label", { className: "sell-label", htmlFor: "message", children: "Enter your message..." })] })] }), (0, Ve.jsx)("button", { className: "sell-button", type: "submit", children: "Submit" })] }) : (0, Ve.jsx)(gP, { handleClose: () => o(!1), handleFormSubmit: E }) }) }), s && (0, Ve.jsx)(gP, { handleClose: () => o(!1), handleFormSubmit: E })] }) }; function AP() { const e = (0, r.useRef)(!1); return Vo((() => (e.current = !0, () => { e.current = !1 })), []), e } class kP extends r.Component { getSnapshotBeforeUpdate(e) { const t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { const e = this.props.sizeRef.current; e.height = t.offsetHeight || 0, e.width = t.offsetWidth || 0, e.top = t.offsetTop, e.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function jP(e) { let { children: t, isPresent: n } = e; const i = (0, r.useId)(), s = (0, r.useRef)(null), o = (0, r.useRef)({ width: 0, height: 0, top: 0, left: 0 }), { nonce: a } = (0, r.useContext)(Lo); return (0, r.useInsertionEffect)((() => { const { width: e, height: t, top: r, left: l } = o.current; if (n || !s.current || !e || !t) return; s.current.dataset.motionPopId = i; const c = document.createElement("style"); return a && (c.nonce = a), document.head.appendChild(c), c.sheet && c.sheet.insertRule('\n          [data-motion-pop-id="'.concat(i, '"] {\n            position: absolute !important;\n            width: ').concat(e, "px !important;\n            height: ").concat(t, "px !important;\n            top: ").concat(r, "px !important;\n            left: ").concat(l, "px !important;\n          }\n        ")), () => { document.head.removeChild(c) } }), [n]), (0, Ve.jsx)(kP, { isPresent: n, childRef: s, sizeRef: o, children: r.cloneElement(t, { ref: s }) }) } const PP = e => { let { children: t, initial: n, isPresent: i, onExitComplete: s, custom: o, presenceAffectsLayout: a, mode: l } = e; const c = yl(IP), u = (0, r.useId)(), d = (0, r.useMemo)((() => ({ id: u, initial: n, isPresent: i, custom: o, onExitComplete: e => { c.set(e, !0); for (const t of c.values()) if (!t) return; s && s() }, register: e => (c.set(e, !1), () => c.delete(e)) })), a ? [Math.random()] : [i]); return (0, r.useMemo)((() => { c.forEach(((e, t) => c.set(t, !1))) }), [i]), r.useEffect((() => { !i && !c.size && s && s() }), [i]), "popLayout" === l && (t = (0, Ve.jsx)(jP, { isPresent: i, children: t })), (0, Ve.jsx)(Uo.Provider, { value: d, children: t }) }; function IP() { return new Map } const RP = e => e.key || ""; const OP = e => { let { children: t, custom: n, initial: i = !0, onExitComplete: s, exitBeforeEnter: o, presenceAffectsLayout: a = !0, mode: l = "sync" } = e; yc(!o, "Replace exitBeforeEnter with mode='wait'"); const c = (0, r.useContext)(ua).forceRender || function () { const e = AP(), [t, n] = (0, r.useState)(0), i = (0, r.useCallback)((() => { e.current && n(t + 1) }), [t]); return [(0, r.useCallback)((() => Tl.postRender(i)), [i]), t] }()[0], u = AP(), d = function (e) { const t = []; return r.Children.forEach(e, (e => { (0, r.isValidElement)(e) && t.push(e) })), t }(t); let h = d; const f = (0, r.useRef)(new Map).current, p = (0, r.useRef)(h), m = (0, r.useRef)(new Map).current, g = (0, r.useRef)(!0); if (Vo((() => { g.current = !1, function (e, t) { e.forEach((e => { const n = RP(e); t.set(n, e) })) }(d, m), p.current = h })), function (e) { (0, r.useEffect)((() => () => e()), []) }((() => { g.current = !0, m.clear(), f.clear() })), g.current) return (0, Ve.jsx)(Ve.Fragment, { children: h.map((e => (0, Ve.jsx)(PP, { isPresent: !0, initial: !!i && void 0, presenceAffectsLayout: a, mode: l, children: e }, RP(e)))) }); h = [...h]; const v = p.current.map(RP), y = d.map(RP), b = v.length; for (let r = 0; r < b; r++) { const e = v[r]; -1 !== y.indexOf(e) || f.has(e) || f.set(e, void 0) } return "wait" === l && f.size && (h = []), f.forEach(((e, t) => { if (-1 !== y.indexOf(t)) return; const r = m.get(t); if (!r) return; const i = v.indexOf(t); let o = e; if (!o) { const e = () => { f.delete(t); const e = Array.from(m.keys()).filter((e => !y.includes(e))); if (e.forEach((e => m.delete(e))), p.current = d.filter((n => { const r = RP(n); return r === t || e.includes(r) })), !f.size) { if (!1 === u.current) return; c(), s && s() } }; o = (0, Ve.jsx)(PP, { isPresent: !1, onExitComplete: e, custom: n, presenceAffectsLayout: a, mode: l, children: r }, RP(r)), f.set(t, o) } h.splice(i, 0, o) })), h = h.map((e => { const t = e.key; return f.has(t) ? e : (0, Ve.jsx)(PP, { isPresent: !0, presenceAffectsLayout: a, mode: l, children: e }, RP(e)) })), (0, Ve.jsx)(Ve.Fragment, { children: f.size ? h : h.map((e => (0, r.cloneElement)(e))) }) }; function DP(e) { let { showModel: t, setShowModel: n } = e; return (0, Ve.jsx)(OP, { mode: "wait", children: t && (0, Ve.jsx)(rp.div, { className: "backdrop", variants: { visible: { opacity: 1 }, hidden: { opacity: 0 }, exit: { opacity: 0 } }, initial: "hidden", animate: "visible", exit: "exit", children: (0, Ve.jsxs)(rp.div, { className: "show-drop", variants: { hidden: { y: "-100vh", opacity: 0 }, visible: { y: "250px", opacity: 1, transition: { delay: .3 } } }, children: [(0, Ve.jsxs)("p", { children: ["Thank you for visiting! ", (0, Ve.jsx)("br", {}), "We contact us"] }), (0, Ve.jsx)(Ce, { to: "/", children: (0, Ve.jsx)("button", { onClick: () => n(!1), children: "EXIT" }) })] }) }) }) } const _P = function (e) { let { setShowModel: t } = e; const n = 864e5, [i, s] = (0, r.useState)(!1), [o, a] = (0, r.useState)(null); (0, r.useEffect)((() => { const e = localStorage.getItem("formSubmittedTimestamp"); if (e) { const t = parseInt(e, 10), r = Date.now(); r - t < n ? (s(!0), a(n - (r - t))) : localStorage.removeItem("formSubmittedTimestamp") } }), []), (0, r.useEffect)((() => { if (o > 0) { const e = setInterval((() => { a((t => { const n = t - 1e3; return n <= 0 ? (clearInterval(e), localStorage.removeItem("formSubmittedTimestamp"), s(!1), 0) : n })) }), 1e3); return () => clearInterval(e) } }), [o]); const [l, c] = (0, r.useState)({ teamName: "", leaderName: "", projectTitle: "", projectName: "", mobileNumber: "", gmail: "", college: "", groupOrSolo: "", solutionStatement: "", whatToDo: "" }), u = e => { const { name: t, value: n } = e.target; c({ ...l, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "all", children: [(0, Ve.jsx)("div", { className: "head-final text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container cont", children: (0, Ve.jsx)("div", { className: "body-final", children: i ? (0, Ve.jsx)("p", { children: "You have already submitted the form. Please try again later." }) : (0, Ve.jsx)("form", { className: "form", onSubmit: async e => { e.preventDefault(); try { const e = await fetch("http://localhost:5000/submit-form", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(l) }), t = await e.json(); console.log(t) } catch (No) { console.error("Error submitting form", No) } const r = Date.now(); localStorage.setItem("formSubmittedTimestamp", r.toString()), s(!0), a(n); const i = setTimeout((() => { t(!0) }), 500); return () => clearTimeout(i) }, children: (0, Ve.jsxs)("div", { className: "row final-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3  col-4 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "tname", name: "teamName", value: l.teamName, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "tname", children: "Team Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3 col-5 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "lname", name: "leaderName", value: l.leaderName, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "lname", children: "Leader Name" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-3 col-md-3 col-4 final", children: (0, Ve.jsxs)("select", { className: "selectfinal", name: "projectTitle", value: l.projectTitle, onChange: e => { c({ ...l, projectTitle: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "PROJECT" }), (0, Ve.jsx)("option", { value: "miniproject", children: "mini project" }), (0, Ve.jsx)("option", { value: "softwaredevelopment", children: "software development" }), (0, Ve.jsx)("option", { value: "finalyearproject", children: "final year project" })] }) }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3 col-5 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "tel", id: "num", name: "mobileNumber", value: l.mobileNumber, onChange: u, maxLength: "10", pattern: "[0-9]{1,10}", title: "Please enter a valid mobile number (up to 10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: "labelfi text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3 col-4 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "email", id: "ename", name: "gmail", value: l.gmail, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "ename", children: "Gmail" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3 col-5 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "cname", name: "college", value: l.college, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "cname", children: "College/University/Institute" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-3 col-4 final", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "pname", name: "projectName", value: l.projectName, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "pname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-md-3  col-1 final", children: [(0, Ve.jsx)("input", { className: "gbutton", type: "radio", id: "rbutton", name: "groupOrSolo", value: "group", onChange: u }), (0, Ve.jsx)("label", { className: "radio-button", htmlFor: "rbutton", children: "Group" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-1 final", children: [(0, Ve.jsx)("input", { className: "rbutton", type: "radio", id: "gbutton", name: "groupOrSolo", value: "solo", onChange: u }), (0, Ve.jsx)("label", { className: "radio-rbutton", htmlFor: "gbutton", children: "Solo" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea final", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "taname", cols: "30", rows: "10", name: "solutionStatement", value: l.solutionStatement, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "taname", children: "Solution Statement" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea final", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "saname", cols: "30", rows: "10", name: "whatToDo", value: l.whatToDo, onChange: u, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "saname", children: "What Should We Do" })] }), (0, Ve.jsx)("div", { className: "form-group button final", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] }) }) }) })] }) }; const MP = function () { return (0, Ve.jsx)("div", { className: "modify-all", children: (0, Ve.jsx)("div", { className: "container modify-cont", children: (0, Ve.jsx)("div", { className: "body-button", children: (0, Ve.jsx)("div", { className: "row modify", children: (0, Ve.jsxs)("div", { className: "link-border", children: [(0, Ve.jsx)("div", { className: "col-lg-3 col-6 col-md-2 background-button", children: (0, Ve.jsx)(Ce, { className: "link-button", to: "/modify/hardmodify", children: " hardwaremodification" }) }), (0, Ve.jsx)("div", { className: "col-lg-2 col-md-2 col-4 ", children: (0, Ve.jsx)(Ce, { className: "link-button", to: "/modify/softmodify", children: " softwaremodification" }) })] }) }) }) }) }) }; const LP = function (e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ teamName: "", leaderName: "", paperName: "", mobileNumber: "", gmail: "", groupOrSolo: "", solutionStatement: "", whatToDo: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allpaper", children: [(0, Ve.jsx)("div", { className: "head-paper text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contpaper", children: (0, Ve.jsx)("div", { className: "body-paper", children: (0, Ve.jsx)("form", { className: "form", onSubmit: async e => { e.preventDefault(); try { const e = await fetch("http://localhost:5000/submit-form", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(s) }), t = await e.json(); console.log(t) } catch (No) { console.error("Error submitting form", No) } i(!0) }, children: (0, Ve.jsxs)("div", { className: "row paper-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-sm-1 col-md-2   col-1 paper", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "tname", name: "teamName", value: s.teamName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "tname", children: "Team Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-1 col-md-2    col-1 paper", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "lname", name: "leaderName", value: s.leaderName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "lname", children: "Leader Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-1 col-md-2  col-1 paper", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "tel", id: "num", name: "mobileNumber", value: s.mobileNumber, onChange: a, maxLength: "10", pattern: "[0-9]{1,10}", title: "Please enter a valid mobile number (up to 10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: "labelfi text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-1 col-md-2  col-1 paper", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "email", id: "ename", name: "gmail", value: s.gmail, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "ename", children: "Gmail" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-1 col-md-2  col-1 paper", children: [(0, Ve.jsx)("input", { className: "inputfi", type: "text", id: "pname", name: "paperName", value: s.paperName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelfi", htmlFor: "pname", children: "Paper Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-2 col-md-2  col-1 paper", children: [(0, Ve.jsx)("input", { className: "gbutton ", type: "radio", id: "rbutton", name: "groupOrSolo", value: "group", onChange: a }), (0, Ve.jsx)("label", { className: "radio-button", htmlFor: "rbutton", children: "Group" })] }), (0, Ve.jsxs)("div", { className: "form-group col-sm-2 col-md-2  col-1 paper", children: [(0, Ve.jsx)("input", { className: "rbutton", type: "radio", id: "gbutton", name: "groupOrSolo", value: "solo", onChange: a }), (0, Ve.jsx)("label", { className: "radio-rbutton", htmlFor: "gbutton", children: "Solo" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea paper", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "taname", cols: "30", rows: "10", name: "solutionStatement", value: s.solutionStatement, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "taname", children: "Solution Statement" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea paper", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "saname", cols: "30", rows: "10", name: "whatToDo", value: s.whatToDo, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "saname", children: "What Should We Do" })] }), (0, Ve.jsx)("div", { className: "form-group button paper", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] }) }) }) })] }) }; const FP = function (e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ teamName: "", leaderName: "", projectTitle: "", hackathondate: "", hackathon: "", mobileNumber: "", gmail: "", college: "", groupOrSolo: "", solutionStatement: "", whatToDo: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allhack", children: [(0, Ve.jsx)("div", { className: "head-hack text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container cont-hack", children: (0, Ve.jsx)("div", { className: "body-hack", children: (0, Ve.jsx)("form", { className: "form", onSubmit: async e => { e.preventDefault(); try { const e = await fetch("http://localhost:5000/submit-form", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(s) }), t = await e.json(); console.log(t) } catch (No) { console.error("Error submitting form", No) } i(!0) }, children: (0, Ve.jsxs)("div", { className: "row hack-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2  hack", children: [(0, Ve.jsx)("input", { className: "inputha1 ", type: "text", id: "teamName", name: "teamName", value: s.teamName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha1", htmlFor: "teamName", children: "Team Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2  hack", children: [(0, Ve.jsx)("input", { className: "inputha2", type: "text", id: "leaderName", name: "leaderName", value: s.leaderName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha2", htmlFor: "leaderName", children: "Leader Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2  hack", children: [(0, Ve.jsx)("input", { className: "inputha1", type: "tel", id: "mobileNumber", name: "mobileNumber", value: s.mobileNumber, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: "labelha1 text-nowrap", htmlFor: "mobileNumber", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2  hack", children: [(0, Ve.jsx)("input", { className: "inputha2", type: "email", id: "gmail", name: "gmail", value: s.gmail, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha2", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1  col-sm-1 col-md-2 col-lg-2 hack", children: [(0, Ve.jsx)("input", { className: "inputha1", type: "text", id: "college", name: "college", value: s.college, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha1", htmlFor: "college", children: "College/University/Institute" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2  hack", children: [(0, Ve.jsx)("input", { className: "inputha2", type: "text", id: "projectTitle", name: "projectTitle", value: s.projectTitle, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha2", htmlFor: "projectTitle", children: "Project Title" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2 hack", children: [(0, Ve.jsx)("input", { className: "inputha1", type: "number", id: "year", name: "hackathondate", value: s.hackathondate, onChange: a, pattern: "[0-9]{4}", title: "Please enter a valid year (e.g., 2024)", required: !0 }), (0, Ve.jsx)("label", { className: "labelha1", htmlFor: "year", children: "Hackathon last date" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-sm-1 col-md-2 col-lg-2 hack", children: [(0, Ve.jsx)("input", { className: "inputha2", type: "text", id: "hackathon", name: "hackathon", value: s.hackathon, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelha2", htmlFor: "hackathon", children: "Hackathon Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-3 col-md-2 col-sm-2 col-1  hack", children: [(0, Ve.jsx)("input", { className: "rbutton", type: "radio", id: "group", name: "groupOrSolo", value: "group", onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "radio-button", htmlFor: "group", children: "Group" })] }), (0, Ve.jsxs)("div", { className: "form-group col-1 col-lg-3 hack", children: [(0, Ve.jsx)("input", { className: "gbutton", type: "radio", id: "solo", name: "groupOrSolo", value: "solo", onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "radio-sbutton", htmlFor: "solo", children: "Solo" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea hack", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "solutionStatement", cols: "30", rows: "10", name: "solutionStatement", value: s.solutionStatement, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "solutionStatement", children: "Solution Statement" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea hack", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "whatToDo", cols: "30", rows: "10", name: "whatToDo", value: s.whatToDo, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "whatToDo", children: "What Should We Do" })] }), (0, Ve.jsx)("div", { className: "form-group button hack", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] }) }) }) })] }) }; function UP(e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ Name: "", choose: "", components: "", projectName: "", mobileNumber: "", gmail: "", groupOrSolo: "", solutionStatement: "", whatToDo: "", repair: "", buildhardware: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allhard", children: [(0, Ve.jsx)("div", { className: "head-hard text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container cont-hard", children: (0, Ve.jsx)("div", { className: "body-hard", children: (0, Ve.jsx)("form", { className: "form", onSubmit: async e => { e.preventDefault(); try { const e = await fetch("http://localhost:5000/submit-form", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(s) }), t = await e.json(); console.log(t) } catch (No) { console.error("Error submitting form", No) } i(!0) }, children: (0, Ve.jsxs)("div", { className: "row hard-project", children: [(0, Ve.jsxs)("div", { className: "form-group  col-md-2 col-sm-1 col-1 hard", children: [(0, Ve.jsx)("input", { className: "inputhi", type: "text", id: "name", name: "Name", value: s.Name, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelhi", htmlFor: "name", children: "Name" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2 col-1 hard", children: [(0, Ve.jsx)("input", { className: "inputhi", type: "text", id: "pname", name: "projectName", value: s.projectName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelhi", htmlFor: "pname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2 col-1 hard", children: [(0, Ve.jsx)("input", { className: "inputhi", type: "email", id: "ename", name: "gmail", value: s.gmail, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelhi", htmlFor: "ename", children: "Gmail" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2 col-1 hard", children: [(0, Ve.jsx)("input", { className: "inputhi", type: "tel", id: "num", name: "mobileNumber", value: s.mobileNumber, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: "labelhi text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsx)("div", { className: "form-group  col-sm-1 col-md-2 col-1 hard", children: (0, Ve.jsxs)("select", { className: "selecthard", name: "choose", value: s.choose, onChange: e => { o({ ...s, choose: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Choose" }), (0, Ve.jsx)("option", { value: "repair", children: "Repair" }), (0, Ve.jsx)("option", { value: "build hardware", children: "Build Hardware" })] }) }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2 col-1 hard", children: [(0, Ve.jsx)("textarea", { className: "inputhack", id: "components", name: "components", value: s.components, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelhack", htmlFor: "components", children: "Components" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2  col-1 hard", children: [(0, Ve.jsx)("input", { className: "rbutton", type: "radio", id: "group", name: "groupOrSolo", value: "group", onChange: a }), (0, Ve.jsx)("label", { className: "radio-button", htmlFor: "group", children: "Group" })] }), (0, Ve.jsxs)("div", { className: "form-group  col-sm-1 col-md-2   col-1 hard", children: [(0, Ve.jsx)("input", { className: "sbutton", type: "radio", id: "solo", name: "groupOrSolo", value: "solo", onChange: a }), (0, Ve.jsx)("label", { className: "radio-sbutton", htmlFor: "solo", children: "Solo" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea hard", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "solutionStatement", name: "solutionStatement", value: s.solutionStatement, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "solutionStatement", children: "Solution Statement" })] }), (0, Ve.jsxs)("div", { className: "form-group textarea hard", children: [(0, Ve.jsx)("textarea", { className: "textarea-project", id: "whatToDo", name: "whatToDo", value: s.whatToDo, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelftxt text-nowrap", htmlFor: "whatToDo", children: "What Should Do" })] }), (0, Ve.jsx)("div", { className: "form-group button hard", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] }) }) }) })] }) } const BP = function () { return (0, Ve.jsx)("div", { className: "manageall", children: (0, Ve.jsx)("div", { className: "manage-content", children: (0, Ve.jsx)("div", { className: "manage-list", children: (0, Ve.jsxs)("ul", { children: [(0, Ve.jsxs)(Ce, { className: "linkto", to: "/manage/school", children: [" ", (0, Ve.jsx)("li", { children: "school" }), " "] }), (0, Ve.jsxs)(Ce, { className: "linkto", to: "/manage/college", children: [" ", (0, Ve.jsx)("li", { children: "college" }), " "] }), (0, Ve.jsx)(Ce, { className: "linkto", to: "/manage/office", children: (0, Ve.jsx)("li", { children: " office" }) }), (0, Ve.jsxs)(Ce, { className: "linkto", to: "/manage/hospital", children: [(0, Ve.jsx)("li", { children: "hospital" }), " "] })] }) }) }) }) }; const VP = function (e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ companyName: "", mailId: "", number: "", team: "", projectDetail: "", what: "", selectValue: "", teamdetials: "", howManyMember: "", startDate: "", endDate: "", meetingArrangement: "", preference: "", whatTime: "", message: "", frontend: "", backend: "", fullstack: "", machinelearning: "", other: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allcomp", children: [(0, Ve.jsx)("div", { className: "head-comp text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container cont-comp", children: (0, Ve.jsxs)("div", { className: "body-comp", children: [(0, Ve.jsx)("form", { className: "form", onSubmit: async e => { e.preventDefault(); try { const e = await fetch("http://localhost:5000/submit-form", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(s) }), t = await e.json(); console.log(t) } catch (No) { console.error("Error submitting form", No) } i(!0) }, children: (0, Ve.jsxs)("div", { className: "row comp-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: [(0, Ve.jsx)("input", { className: "inputcomp", type: "text", id: "companyName", name: "companyName", value: s.companyName, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelcomp", htmlFor: "companyName", children: "Company Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: [(0, Ve.jsx)("input", { className: "inputcomp", type: "email", id: "mailId", name: "mailId", value: s.mailId, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelcomp", htmlFor: "mailId", children: "Mail ID" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: [(0, Ve.jsx)("input", { className: " inputcomp", type: "tel", id: "num", name: "mobileNumber", value: s.mobileNumber, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelcomp text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsxs)("select", { className: "selectcomp", name: "selectValue", value: s.selectValue, onChange: e => { o({ ...s, selectValue: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select an option" }), (0, Ve.jsx)("option", { value: "project", children: "Project" }), (0, Ve.jsx)("option", { value: "team", children: " Hire Team" }), (0, Ve.jsx)("option", { value: "meeting", children: "Meeting" })] }) }), "project" === s.selectValue && (0, Ve.jsxs)("div", { children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: [(0, Ve.jsx)("textarea", { className: "textareacomp", id: "projectDetail", name: "projectDetail", value: s.projectDetail, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labeltxtcomp", htmlFor: "projectDetail", children: "Project Detail" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", style: { marginBottom: "100px" }, children: [(0, Ve.jsx)("textarea", { className: "textareacomp", id: "what", name: "what", value: s.what, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labeltxtcomp", htmlFor: "what", children: "What to do" })] }), (0, Ve.jsx)("div", { className: "row", children: (0, Ve.jsx)("div", { className: "form-group button comp", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) }) })] }), "team" === s.selectValue && (0, Ve.jsxs)("div", { children: [(0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsxs)("select", { className: "selectcomp", name: "teamdetials", value: s.teamdetials, onChange: a, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Team Peference " }), (0, Ve.jsx)("option", { value: "machinelearning", children: "Machine Learning" }), (0, Ve.jsx)("option", { value: "frontend", children: "Frontend" }), (0, Ve.jsx)("option", { value: "backend", children: "Backend" }), (0, Ve.jsx)("option", { value: "fullstack", children: "Fullstack" }), (0, Ve.jsx)("option", { value: "other", children: "Others" })] }) }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp text-nowrap", children: [(0, Ve.jsx)("input", { className: "inputcomp", type: "number", name: "howManyMember", value: s.howManyMember, onChange: a, maxLength: "1000", required: !0 }), (0, Ve.jsx)("label", { className: "labelcomp", htmlFor: "howManyMember", children: "How Many Members" })] })] }), (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsx)("input", { className: "teamcomp", type: "date", name: "startDate", value: s.startDate, onChange: a, "data-placeholder": "Start Date", required: !0 }) }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsx)("input", { className: "teamcomp", type: "date", name: "endDate", value: s.endDate, onChange: a, "data-placeholder": "End Date", required: !0 }) })] }), (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsxs)("select", { className: "teamselectcomp", name: "meetingArrangement", value: s.meetingArrangement, onChange: a, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Preference" }), (0, Ve.jsx)("option", { value: "online", children: "Online" }), (0, Ve.jsx)("option", { value: "offline", children: "Offline" })] }) }), (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", style: { marginBottom: "100px", marginTop: "-80px" }, children: [(0, Ve.jsx)("textarea", { className: "textareacomp", id: "message", name: "message", value: s.message, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labeltxtcomp", htmlFor: "message", children: "Message" })] }), (0, Ve.jsx)("div", { className: "form-group button comp", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] })] })] }), "meeting" === s.selectValue && (0, Ve.jsxs)("div", { children: [(0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", style: { marginBottom: "30px" }, children: (0, Ve.jsx)("input", { className: "teamcomp", type: "date", name: "startDate", value: s.startDate, onChange: a, "data-placeholder": "Start Date", required: !0 }) }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsx)("input", { className: "teamcomp", type: "date", name: "endDate", value: s.endDate, onChange: a, "data-placeholder": "End Date", required: !0 }) })] }), (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsx)("input", { className: "teamcomp", type: "time", name: "whatTime", value: s.whatTime, onChange: a, "data-placeholder": "what time" }) }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", children: (0, Ve.jsxs)("select", { className: "teamselectcomp2", name: "meetingArrangement", value: s.meetingArrangement, onChange: a, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Preference" }), (0, Ve.jsx)("option", { value: "online", children: "Online" }), (0, Ve.jsx)("option", { value: "offline", children: "Offline" })] }) })] }), (0, Ve.jsxs)("div", { className: "row", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 comp", style: { marginBottom: "100px", marginTop: "30px" }, children: [(0, Ve.jsx)("textarea", { className: "textareacomp", id: "message", name: "message", value: s.message, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labeltxtcomp", htmlFor: "message", children: "Message" })] }), (0, Ve.jsx)("div", { className: "form-group button comp", children: (0, Ve.jsx)("button", { type: "submit", children: "SUBMIT" }) })] })] })] }) }), (0, Ve.jsxs)("div", { className: "scroll-down1 ", children: [(0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {}), (0, Ve.jsx)("span", {})] }), (0, Ve.jsx)("h1", { children: "scroll up" })] }) })] }) }; const zP = function () { return (0, Ve.jsx)("div", { className: "photo-background", children: (0, Ve.jsxs)("div", { className: "row rowback", children: [(0, Ve.jsx)("div", { className: "col-lg-6 col-sm-6 col-md-6", children: (0, Ve.jsx)("div", { "data-aos": "fade-up-right", "data-aos-easing": "linear", "data-aos-duration": "1500", children: (0, Ve.jsx)("img", { className: "photo", src: Ro, alt: "" }) }) }), (0, Ve.jsx)("div", { "data-aos": "fade-up-left", "data-aos-easing": "linear", "data-aos-duration": "1500", className: "col-lg-6 col-sm-12 col-md-6", children: (0, Ve.jsx)("p", { children: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Illum ullam sit inventore odio error id, natus assumenda obcaecati placeat, in eum, ut dolore molestias ad nostrum doloremque labore! Vel, ullam. Lorem ipsum dolor sit amet consectetur, adipisicing elit. Commodi maxime a quis culpa, veniam vero vitae nam suscipit praesentium corporis sed pariatur, ipsum adipisci, sequi error saepe corrupti. Tenetur, eligendi! Lorem ipsum dolor sit amet consectetur adipisicing elit. Quaerat quam fuga iusto architecto placeat cum vitae id at porro. Eligendi illo ipsa aut mollitia quis explicabo earum, saepe eaque sapiente?" }) })] }) }) }; const qP = function () { const [e, t] = (0, r.useState)({ Name: "", projectname: "", mobileNumber: "", gmail: "", preference: "", solutionStatement: "" }), n = n => { const { name: r, value: i } = n.target; t({ ...e, [r]: i }) }; return (0, Ve.jsxs)("div", { className: "allharde", children: [(0, Ve.jsx)("div", { className: "head-harde text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contharde", children: (0, Ve.jsx)("div", { className: "body-harde", children: (0, Ve.jsx)("form", { className: "form", onSubmit: t => { t.preventDefault(), console.log(e) }, children: (0, Ve.jsxs)("div", { className: "row harde-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "text", id: "name", name: "Name", value: e.Name, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "name", children: "Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-1 col-md-2 harde", children: [(0, Ve.jsx)("input", { className: "inputhe", type: "text", id: "projectname", name: "projectname", value: e.projectname, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-1  col-md-2 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "tel", id: "num", name: "mobileNumber", value: e.mobileNumber, onChange: n, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelhe text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-1 col-md-2 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "email", id: "gmail", name: "gmail", value: e.gmail, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-1 col-md-2 harde", children: (0, Ve.jsxs)("select", { className: " selecthe", id: "preference", name: "preference", value: e.preference, onChange: n => { t({ ...e, preference: n.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select Preference" }), (0, Ve.jsx)("option", { value: "Option1", children: "Option 1" }), (0, Ve.jsx)("option", { value: "Option2", children: "Option 2" }), (0, Ve.jsx)("option", { value: "Option3", children: "Option 3" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea harde", children: [(0, Ve.jsx)("textarea", { className: "textareaharde ", id: "solutionStatement", cols: "30", rows: "10", name: "solutionStatement", value: e.solutionStatement, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: "labelhtxt  text-nowrap", htmlFor: "solutionStatement", children: "Solution Statement" })] }), (0, Ve.jsx)("div", { className: "form-group button harde", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) }; const HP = function () { const [e, t] = (0, r.useState)({ Name: "", projectname: "", mobileNumber: "", gmail: "", preference: "", solutionStatement: "", php: "", flutter: "", reactjs: "", html: "", python: "", nodejs: "", javascript: "", linux: "", mysql: "", machinelearning: "" }), n = n => { const { name: r, value: i } = n.target; t({ ...e, [r]: i }) }; return (0, Ve.jsxs)("div", { className: "allharde", children: [(0, Ve.jsx)("div", { className: "head-harde text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contharde", children: (0, Ve.jsx)("div", { className: "body-harde", children: (0, Ve.jsx)("form", { className: "form", onSubmit: t => { t.preventDefault(), console.log(e) }, children: (0, Ve.jsxs)("div", { className: "row harde-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "text", id: "name", name: "Name", value: e.Name, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "name", children: "Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: [(0, Ve.jsx)("input", { className: "inputhe", type: "text", id: "projectname", name: "projectname", value: e.projectname, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "tel", id: "num", name: "mobileNumber", value: e.mobileNumber, onChange: n, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelhe text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: [(0, Ve.jsx)("input", { className: " inputhe", type: "email", id: "gmail", name: "gmail", value: e.gmail, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: " labelhe", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-1 harde", children: (0, Ve.jsxs)("select", { className: " selecthe", id: "preference", name: "preference", value: e.preference, onChange: n => { t({ ...e, preference: n.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: " Preference" }), (0, Ve.jsx)("option", { value: "php", children: "PhP" }), (0, Ve.jsx)("option", { value: "python", children: "Python" }), (0, Ve.jsx)("option", { value: "nodejs", children: "Nodejs" }), (0, Ve.jsx)("option", { value: "reactjs", children: "Reactjs" }), (0, Ve.jsx)("option", { value: "javascript", children: "JavaScript" }), (0, Ve.jsx)("option", { value: "flutter", children: "Flutter" }), (0, Ve.jsx)("option", { value: "linux", children: "Linux" }), (0, Ve.jsx)("option", { value: "mysql", children: "Mysql" }), (0, Ve.jsx)("option", { value: "machinelearning", children: "Machine Learning" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea harde", children: [(0, Ve.jsx)("textarea", { className: " textareaharde", id: "solutionStatement", cols: "30", rows: "10", name: "solutionStatement", value: e.solutionStatement, onChange: n, required: !0 }), (0, Ve.jsx)("label", { className: "labelhtxt  text-nowrap", htmlFor: "solutionStatement", children: "Solution Statement" })] }), (0, Ve.jsx)("div", { className: "form-group button harde", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) }; function WP(e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)({ schoolname: "", projectname: "", number: "", email: "", preference: "", what: "" }), [s, o] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (s) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), o(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [s, t]); const a = e => { const { name: t, value: r } = e.target; i({ ...n, [t]: r }) }; return (0, Ve.jsxs)("div", { className: "allschool", children: [(0, Ve.jsx)("div", { className: "head-school text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contschool", children: (0, Ve.jsx)("div", { className: "body-school", children: (0, Ve.jsx)("form", { className: "form", onSubmit: e => { e.preventDefault(), o(!0) }, children: (0, Ve.jsxs)("div", { className: "row school-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "text", id: "schoolname", name: "schoolname", value: n.schoolname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelsc", htmlFor: "schoolname", children: "School Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 col-sm-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "text", id: "projectname", name: "projectname", value: n.projectname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelsc", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 col-sm-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "tel", id: "number", name: "number", value: n.number, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: "labelsc text-nowrap", htmlFor: "number", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-1 col-sm-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "email", id: "email", name: "email", value: n.email, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelsc", htmlFor: "email", children: "Email" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-1 col-sm-1 school", children: (0, Ve.jsxs)("select", { className: "selectsc", id: "preference", name: "preference", value: n.preference, onChange: e => { i({ ...n, preference: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select Preference" }), (0, Ve.jsx)("option", { value: "Option1", children: "Option 1" }), (0, Ve.jsx)("option", { value: "Option2", children: "Option 2" }), (0, Ve.jsx)("option", { value: "Option3", children: "Option 3" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea school", children: [(0, Ve.jsx)("textarea", { className: "textareaschool", id: "what", cols: "30", rows: "10", name: "what", value: n.what, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelstxt text-nowrap", htmlFor: "what", children: "What should we do?" })] }), (0, Ve.jsx)("div", { className: "form-group button school", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) } const KP = function (e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ collegename: "", projectname: "", number: "", email: "", preference: "", whatshoulddo: "", librarymanagement: "", attendancemanagement: "", idnfcmanagement: "", busmanagement: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allschool", children: [(0, Ve.jsx)("div", { className: "head-school text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contschool", children: (0, Ve.jsx)("div", { className: "body-school", children: (0, Ve.jsx)("form", { className: "form", onSubmit: e => { e.preventDefault(), i(!0) }, children: (0, Ve.jsxs)("div", { className: "row school-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "text", id: "name", name: "collegename", value: s.collegename, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "name", children: "College Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "text", id: "projectname", name: "projectname", value: s.projectname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "tel", id: "num", name: "number", value: s.number, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelsc text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "email", id: "gmail", name: "email", value: s.email, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: (0, Ve.jsxs)("select", { className: " selectsc", id: "preference", name: "preference", value: s.preference, onChange: e => { o({ ...s, preference: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select Preference" }), (0, Ve.jsx)("option", { value: "librarymanagement", children: "Library Management" }), (0, Ve.jsx)("option", { value: "attendancemanagement", children: "Attendance Management" }), (0, Ve.jsx)("option", { value: "idnfcmanagement", children: "IDnfc Management" }), (0, Ve.jsx)("option", { value: " busmanagement", children: "Bus Management" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea school", children: [(0, Ve.jsx)("textarea", { className: "textareaschool", id: "what", cols: "30", rows: "10", name: "what", value: s.what, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelstxt text-nowrap", htmlFor: "what", children: "What should we do?" })] }), (0, Ve.jsx)("div", { className: "form-group button school", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) }; function GP(e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ hospitelname: "", projectname: "", number: "", email: "", preference: "", whatshoulddo: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allschool", children: [(0, Ve.jsx)("div", { className: "head-school text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contschool", children: (0, Ve.jsx)("div", { className: "body-school", children: (0, Ve.jsx)("form", { className: "form", onSubmit: e => { e.preventDefault(), i(!0) }, children: (0, Ve.jsxs)("div", { className: "row school-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "text", id: "name", name: "hospitelname", value: s.hospitelname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "name", children: "Hospital Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "text", id: "projectname", name: "projectname", value: s.projectname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "tel", id: "num", name: "number", value: s.number, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelsc text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "email", id: "gmail", name: "email", value: s.email, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: (0, Ve.jsxs)("select", { className: " selectsc", id: "preference", name: "preference", value: s.preference, onChange: e => { o({ ...s, preference: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select Preference" }), (0, Ve.jsx)("option", { value: "Option1", children: "Option 1" }), (0, Ve.jsx)("option", { value: "Option2", children: "Option 2" }), (0, Ve.jsx)("option", { value: "Option3", children: "Option 3" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea school", children: [(0, Ve.jsx)("textarea", { className: "textareaschool", id: "what", cols: "30", rows: "10", name: "what", value: s.what, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelstxt text-nowrap", htmlFor: "what", children: "What should we do?" })] }), (0, Ve.jsx)("div", { className: "form-group button school", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) } function QP(e) { let { setShowModel: t } = e; const [n, i] = (0, r.useState)(!1); (0, r.useEffect)((() => { if (n) { const e = setTimeout((() => { t(!0) }), 100), n = setTimeout((() => { console.log("Cooldown timeout reached. Resetting formSubmitted to false."), i(!1) }), 36e5); return () => { clearTimeout(e), clearTimeout(n) } } }), [n, t]); const [s, o] = (0, r.useState)({ officename: "", projectname: "", number: "", email: "", preference: "", what: "" }), a = e => { const { name: t, value: n } = e.target; o({ ...s, [t]: n }) }; return (0, Ve.jsxs)("div", { className: "allschool", children: [(0, Ve.jsx)("div", { className: "head-school text-nowrap", children: "PROJECT PROPOSAL FORM" }), (0, Ve.jsx)("div", { className: "container contschool", children: (0, Ve.jsx)("div", { className: "body-school", children: (0, Ve.jsx)("form", { className: "form", onSubmit: e => { e.preventDefault(), i(!0) }, children: (0, Ve.jsxs)("div", { className: "row school-project", children: [(0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "text", id: "name", name: "officename", value: s.officename, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "name", children: "Office Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: "inputsc", type: "text", id: "projectname", name: "projectname", value: s.projectname, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "projectname", children: "Project Name" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "tel", id: "num", name: "number", value: s.number, onChange: a, maxLength: "10", pattern: "[0-9]{10}", title: "Please enter a valid mobile number (10 digits)", required: !0 }), (0, Ve.jsx)("label", { className: " labelsc text-nowrap", htmlFor: "num", children: "Mobile Number" })] }), (0, Ve.jsxs)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: [(0, Ve.jsx)("input", { className: " inputsc", type: "email", id: "gmail", name: "email", value: s.email, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: " labelsc", htmlFor: "gmail", children: "Gmail" })] }), (0, Ve.jsx)("div", { className: "form-group col-lg-2 col-md-2 col-sm-1 col-1 school", children: (0, Ve.jsxs)("select", { className: " selectsc", id: "preference", name: "preference", value: s.preference, onChange: e => { o({ ...s, preference: e.target.value }) }, required: !0, children: [(0, Ve.jsx)("option", { value: "", disabled: !0, children: "Select Preference" }), (0, Ve.jsx)("option", { value: "Option1", children: "Option 1" }), (0, Ve.jsx)("option", { value: "Option2", children: "Option 2" }), (0, Ve.jsx)("option", { value: "Option3", children: "Option 3" })] }) }), (0, Ve.jsxs)("div", { className: "form-group textarea school", children: [(0, Ve.jsx)("textarea", { className: "textareaschool", id: "what", cols: "30", rows: "10", name: "what", value: s.what, onChange: a, required: !0 }), (0, Ve.jsx)("label", { className: "labelstxt text-nowrap", htmlFor: "what", children: "What should we do?" })] }), (0, Ve.jsx)("div", { className: "form-group button school", children: (0, Ve.jsx)("button", { type: "submit", className: "btn btn-primary", children: "SUBMIT" }) })] }) }) }) })] }) } const YP = function () { const [e, t] = (0, r.useState)(""), [n, i] = (0, r.useState)(""), [s, o] = (0, r.useState)(!1); return (0, Ve.jsx)("div", { style: { display: "flex", justifyContent: "center", alignItems: "center", height: "90vh" }, children: s ? (0, Ve.jsxs)("div", { children: [(0, Ve.jsx)(Ce, { style: { textDecoration: "none", fontSize: "28px", color: "black", textTransform: "capitalize", padding: "20px", fontWeight: "bolder" }, to: "/admin/free", children: "freelanceadminpanel" }), (0, Ve.jsx)(Ce, { style: { textDecoration: "none", fontSize: "28px", color: "black", textTransform: "capitalize", fontWeight: "bolder" }, to: "/admin/prod", children: "productadminpanel" })] }) : (0, Ve.jsxs)("form", { onSubmit: async t => { t.preventDefault(); try { const t = await Dg.post("http://localhost:5001/api/login", { username: e, password: n }); 200 === t.status && t.data.isAuthenticated ? o(!0) : alert("Invalid username or password") } catch (No) { console.error("Error during login:", No), alert("Login failed. Please try again.") } }, style: { textAlign: "center" }, children: [(0, Ve.jsx)("div", { children: (0, Ve.jsxs)("label", { children: ["Username:", (0, Ve.jsx)("input", { type: "text", value: e, onChange: e => t(e.target.value), style: { margin: "10px", padding: "10px", fontSize: "16px" } })] }) }), (0, Ve.jsx)("div", { children: (0, Ve.jsxs)("label", { children: ["Password:", (0, Ve.jsx)("input", { type: "password", value: n, onChange: e => i(e.target.value), style: { margin: "10px", padding: "10px", fontSize: "16px" } })] }) }), (0, Ve.jsx)("button", { type: "submit", style: { margin: "10px", padding: "10px 20px", fontSize: "16px", fontWeight: "bolder", backgroundColor: "black", color: "white", border: "none", cursor: "pointer" }, children: "Login" })] }) }) }, JP = () => (0, Ve.jsx)("div", { children: "We are currently working hard to bring you the best experience for managing projects. Stay tuned for updates on our latest features and improvements." }), XP = () => { const [e, t] = (0, r.useState)({ title: "", sellerName: "", domainName: "", minPrice: "", maxPrice: "", zipFile: null, images: [], projectDetail: "" }), [n, i] = (0, r.useState)(!1), [s, o] = (0, r.useState)(""), [a, l] = (0, r.useState)(""), c = e => { const { name: n, value: r, files: i } = e.target; t("images" === n ? e => ({ ...e, images: Array.from(i) }) : "zipFile" === n ? e => ({ ...e, zipFile: i[0] }) : e => ({ ...e, [n]: r })) }; return (0, Ve.jsx)("div", { className: "admin-container", children: n ? (0, Ve.jsx)("div", { className: "admin-form-wrapper", children: (0, Ve.jsxs)("form", { onSubmit: async n => { n.preventDefault(); try { const n = new FormData; n.append("title", e.title), n.append("sellerName", e.sellerName), n.append("domainName", e.domainName), n.append("minPrice", e.minPrice), n.append("maxPrice", e.maxPrice), n.append("projectDetail", e.projectDetail), e.zipFile && n.append("zipFile", e.zipFile), e.images.forEach((e => { n.append("images", e) })); 201 === (await Dg.post("http://localhost:5001/api/freelance", n, { headers: { "Content-Type": "multipart/form-data" } })).status ? (console.log("Project added successfully"), t({ title: "", sellerName: "", domainName: "", minPrice: "", maxPrice: "", zipFile: null, images: [], projectDetail: "" })) : console.error("Error adding project") } catch (No) { console.error("Error:", No) } }, children: [(0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Title:" }), (0, Ve.jsx)("input", { type: "text", name: "title", value: e.title, onChange: c, placeholder: "Title", required: !0 })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Seller Name:" }), (0, Ve.jsx)("input", { type: "text", name: "sellerName", value: e.sellerName, onChange: c, placeholder: "Seller Name", required: !0 })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Domain Name:" }), (0, Ve.jsx)("input", { type: "text", name: "domainName", value: e.domainName, onChange: c, placeholder: "Enter the domain name" })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Min Price:" }), (0, Ve.jsx)("input", { type: "text", name: "minPrice", value: e.minPrice, onChange: c, required: !0 })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Max Price:" }), (0, Ve.jsx)("input", { type: "text", name: "maxPrice", value: e.maxPrice, onChange: c, required: !0 })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { htmlFor: "zipFile", children: "Zip File:" }), (0, Ve.jsx)("input", { type: "file", id: "zipFile", name: "zipFile", onChange: c, accept: ".zip", required: !0 })] }), e.zipFile && (0, Ve.jsxs)("div", { className: "admin-file-preview", children: [(0, Ve.jsx)("span", { children: e.zipFile.name }), (0, Ve.jsx)("button", { type: "button", onClick: () => { t((e => ({ ...e, zipFile: null }))) }, children: "Remove" })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { htmlFor: "images", children: "Images:" }), (0, Ve.jsx)("input", { type: "file", id: "images", name: "images", onChange: c, accept: "image/*", multiple: !0, required: !0 })] }), e.images.length > 0 && (0, Ve.jsx)("div", { className: "admin-image-previews", children: e.images.map(((e, n) => (0, Ve.jsxs)("div", { className: "admin-image-preview", children: [(0, Ve.jsx)("img", { src: URL.createObjectURL(e), alt: "Preview ".concat(n), style: { width: "100px", height: "100px" } }), (0, Ve.jsx)("button", { type: "button", onClick: () => (e => { t((t => ({ ...t, images: t.images.filter(((t, n) => n !== e)) }))) })(n), children: "Remove" })] }, n))) }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Project Details:" }), (0, Ve.jsx)("textarea", { name: "projectDetail", value: e.projectDetail, onChange: c, placeholder: "Project Details", required: !0 })] }), (0, Ve.jsx)("div", { className: "admin-form-row", children: (0, Ve.jsx)("button", { type: "submit", children: "Submit" }) })] }) }) : (0, Ve.jsx)("div", { className: "admin-login-wrapper", children: (0, Ve.jsxs)("form", { onSubmit: async e => { e.preventDefault(); try { const e = await Dg.post("http://localhost:5001/api/login", { username: s, password: a }); 200 === e.status && e.data.isAuthenticated ? i(!0) : alert("Invalid username or password") } catch (No) { console.error("Error during login:", No), alert("Login failed. Please try again.") } }, children: [(0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Username:" }), (0, Ve.jsx)("input", { type: "text", name: "username", value: s, onChange: e => o(e.target.value), required: !0 })] }), (0, Ve.jsxs)("div", { className: "admin-form-row", children: [(0, Ve.jsx)("label", { children: "Password:" }), (0, Ve.jsx)("input", { type: "password", name: "password", value: a, onChange: e => l(e.target.value), required: !0 })] }), (0, Ve.jsx)("div", { className: "admin-form-row", children: (0, Ve.jsx)("button", { type: "submit", children: "Login" }) })] }) }) }) }, ZP = () => { const { title: e } = function () { let { matches: e } = r.useContext(Y), t = e[e.length - 1]; return t ? t.params : {} }(), [t, n] = (0, r.useState)(null), [i, s] = (0, r.useState)(""); (0, r.useEffect)((() => { (async () => { try { const t = await Dg.get("http://localhost:5001/api/viewdetail/".concat(e)); n(t.data.project) } catch (t) { s("No project found") } })() }), [e]); const o = async e => { try { if (await (async () => new Promise(((e, t) => { const n = document.createElement("script"); n.src = "https://checkout.razorpay.com/v1/checkout.js", n.async = !0, n.onload = e, n.onerror = t, document.body.appendChild(n) })))(), !window.Razorpay) return void alert("Razorpay SDK is not loaded"); const n = await Dg.post("http://localhost:5001/api/freelance/payment/order", { amount: e }), { id: r, currency: i } = n.data, s = { key: { NODE_ENV: "production", PUBLIC_URL: "", WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0, REACT_APP_FIREBASE_API_KEY: "AIzaSyCAcMKQIWGwcpTZfDfYamOc1TtTsoqDmA0", REACT_APP_FIREBASE_APP_ID: "1:234384132534:web:eecf01823c9eb638b81917", REACT_APP_FIREBASE_AUTH_DOMAIN: "auth-web-3b1e9.firebaseapp.com", REACT_APP_FIREBASE_MESSAGING_SENDER_ID: "234384132534", REACT_APP_FIREBASE_PROJECT_ID: "auth-web-3b1e9", REACT_APP_FIREBASE_STORAGE_BUCKET: "auth-web-3b1e9.appspot.com" }.REACT_APP_RAZORPAY_KEY_ID, amount: e, currency: i, name: t.title, description: t.projectdetail, order_id: r, handler: async function (e) { alert("Payment successful! Payment ID: ".concat(e.razorpay_payment_id)); const n = "http://localhost:5001/".concat(t.zipfile), r = document.createElement("a"); r.href = n, r.setAttribute("download", "project.zip"), document.body.appendChild(r), r.click(), r.remove() }, prefill: { name: "Customer Name", email: "customer@example.com", contact: "9999999999" }, notes: { address: "Customer Address" }, theme: { color: "#3399cc" } }; new window.Razorpay(s).open() } catch (i) { console.error(i) } }; if (i) return (0, Ve.jsx)("div", { children: i }); if (!t) return (0, Ve.jsx)("div", { children: "Loading..." }); const a = e => "http://localhost:5001/".concat(e); return (0, Ve.jsxs)("div", { className: "maim-buy", children: [(0, Ve.jsx)("div", { className: "slider-containers", children: (0, Ve.jsx)("div", { className: "slide-imgs", children: t.images && t.images.length > 0 && t.images.map(((e, n) => (0, Ve.jsx)("img", { src: a(e), width: "50", height: "60", alt: t.title, className: "slider-images", onError: e => e.target.style.display = "none" }, n))) }) }), (0, Ve.jsxs)("div", { className: "buy-contents", children: [(0, Ve.jsxs)("h1", { children: ["Title: ", t.title] }), (0, Ve.jsxs)("p", { children: ["Domain: ", t.domainname] }), (0, Ve.jsxs)("p", { className: "para444", children: [" ", t.projectdetail] }), (0, Ve.jsxs)("button", { onClick: () => o(t.minprice), children: ["Pay \u20b9", t.minprice] }), (0, Ve.jsxs)("button", { onClick: () => o(t.maxprice), children: ["Pay \u20b9", t.maxprice] })] })] }) }; const $P = function () { return (0, Ve.jsx)("div", { className: "page8", children: (0, Ve.jsxs)("div", { className: "container", children: [(0, Ve.jsx)("h1", { className: "heading", children: "Introduction" }), (0, Ve.jsx)("p", { className: "paragraph", children: "Welcome to AFOT's website. By accessing or using our website, you agree to comply with and be bound by these terms and conditions. If you do not agree with any part of these terms, please do not use our website." }), (0, Ve.jsx)("h1", { className: "heading", children: "Acceptance of Terms" }), (0, Ve.jsx)("p", { className: "paragraph", children: "Your access to and use of the website is conditioned on your acceptance of and compliance with these terms. These terms apply to all visitors, users, and others who access or use the website." }), (0, Ve.jsx)("h1", { className: "heading", children: "Use of the Website" }), (0, Ve.jsx)("p", { className: "paragraph", children: "You agree to use the website only for lawful purposes and in a way that does not infringe the rights of others, restrict, or inhibit anyone else's use and enjoyment of the website. You agree not to use the website for any unlawful or fraudulent purpose. If occurs, strict punishment will be carried out to the user." }), (0, Ve.jsx)("h1", { className: "heading", children: "Intellectual Property" }), (0, Ve.jsx)("p", { className: "paragraph", children: "The content, layout, design, data, databases, and graphics on this website are protected by intellectual property laws and are owned by AFOT. You may not reproduce, distribute, or otherwise use any materials on the website without our prior written permission." }), (0, Ve.jsx)("h1", { className: "heading", children: "User Accounts" }), (0, Ve.jsx)("p", { className: "paragraph", children: "To access certain features of our website, you may need to create an account. You must provide accurate and complete information and keep your account information updated. You are responsible for maintaining the confidentiality of your account and password and for restricting access to your computer or device." }), (0, Ve.jsx)("h1", { className: "heading", children: "Privacy Policy" }), (0, Ve.jsx)("p", { className: "paragraph", children: "Our Privacy Policy explains how we collect, use, and share your personal information. By using the website, you agree to the collection and use of information in accordance with our Privacy Policy." }), (0, Ve.jsx)("h1", { className: "heading", children: "Limitation of Liability" }), (0, Ve.jsxs)("p", { className: "paragraph", children: ["AFOT shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, use, goodwill, or other intangible losses, resulting from:", (0, Ve.jsxs)("ul", { className: "list", children: [(0, Ve.jsx)("li", { className: "list-item", children: "Your use or inability to use the website." }), (0, Ve.jsx)("li", { className: "list-item", children: "Any unauthorized access to or use of our servers and/or any personal information stored therein." }), (0, Ve.jsx)("li", { className: "list-item", children: "Any interruption or cessation of transmission to or from the website." }), (0, Ve.jsx)("li", { className: "list-item", children: "Any bugs, viruses, trojan horses, or the like that may be transmitted to or through our website by any third party." }), (0, Ve.jsx)("li", { className: "list-item", children: "Any errors or omissions in any content or for any loss or damage incurred as a result of your use of any content posted, emailed, transmitted, or otherwise made available through the website." })] })] }), (0, Ve.jsx)("h1", { className: "heading", children: "Changes to Terms and Conditions" }), (0, Ve.jsx)("p", { className: "paragraph", children: "We reserve the right, at our sole discretion, to modify or replace these terms at any time. If a revision is material, we will provide at least 30 days' notice before any new terms take effect. What constitutes a material change will be determined at our sole discretion." }), (0, Ve.jsx)("h1", { className: "heading", children: "Governing Law" }), (0, Ve.jsx)("p", { className: "paragraph", children: "These terms shall be governed and construed in accordance with the laws of INDIA, without regard to its conflict of law provisions." }), (0, Ve.jsx)("h1", { className: "heading", children: "Contact Us" }), (0, Ve.jsx)("p", { className: "paragraph contact", children: "If you have any questions about these terms, please contact us at (mobile number add paniko inga)." })] }) }) }; const eI = function () { const [e, t] = (0, r.useState)(!1), [n, i] = (0, r.useState)(!1), [s, o] = (0, r.useState)(!1); (0, r.useEffect)((() => { const e = JSON.parse(localStorage.getItem("isFormSubmitted")) || !1; if (o(e), !e) { const e = setTimeout((() => { i(!0) }), 2e3); return () => clearTimeout(e) } }), []), (0, r.useEffect)((() => { let e; return n || s || (e = setInterval((() => { i(!0) }), 6e4)), () => clearInterval(e) }), [n, s]); const [a, l] = (0, r.useState)([]), [c, u] = (0, r.useState)([]); return (0, r.useEffect)((() => { const e = JSON.parse(localStorage.getItem("projects")) || []; u(e) }), []), (0, Ve.jsx)("div", { className: "back-ground", children: (0, Ve.jsx)("div", { className: "home-div ".concat(n ? "blur-background" : ""), children: (0, Ve.jsxs)(Ee, { children: [(0, Ve.jsx)(So, {}), (0, Ve.jsx)(DP, { showModel: e, setShowModel: t }), (0, Ve.jsxs)(ge, { children: [(0, Ve.jsx)(pe, { path: "/admin", element: (0, Ve.jsx)(YP, {}) }), (0, Ve.jsx)(pe, { path: "/admin/free", element: (0, Ve.jsx)(XP, { addNewProject: e => { const t = [...c, e]; u(t), localStorage.setItem("projects", JSON.stringify(t)) }, projectsList: c, deleteProject: e => { const t = c.filter(((t, n) => n !== e)); u(t), localStorage.setItem("projects", JSON.stringify(t)) } }) }), (0, Ve.jsx)(pe, { path: "/admin/prod", element: (0, Ve.jsx)(JP, { onAddProject: e => { l([...a, e]) } }) }), (0, Ve.jsx)(pe, { path: "*", element: (0, Ve.jsx)(No, {}) }), (0, Ve.jsx)(pe, { path: "/products", element: (0, Ve.jsx)(Co, { projects: a }) }), (0, Ve.jsx)(pe, { path: "/contact", element: (0, Ve.jsx)(Po, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/about", element: (0, Ve.jsx)(ip, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/about/cardone", element: (0, Ve.jsx)(zP, {}) }), (0, Ve.jsx)(pe, { path: "/", element: (0, Ve.jsx)(Ep, {}) }), (0, Ve.jsx)(pe, { path: "/buy", element: (0, Ve.jsx)(vP, { projectList: c }) }), (0, Ve.jsx)(pe, { path: "/sell", element: (0, Ve.jsx)(TP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/project", element: (0, Ve.jsx)(_P, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/paper work", element: (0, Ve.jsx)(LP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/Hackathon", element: (0, Ve.jsx)(FP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/Hardware Bases", element: (0, Ve.jsx)(UP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/modification", element: (0, Ve.jsx)(MP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/modify/hardmodify", element: (0, Ve.jsx)(qP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/modify/softmodify", element: (0, Ve.jsx)(HP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/Managements", element: (0, Ve.jsx)(BP, {}) }), (0, Ve.jsx)(pe, { path: "/manage/school", element: (0, Ve.jsx)(WP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/manage/college", element: (0, Ve.jsx)(KP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/manage/hospital", element: (0, Ve.jsx)(GP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/manage/office", element: (0, Ve.jsx)(QP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "/Company Projects", element: (0, Ve.jsx)(VP, { setShowModel: t }) }), (0, Ve.jsx)(pe, { path: "term", element: (0, Ve.jsx)($P, {}) }), (0, Ve.jsx)(pe, { path: "/freelance/:title", element: (0, Ve.jsx)(ZP, {}) })] })] }) }) }) }; const tI = function () { return (0, Ve.jsx)("div", { className: "preloader" }) }, nI = (0, r.createContext)(); const rI = function () { const [e, t] = (0, r.useState)(!0), [n, i] = (0, r.useState)(!1); return (0, r.useEffect)((() => { setTimeout((() => { t(!1) }), 2e3) }), []), (0, r.useEffect)((() => { const e = window.matchMedia("(prefers-color-scheme:light)"); i(e.matches); const t = e => { i(e.matches) }; return e.addEventListener("change", t), () => e.removeEventListener("change", t) }), []), (0, Ve.jsx)(nI.Provider, { value: { darkTheme: n, toggleTheme: () => { i((e => !e)) } }, children: (0, Ve.jsx)("div", { className: n ? "dark-theme" : "light-theme", children: e ? (0, Ve.jsx)(tI, {}) : (0, Ve.jsx)(eI, {}) }) }) }; var iI = n(115); n.n(iI)().init(); s.createRoot(document.getElementById("root")).render((0, Ve.jsx)(r.StrictMode, { children: (0, Ve.jsx)(rI, {}) })) })() })();
//# sourceMappingURL=main.533a12c2.js.map